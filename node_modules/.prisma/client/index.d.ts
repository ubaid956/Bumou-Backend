
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserDeviceToken
 * 
 */
export type UserDeviceToken = $Result.DefaultSelection<Prisma.$UserDeviceTokenPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model UserMood
 * 
 */
export type UserMood = $Result.DefaultSelection<Prisma.$UserMoodPayload>
/**
 * Model Friendship
 * 
 */
export type Friendship = $Result.DefaultSelection<Prisma.$FriendshipPayload>
/**
 * Model Chatroom
 * 
 */
export type Chatroom = $Result.DefaultSelection<Prisma.$ChatroomPayload>
/**
 * Model ChatroomMessage
 * 
 */
export type ChatroomMessage = $Result.DefaultSelection<Prisma.$ChatroomMessagePayload>
/**
 * Model ChatroomReadStatus
 * 
 */
export type ChatroomReadStatus = $Result.DefaultSelection<Prisma.$ChatroomReadStatusPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model MediaAttachment
 * 
 */
export type MediaAttachment = $Result.DefaultSelection<Prisma.$MediaAttachmentPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Help
 * 
 */
export type Help = $Result.DefaultSelection<Prisma.$HelpPayload>
/**
 * Model HelpMessage
 * 
 */
export type HelpMessage = $Result.DefaultSelection<Prisma.$HelpMessagePayload>
/**
 * Model HelpReadStatus
 * 
 */
export type HelpReadStatus = $Result.DefaultSelection<Prisma.$HelpReadStatusPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model PostViewStatus
 * 
 */
export type PostViewStatus = $Result.DefaultSelection<Prisma.$PostViewStatusPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserType: {
  ADULT: 'ADULT',
  STUDENT: 'STUDENT'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const UserMoodType: {
  VERYGOOD: 'VERYGOOD',
  GOOD: 'GOOD',
  NEUTRAL: 'NEUTRAL',
  BAD: 'BAD',
  VERYBAD: 'VERYBAD'
};

export type UserMoodType = (typeof UserMoodType)[keyof typeof UserMoodType]


export const FriendshipStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type FriendshipStatus = (typeof FriendshipStatus)[keyof typeof FriendshipStatus]


export const ChatroomMessageStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ'
};

export type ChatroomMessageStatus = (typeof ChatroomMessageStatus)[keyof typeof ChatroomMessageStatus]


export const ChatroomMessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  VOICE: 'VOICE',
  FILE: 'FILE',
  LOCATION: 'LOCATION',
  JOIN: 'JOIN',
  CALL: 'CALL'
};

export type ChatroomMessageType = (typeof ChatroomMessageType)[keyof typeof ChatroomMessageType]


export const CallMessageStatus: {
  REQUEST: 'REQUEST',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED',
  ENDED: 'ENDED'
};

export type CallMessageStatus = (typeof CallMessageStatus)[keyof typeof CallMessageStatus]


export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const HelpStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type HelpStatus = (typeof HelpStatus)[keyof typeof HelpStatus]

}

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type UserMoodType = $Enums.UserMoodType

export const UserMoodType: typeof $Enums.UserMoodType

export type FriendshipStatus = $Enums.FriendshipStatus

export const FriendshipStatus: typeof $Enums.FriendshipStatus

export type ChatroomMessageStatus = $Enums.ChatroomMessageStatus

export const ChatroomMessageStatus: typeof $Enums.ChatroomMessageStatus

export type ChatroomMessageType = $Enums.ChatroomMessageType

export const ChatroomMessageType: typeof $Enums.ChatroomMessageType

export type CallMessageStatus = $Enums.CallMessageStatus

export const CallMessageStatus: typeof $Enums.CallMessageStatus

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type HelpStatus = $Enums.HelpStatus

export const HelpStatus: typeof $Enums.HelpStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userDeviceToken`: Exposes CRUD operations for the **UserDeviceToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDeviceTokens
    * const userDeviceTokens = await prisma.userDeviceToken.findMany()
    * ```
    */
  get userDeviceToken(): Prisma.UserDeviceTokenDelegate<ExtArgs>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs>;

  /**
   * `prisma.userMood`: Exposes CRUD operations for the **UserMood** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMoods
    * const userMoods = await prisma.userMood.findMany()
    * ```
    */
  get userMood(): Prisma.UserMoodDelegate<ExtArgs>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<ExtArgs>;

  /**
   * `prisma.chatroom`: Exposes CRUD operations for the **Chatroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatrooms
    * const chatrooms = await prisma.chatroom.findMany()
    * ```
    */
  get chatroom(): Prisma.ChatroomDelegate<ExtArgs>;

  /**
   * `prisma.chatroomMessage`: Exposes CRUD operations for the **ChatroomMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatroomMessages
    * const chatroomMessages = await prisma.chatroomMessage.findMany()
    * ```
    */
  get chatroomMessage(): Prisma.ChatroomMessageDelegate<ExtArgs>;

  /**
   * `prisma.chatroomReadStatus`: Exposes CRUD operations for the **ChatroomReadStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatroomReadStatuses
    * const chatroomReadStatuses = await prisma.chatroomReadStatus.findMany()
    * ```
    */
  get chatroomReadStatus(): Prisma.ChatroomReadStatusDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.mediaAttachment`: Exposes CRUD operations for the **MediaAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaAttachments
    * const mediaAttachments = await prisma.mediaAttachment.findMany()
    * ```
    */
  get mediaAttachment(): Prisma.MediaAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs>;

  /**
   * `prisma.help`: Exposes CRUD operations for the **Help** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Helps
    * const helps = await prisma.help.findMany()
    * ```
    */
  get help(): Prisma.HelpDelegate<ExtArgs>;

  /**
   * `prisma.helpMessage`: Exposes CRUD operations for the **HelpMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpMessages
    * const helpMessages = await prisma.helpMessage.findMany()
    * ```
    */
  get helpMessage(): Prisma.HelpMessageDelegate<ExtArgs>;

  /**
   * `prisma.helpReadStatus`: Exposes CRUD operations for the **HelpReadStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpReadStatuses
    * const helpReadStatuses = await prisma.helpReadStatus.findMany()
    * ```
    */
  get helpReadStatus(): Prisma.HelpReadStatusDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs>;

  /**
   * `prisma.postViewStatus`: Exposes CRUD operations for the **PostViewStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostViewStatuses
    * const postViewStatuses = await prisma.postViewStatus.findMany()
    * ```
    */
  get postViewStatus(): Prisma.PostViewStatusDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserDeviceToken: 'UserDeviceToken',
    UserSession: 'UserSession',
    UserMood: 'UserMood',
    Friendship: 'Friendship',
    Chatroom: 'Chatroom',
    ChatroomMessage: 'ChatroomMessage',
    ChatroomReadStatus: 'ChatroomReadStatus',
    Post: 'Post',
    MediaAttachment: 'MediaAttachment',
    Comment: 'Comment',
    Like: 'Like',
    Help: 'Help',
    HelpMessage: 'HelpMessage',
    HelpReadStatus: 'HelpReadStatus',
    notifications: 'notifications',
    PostViewStatus: 'PostViewStatus'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "userDeviceToken" | "userSession" | "userMood" | "friendship" | "chatroom" | "chatroomMessage" | "chatroomReadStatus" | "post" | "mediaAttachment" | "comment" | "like" | "help" | "helpMessage" | "helpReadStatus" | "notifications" | "postViewStatus"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserDeviceToken: {
        payload: Prisma.$UserDeviceTokenPayload<ExtArgs>
        fields: Prisma.UserDeviceTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDeviceTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDeviceTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload>
          }
          findFirst: {
            args: Prisma.UserDeviceTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDeviceTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload>
          }
          findMany: {
            args: Prisma.UserDeviceTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload>[]
          }
          create: {
            args: Prisma.UserDeviceTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload>
          }
          createMany: {
            args: Prisma.UserDeviceTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDeviceTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload>[]
          }
          delete: {
            args: Prisma.UserDeviceTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload>
          }
          update: {
            args: Prisma.UserDeviceTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload>
          }
          deleteMany: {
            args: Prisma.UserDeviceTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDeviceTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserDeviceTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceTokenPayload>
          }
          aggregate: {
            args: Prisma.UserDeviceTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDeviceToken>
          }
          groupBy: {
            args: Prisma.UserDeviceTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDeviceTokenCountArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceTokenCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      UserMood: {
        payload: Prisma.$UserMoodPayload<ExtArgs>
        fields: Prisma.UserMoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload>
          }
          findFirst: {
            args: Prisma.UserMoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload>
          }
          findMany: {
            args: Prisma.UserMoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload>[]
          }
          create: {
            args: Prisma.UserMoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload>
          }
          createMany: {
            args: Prisma.UserMoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserMoodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload>[]
          }
          delete: {
            args: Prisma.UserMoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload>
          }
          update: {
            args: Prisma.UserMoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload>
          }
          deleteMany: {
            args: Prisma.UserMoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserMoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMoodPayload>
          }
          aggregate: {
            args: Prisma.UserMoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMood>
          }
          groupBy: {
            args: Prisma.UserMoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMoodGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMoodCountArgs<ExtArgs>
            result: $Utils.Optional<UserMoodCountAggregateOutputType> | number
          }
        }
      }
      Friendship: {
        payload: Prisma.$FriendshipPayload<ExtArgs>
        fields: Prisma.FriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findFirst: {
            args: Prisma.FriendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findMany: {
            args: Prisma.FriendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          create: {
            args: Prisma.FriendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          createMany: {
            args: Prisma.FriendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          delete: {
            args: Prisma.FriendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          update: {
            args: Prisma.FriendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          deleteMany: {
            args: Prisma.FriendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.FriendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      Chatroom: {
        payload: Prisma.$ChatroomPayload<ExtArgs>
        fields: Prisma.ChatroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          findFirst: {
            args: Prisma.ChatroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          findMany: {
            args: Prisma.ChatroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>[]
          }
          create: {
            args: Prisma.ChatroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          createMany: {
            args: Prisma.ChatroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>[]
          }
          delete: {
            args: Prisma.ChatroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          update: {
            args: Prisma.ChatroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          deleteMany: {
            args: Prisma.ChatroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          aggregate: {
            args: Prisma.ChatroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatroom>
          }
          groupBy: {
            args: Prisma.ChatroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatroomCountArgs<ExtArgs>
            result: $Utils.Optional<ChatroomCountAggregateOutputType> | number
          }
        }
      }
      ChatroomMessage: {
        payload: Prisma.$ChatroomMessagePayload<ExtArgs>
        fields: Prisma.ChatroomMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatroomMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatroomMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatroomMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatroomMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload>
          }
          findMany: {
            args: Prisma.ChatroomMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload>[]
          }
          create: {
            args: Prisma.ChatroomMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload>
          }
          createMany: {
            args: Prisma.ChatroomMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatroomMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatroomMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload>
          }
          update: {
            args: Prisma.ChatroomMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatroomMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatroomMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatroomMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatroomMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatroomMessage>
          }
          groupBy: {
            args: Prisma.ChatroomMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatroomMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatroomMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatroomMessageCountAggregateOutputType> | number
          }
        }
      }
      ChatroomReadStatus: {
        payload: Prisma.$ChatroomReadStatusPayload<ExtArgs>
        fields: Prisma.ChatroomReadStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatroomReadStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatroomReadStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload>
          }
          findFirst: {
            args: Prisma.ChatroomReadStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatroomReadStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload>
          }
          findMany: {
            args: Prisma.ChatroomReadStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload>[]
          }
          create: {
            args: Prisma.ChatroomReadStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload>
          }
          createMany: {
            args: Prisma.ChatroomReadStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatroomReadStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload>[]
          }
          delete: {
            args: Prisma.ChatroomReadStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload>
          }
          update: {
            args: Prisma.ChatroomReadStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload>
          }
          deleteMany: {
            args: Prisma.ChatroomReadStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatroomReadStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatroomReadStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomReadStatusPayload>
          }
          aggregate: {
            args: Prisma.ChatroomReadStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatroomReadStatus>
          }
          groupBy: {
            args: Prisma.ChatroomReadStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatroomReadStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatroomReadStatusCountArgs<ExtArgs>
            result: $Utils.Optional<ChatroomReadStatusCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      MediaAttachment: {
        payload: Prisma.$MediaAttachmentPayload<ExtArgs>
        fields: Prisma.MediaAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MediaAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload>
          }
          findMany: {
            args: Prisma.MediaAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload>[]
          }
          create: {
            args: Prisma.MediaAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload>
          }
          createMany: {
            args: Prisma.MediaAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload>[]
          }
          delete: {
            args: Prisma.MediaAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload>
          }
          update: {
            args: Prisma.MediaAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MediaAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MediaAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaAttachment>
          }
          groupBy: {
            args: Prisma.MediaAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<MediaAttachmentCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Help: {
        payload: Prisma.$HelpPayload<ExtArgs>
        fields: Prisma.HelpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          findFirst: {
            args: Prisma.HelpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          findMany: {
            args: Prisma.HelpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>[]
          }
          create: {
            args: Prisma.HelpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          createMany: {
            args: Prisma.HelpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>[]
          }
          delete: {
            args: Prisma.HelpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          update: {
            args: Prisma.HelpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          deleteMany: {
            args: Prisma.HelpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          aggregate: {
            args: Prisma.HelpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelp>
          }
          groupBy: {
            args: Prisma.HelpGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpCountArgs<ExtArgs>
            result: $Utils.Optional<HelpCountAggregateOutputType> | number
          }
        }
      }
      HelpMessage: {
        payload: Prisma.$HelpMessagePayload<ExtArgs>
        fields: Prisma.HelpMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload>
          }
          findFirst: {
            args: Prisma.HelpMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload>
          }
          findMany: {
            args: Prisma.HelpMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload>[]
          }
          create: {
            args: Prisma.HelpMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload>
          }
          createMany: {
            args: Prisma.HelpMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload>[]
          }
          delete: {
            args: Prisma.HelpMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload>
          }
          update: {
            args: Prisma.HelpMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload>
          }
          deleteMany: {
            args: Prisma.HelpMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpMessagePayload>
          }
          aggregate: {
            args: Prisma.HelpMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpMessage>
          }
          groupBy: {
            args: Prisma.HelpMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpMessageCountArgs<ExtArgs>
            result: $Utils.Optional<HelpMessageCountAggregateOutputType> | number
          }
        }
      }
      HelpReadStatus: {
        payload: Prisma.$HelpReadStatusPayload<ExtArgs>
        fields: Prisma.HelpReadStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpReadStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpReadStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload>
          }
          findFirst: {
            args: Prisma.HelpReadStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpReadStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload>
          }
          findMany: {
            args: Prisma.HelpReadStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload>[]
          }
          create: {
            args: Prisma.HelpReadStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload>
          }
          createMany: {
            args: Prisma.HelpReadStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpReadStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload>[]
          }
          delete: {
            args: Prisma.HelpReadStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload>
          }
          update: {
            args: Prisma.HelpReadStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload>
          }
          deleteMany: {
            args: Prisma.HelpReadStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpReadStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpReadStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpReadStatusPayload>
          }
          aggregate: {
            args: Prisma.HelpReadStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpReadStatus>
          }
          groupBy: {
            args: Prisma.HelpReadStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpReadStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpReadStatusCountArgs<ExtArgs>
            result: $Utils.Optional<HelpReadStatusCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      PostViewStatus: {
        payload: Prisma.$PostViewStatusPayload<ExtArgs>
        fields: Prisma.PostViewStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostViewStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostViewStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload>
          }
          findFirst: {
            args: Prisma.PostViewStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostViewStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload>
          }
          findMany: {
            args: Prisma.PostViewStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload>[]
          }
          create: {
            args: Prisma.PostViewStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload>
          }
          createMany: {
            args: Prisma.PostViewStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostViewStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload>[]
          }
          delete: {
            args: Prisma.PostViewStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload>
          }
          update: {
            args: Prisma.PostViewStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload>
          }
          deleteMany: {
            args: Prisma.PostViewStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostViewStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostViewStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostViewStatusPayload>
          }
          aggregate: {
            args: Prisma.PostViewStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostViewStatus>
          }
          groupBy: {
            args: Prisma.PostViewStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostViewStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostViewStatusCountArgs<ExtArgs>
            result: $Utils.Optional<PostViewStatusCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    comments: number
    helpReadStatus: number
    likes: number
    posts: number
    chatroomMessage: number
    friends1: number
    friends2: number
    help_messages: number
    helper: number
    requestedHelp: number
    notifications: number
    postViews: number
    deviceTokens: number
    moods: number
    sessions: number
    chatrooms: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    helpReadStatus?: boolean | UserCountOutputTypeCountHelpReadStatusArgs
    likes?: boolean | UserCountOutputTypeCountLikesArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    chatroomMessage?: boolean | UserCountOutputTypeCountChatroomMessageArgs
    friends1?: boolean | UserCountOutputTypeCountFriends1Args
    friends2?: boolean | UserCountOutputTypeCountFriends2Args
    help_messages?: boolean | UserCountOutputTypeCountHelp_messagesArgs
    helper?: boolean | UserCountOutputTypeCountHelperArgs
    requestedHelp?: boolean | UserCountOutputTypeCountRequestedHelpArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    postViews?: boolean | UserCountOutputTypeCountPostViewsArgs
    deviceTokens?: boolean | UserCountOutputTypeCountDeviceTokensArgs
    moods?: boolean | UserCountOutputTypeCountMoodsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    chatrooms?: boolean | UserCountOutputTypeCountChatroomsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHelpReadStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpReadStatusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatroomMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriends1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriends2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHelp_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHelperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestedHelpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostViewStatusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDeviceTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMoodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMoodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomWhereInput
  }


  /**
   * Count Type ChatroomCountOutputType
   */

  export type ChatroomCountOutputType = {
    readStatuses: number
    messages: number
    members: number
  }

  export type ChatroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    readStatuses?: boolean | ChatroomCountOutputTypeCountReadStatusesArgs
    messages?: boolean | ChatroomCountOutputTypeCountMessagesArgs
    members?: boolean | ChatroomCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomCountOutputType
     */
    select?: ChatroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeCountReadStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomReadStatusWhereInput
  }

  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomMessageWhereInput
  }

  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ChatroomMessageCountOutputType
   */

  export type ChatroomMessageCountOutputType = {
    readBy: number
    chat_message: number
  }

  export type ChatroomMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    readBy?: boolean | ChatroomMessageCountOutputTypeCountReadByArgs
    chat_message?: boolean | ChatroomMessageCountOutputTypeCountChat_messageArgs
  }

  // Custom InputTypes
  /**
   * ChatroomMessageCountOutputType without action
   */
  export type ChatroomMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessageCountOutputType
     */
    select?: ChatroomMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatroomMessageCountOutputType without action
   */
  export type ChatroomMessageCountOutputTypeCountReadByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomReadStatusWhereInput
  }

  /**
   * ChatroomMessageCountOutputType without action
   */
  export type ChatroomMessageCountOutputTypeCountChat_messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomMessageWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
    likes: number
    mediaAttachments: number
    viewStatus: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    likes?: boolean | PostCountOutputTypeCountLikesArgs
    mediaAttachments?: boolean | PostCountOutputTypeCountMediaAttachmentsArgs
    viewStatus?: boolean | PostCountOutputTypeCountViewStatusArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountMediaAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAttachmentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountViewStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostViewStatusWhereInput
  }


  /**
   * Count Type HelpCountOutputType
   */

  export type HelpCountOutputType = {
    helpReadStatus: number
    messages: number
  }

  export type HelpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpReadStatus?: boolean | HelpCountOutputTypeCountHelpReadStatusArgs
    messages?: boolean | HelpCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * HelpCountOutputType without action
   */
  export type HelpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCountOutputType
     */
    select?: HelpCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelpCountOutputType without action
   */
  export type HelpCountOutputTypeCountHelpReadStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpReadStatusWhereInput
  }

  /**
   * HelpCountOutputType without action
   */
  export type HelpCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpMessageWhereInput
  }


  /**
   * Count Type HelpMessageCountOutputType
   */

  export type HelpMessageCountOutputType = {
    readBy: number
  }

  export type HelpMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    readBy?: boolean | HelpMessageCountOutputTypeCountReadByArgs
  }

  // Custom InputTypes
  /**
   * HelpMessageCountOutputType without action
   */
  export type HelpMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessageCountOutputType
     */
    select?: HelpMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelpMessageCountOutputType without action
   */
  export type HelpMessageCountOutputTypeCountReadByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpReadStatusWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    username: string | null
    phone: string | null
    password: string | null
    userType: $Enums.UserType | null
    local: string | null
    firstName: string | null
    lastName: string | null
    profilePicture: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    schoolName: string | null
    className: string | null
    teacherName: string | null
    isVerified: boolean | null
    isBlocked: boolean | null
    isOnline: boolean | null
    isDeleted: boolean | null
    isHelping: boolean | null
    Aliyun_token: string | null
    device_type: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    username: string | null
    phone: string | null
    password: string | null
    userType: $Enums.UserType | null
    local: string | null
    firstName: string | null
    lastName: string | null
    profilePicture: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    schoolName: string | null
    className: string | null
    teacherName: string | null
    isVerified: boolean | null
    isBlocked: boolean | null
    isOnline: boolean | null
    isDeleted: boolean | null
    isHelping: boolean | null
    Aliyun_token: string | null
    device_type: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    username: number
    phone: number
    password: number
    userType: number
    local: number
    firstName: number
    lastName: number
    profilePicture: number
    address: number
    city: number
    state: number
    zip: number
    country: number
    schoolName: number
    className: number
    teacherName: number
    isVerified: number
    isBlocked: number
    isOnline: number
    isDeleted: number
    isHelping: number
    Aliyun_token: number
    device_type: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    username?: true
    phone?: true
    password?: true
    userType?: true
    local?: true
    firstName?: true
    lastName?: true
    profilePicture?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    schoolName?: true
    className?: true
    teacherName?: true
    isVerified?: true
    isBlocked?: true
    isOnline?: true
    isDeleted?: true
    isHelping?: true
    Aliyun_token?: true
    device_type?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    username?: true
    phone?: true
    password?: true
    userType?: true
    local?: true
    firstName?: true
    lastName?: true
    profilePicture?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    schoolName?: true
    className?: true
    teacherName?: true
    isVerified?: true
    isBlocked?: true
    isOnline?: true
    isDeleted?: true
    isHelping?: true
    Aliyun_token?: true
    device_type?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    username?: true
    phone?: true
    password?: true
    userType?: true
    local?: true
    firstName?: true
    lastName?: true
    profilePicture?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    schoolName?: true
    className?: true
    teacherName?: true
    isVerified?: true
    isBlocked?: true
    isOnline?: true
    isDeleted?: true
    isHelping?: true
    Aliyun_token?: true
    device_type?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    email: string
    username: string
    phone: string
    password: string
    userType: $Enums.UserType
    local: string | null
    firstName: string
    lastName: string
    profilePicture: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    schoolName: string | null
    className: string | null
    teacherName: string | null
    isVerified: boolean
    isBlocked: boolean
    isOnline: boolean
    isDeleted: boolean
    isHelping: boolean
    Aliyun_token: string | null
    device_type: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    username?: boolean
    phone?: boolean
    password?: boolean
    userType?: boolean
    local?: boolean
    firstName?: boolean
    lastName?: boolean
    profilePicture?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    schoolName?: boolean
    className?: boolean
    teacherName?: boolean
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: boolean
    device_type?: boolean
    comments?: boolean | User$commentsArgs<ExtArgs>
    helpReadStatus?: boolean | User$helpReadStatusArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    chatroomMessage?: boolean | User$chatroomMessageArgs<ExtArgs>
    friends1?: boolean | User$friends1Args<ExtArgs>
    friends2?: boolean | User$friends2Args<ExtArgs>
    help_messages?: boolean | User$help_messagesArgs<ExtArgs>
    helper?: boolean | User$helperArgs<ExtArgs>
    requestedHelp?: boolean | User$requestedHelpArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    postViews?: boolean | User$postViewsArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    moods?: boolean | User$moodsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    chatrooms?: boolean | User$chatroomsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    username?: boolean
    phone?: boolean
    password?: boolean
    userType?: boolean
    local?: boolean
    firstName?: boolean
    lastName?: boolean
    profilePicture?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    schoolName?: boolean
    className?: boolean
    teacherName?: boolean
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: boolean
    device_type?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    username?: boolean
    phone?: boolean
    password?: boolean
    userType?: boolean
    local?: boolean
    firstName?: boolean
    lastName?: boolean
    profilePicture?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    schoolName?: boolean
    className?: boolean
    teacherName?: boolean
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: boolean
    device_type?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | User$commentsArgs<ExtArgs>
    helpReadStatus?: boolean | User$helpReadStatusArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    chatroomMessage?: boolean | User$chatroomMessageArgs<ExtArgs>
    friends1?: boolean | User$friends1Args<ExtArgs>
    friends2?: boolean | User$friends2Args<ExtArgs>
    help_messages?: boolean | User$help_messagesArgs<ExtArgs>
    helper?: boolean | User$helperArgs<ExtArgs>
    requestedHelp?: boolean | User$requestedHelpArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    postViews?: boolean | User$postViewsArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    moods?: boolean | User$moodsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    chatrooms?: boolean | User$chatroomsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      helpReadStatus: Prisma.$HelpReadStatusPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      chatroomMessage: Prisma.$ChatroomMessagePayload<ExtArgs>[]
      friends1: Prisma.$FriendshipPayload<ExtArgs>[]
      friends2: Prisma.$FriendshipPayload<ExtArgs>[]
      help_messages: Prisma.$HelpMessagePayload<ExtArgs>[]
      helper: Prisma.$HelpPayload<ExtArgs>[]
      requestedHelp: Prisma.$HelpPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      postViews: Prisma.$PostViewStatusPayload<ExtArgs>[]
      deviceTokens: Prisma.$UserDeviceTokenPayload<ExtArgs>[]
      moods: Prisma.$UserMoodPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      chatrooms: Prisma.$ChatroomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      email: string
      username: string
      phone: string
      password: string
      userType: $Enums.UserType
      local: string | null
      firstName: string
      lastName: string
      profilePicture: string | null
      address: string | null
      city: string | null
      state: string | null
      zip: string | null
      country: string | null
      schoolName: string | null
      className: string | null
      teacherName: string | null
      isVerified: boolean
      isBlocked: boolean
      isOnline: boolean
      isDeleted: boolean
      isHelping: boolean
      Aliyun_token: string | null
      device_type: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    helpReadStatus<T extends User$helpReadStatusArgs<ExtArgs> = {}>(args?: Subset<T, User$helpReadStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends User$likesArgs<ExtArgs> = {}>(args?: Subset<T, User$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    chatroomMessage<T extends User$chatroomMessageArgs<ExtArgs> = {}>(args?: Subset<T, User$chatroomMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findMany"> | Null>
    friends1<T extends User$friends1Args<ExtArgs> = {}>(args?: Subset<T, User$friends1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    friends2<T extends User$friends2Args<ExtArgs> = {}>(args?: Subset<T, User$friends2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    help_messages<T extends User$help_messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$help_messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "findMany"> | Null>
    helper<T extends User$helperArgs<ExtArgs> = {}>(args?: Subset<T, User$helperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findMany"> | Null>
    requestedHelp<T extends User$requestedHelpArgs<ExtArgs> = {}>(args?: Subset<T, User$requestedHelpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany"> | Null>
    postViews<T extends User$postViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$postViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "findMany"> | Null>
    deviceTokens<T extends User$deviceTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$deviceTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "findMany"> | Null>
    moods<T extends User$moodsArgs<ExtArgs> = {}>(args?: Subset<T, User$moodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany"> | Null>
    chatrooms<T extends User$chatroomsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatroomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly userType: FieldRef<"User", 'UserType'>
    readonly local: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly zip: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly schoolName: FieldRef<"User", 'String'>
    readonly className: FieldRef<"User", 'String'>
    readonly teacherName: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly isBlocked: FieldRef<"User", 'Boolean'>
    readonly isOnline: FieldRef<"User", 'Boolean'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly isHelping: FieldRef<"User", 'Boolean'>
    readonly Aliyun_token: FieldRef<"User", 'String'>
    readonly device_type: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.helpReadStatus
   */
  export type User$helpReadStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    where?: HelpReadStatusWhereInput
    orderBy?: HelpReadStatusOrderByWithRelationInput | HelpReadStatusOrderByWithRelationInput[]
    cursor?: HelpReadStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpReadStatusScalarFieldEnum | HelpReadStatusScalarFieldEnum[]
  }

  /**
   * User.likes
   */
  export type User$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.chatroomMessage
   */
  export type User$chatroomMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    where?: ChatroomMessageWhereInput
    orderBy?: ChatroomMessageOrderByWithRelationInput | ChatroomMessageOrderByWithRelationInput[]
    cursor?: ChatroomMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatroomMessageScalarFieldEnum | ChatroomMessageScalarFieldEnum[]
  }

  /**
   * User.friends1
   */
  export type User$friends1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.friends2
   */
  export type User$friends2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.help_messages
   */
  export type User$help_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    where?: HelpMessageWhereInput
    orderBy?: HelpMessageOrderByWithRelationInput | HelpMessageOrderByWithRelationInput[]
    cursor?: HelpMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpMessageScalarFieldEnum | HelpMessageScalarFieldEnum[]
  }

  /**
   * User.helper
   */
  export type User$helperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    where?: HelpWhereInput
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    cursor?: HelpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpScalarFieldEnum | HelpScalarFieldEnum[]
  }

  /**
   * User.requestedHelp
   */
  export type User$requestedHelpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    where?: HelpWhereInput
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    cursor?: HelpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpScalarFieldEnum | HelpScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * User.postViews
   */
  export type User$postViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    where?: PostViewStatusWhereInput
    orderBy?: PostViewStatusOrderByWithRelationInput | PostViewStatusOrderByWithRelationInput[]
    cursor?: PostViewStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostViewStatusScalarFieldEnum | PostViewStatusScalarFieldEnum[]
  }

  /**
   * User.deviceTokens
   */
  export type User$deviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    where?: UserDeviceTokenWhereInput
    orderBy?: UserDeviceTokenOrderByWithRelationInput | UserDeviceTokenOrderByWithRelationInput[]
    cursor?: UserDeviceTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDeviceTokenScalarFieldEnum | UserDeviceTokenScalarFieldEnum[]
  }

  /**
   * User.moods
   */
  export type User$moodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    where?: UserMoodWhereInput
    orderBy?: UserMoodOrderByWithRelationInput | UserMoodOrderByWithRelationInput[]
    cursor?: UserMoodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMoodScalarFieldEnum | UserMoodScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.chatrooms
   */
  export type User$chatroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    where?: ChatroomWhereInput
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    cursor?: ChatroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserDeviceToken
   */

  export type AggregateUserDeviceToken = {
    _count: UserDeviceTokenCountAggregateOutputType | null
    _min: UserDeviceTokenMinAggregateOutputType | null
    _max: UserDeviceTokenMaxAggregateOutputType | null
  }

  export type UserDeviceTokenMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    token: string | null
    device_type: string | null
  }

  export type UserDeviceTokenMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    token: string | null
    device_type: string | null
  }

  export type UserDeviceTokenCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    token: number
    device_type: number
    _all: number
  }


  export type UserDeviceTokenMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    token?: true
    device_type?: true
  }

  export type UserDeviceTokenMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    token?: true
    device_type?: true
  }

  export type UserDeviceTokenCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    token?: true
    device_type?: true
    _all?: true
  }

  export type UserDeviceTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDeviceToken to aggregate.
     */
    where?: UserDeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceTokens to fetch.
     */
    orderBy?: UserDeviceTokenOrderByWithRelationInput | UserDeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDeviceTokens
    **/
    _count?: true | UserDeviceTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDeviceTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDeviceTokenMaxAggregateInputType
  }

  export type GetUserDeviceTokenAggregateType<T extends UserDeviceTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDeviceToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDeviceToken[P]>
      : GetScalarType<T[P], AggregateUserDeviceToken[P]>
  }




  export type UserDeviceTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDeviceTokenWhereInput
    orderBy?: UserDeviceTokenOrderByWithAggregationInput | UserDeviceTokenOrderByWithAggregationInput[]
    by: UserDeviceTokenScalarFieldEnum[] | UserDeviceTokenScalarFieldEnum
    having?: UserDeviceTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDeviceTokenCountAggregateInputType | true
    _min?: UserDeviceTokenMinAggregateInputType
    _max?: UserDeviceTokenMaxAggregateInputType
  }

  export type UserDeviceTokenGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    token: string
    device_type: string
    _count: UserDeviceTokenCountAggregateOutputType | null
    _min: UserDeviceTokenMinAggregateOutputType | null
    _max: UserDeviceTokenMaxAggregateOutputType | null
  }

  type GetUserDeviceTokenGroupByPayload<T extends UserDeviceTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDeviceTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDeviceTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDeviceTokenGroupByOutputType[P]>
            : GetScalarType<T[P], UserDeviceTokenGroupByOutputType[P]>
        }
      >
    >


  export type UserDeviceTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    token?: boolean
    device_type?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDeviceToken"]>

  export type UserDeviceTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    token?: boolean
    device_type?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDeviceToken"]>

  export type UserDeviceTokenSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    token?: boolean
    device_type?: boolean
  }

  export type UserDeviceTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDeviceTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserDeviceTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDeviceToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      token: string
      device_type: string
    }, ExtArgs["result"]["userDeviceToken"]>
    composites: {}
  }

  type UserDeviceTokenGetPayload<S extends boolean | null | undefined | UserDeviceTokenDefaultArgs> = $Result.GetResult<Prisma.$UserDeviceTokenPayload, S>

  type UserDeviceTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserDeviceTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserDeviceTokenCountAggregateInputType | true
    }

  export interface UserDeviceTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDeviceToken'], meta: { name: 'UserDeviceToken' } }
    /**
     * Find zero or one UserDeviceToken that matches the filter.
     * @param {UserDeviceTokenFindUniqueArgs} args - Arguments to find a UserDeviceToken
     * @example
     * // Get one UserDeviceToken
     * const userDeviceToken = await prisma.userDeviceToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDeviceTokenFindUniqueArgs>(args: SelectSubset<T, UserDeviceTokenFindUniqueArgs<ExtArgs>>): Prisma__UserDeviceTokenClient<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserDeviceToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserDeviceTokenFindUniqueOrThrowArgs} args - Arguments to find a UserDeviceToken
     * @example
     * // Get one UserDeviceToken
     * const userDeviceToken = await prisma.userDeviceToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDeviceTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDeviceTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDeviceTokenClient<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserDeviceToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceTokenFindFirstArgs} args - Arguments to find a UserDeviceToken
     * @example
     * // Get one UserDeviceToken
     * const userDeviceToken = await prisma.userDeviceToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDeviceTokenFindFirstArgs>(args?: SelectSubset<T, UserDeviceTokenFindFirstArgs<ExtArgs>>): Prisma__UserDeviceTokenClient<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserDeviceToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceTokenFindFirstOrThrowArgs} args - Arguments to find a UserDeviceToken
     * @example
     * // Get one UserDeviceToken
     * const userDeviceToken = await prisma.userDeviceToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDeviceTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDeviceTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDeviceTokenClient<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserDeviceTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDeviceTokens
     * const userDeviceTokens = await prisma.userDeviceToken.findMany()
     * 
     * // Get first 10 UserDeviceTokens
     * const userDeviceTokens = await prisma.userDeviceToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDeviceTokenWithIdOnly = await prisma.userDeviceToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserDeviceTokenFindManyArgs>(args?: SelectSubset<T, UserDeviceTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserDeviceToken.
     * @param {UserDeviceTokenCreateArgs} args - Arguments to create a UserDeviceToken.
     * @example
     * // Create one UserDeviceToken
     * const UserDeviceToken = await prisma.userDeviceToken.create({
     *   data: {
     *     // ... data to create a UserDeviceToken
     *   }
     * })
     * 
     */
    create<T extends UserDeviceTokenCreateArgs>(args: SelectSubset<T, UserDeviceTokenCreateArgs<ExtArgs>>): Prisma__UserDeviceTokenClient<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserDeviceTokens.
     * @param {UserDeviceTokenCreateManyArgs} args - Arguments to create many UserDeviceTokens.
     * @example
     * // Create many UserDeviceTokens
     * const userDeviceToken = await prisma.userDeviceToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDeviceTokenCreateManyArgs>(args?: SelectSubset<T, UserDeviceTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDeviceTokens and returns the data saved in the database.
     * @param {UserDeviceTokenCreateManyAndReturnArgs} args - Arguments to create many UserDeviceTokens.
     * @example
     * // Create many UserDeviceTokens
     * const userDeviceToken = await prisma.userDeviceToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDeviceTokens and only return the `id`
     * const userDeviceTokenWithIdOnly = await prisma.userDeviceToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDeviceTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDeviceTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserDeviceToken.
     * @param {UserDeviceTokenDeleteArgs} args - Arguments to delete one UserDeviceToken.
     * @example
     * // Delete one UserDeviceToken
     * const UserDeviceToken = await prisma.userDeviceToken.delete({
     *   where: {
     *     // ... filter to delete one UserDeviceToken
     *   }
     * })
     * 
     */
    delete<T extends UserDeviceTokenDeleteArgs>(args: SelectSubset<T, UserDeviceTokenDeleteArgs<ExtArgs>>): Prisma__UserDeviceTokenClient<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserDeviceToken.
     * @param {UserDeviceTokenUpdateArgs} args - Arguments to update one UserDeviceToken.
     * @example
     * // Update one UserDeviceToken
     * const userDeviceToken = await prisma.userDeviceToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDeviceTokenUpdateArgs>(args: SelectSubset<T, UserDeviceTokenUpdateArgs<ExtArgs>>): Prisma__UserDeviceTokenClient<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserDeviceTokens.
     * @param {UserDeviceTokenDeleteManyArgs} args - Arguments to filter UserDeviceTokens to delete.
     * @example
     * // Delete a few UserDeviceTokens
     * const { count } = await prisma.userDeviceToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeviceTokenDeleteManyArgs>(args?: SelectSubset<T, UserDeviceTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDeviceTokens
     * const userDeviceToken = await prisma.userDeviceToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDeviceTokenUpdateManyArgs>(args: SelectSubset<T, UserDeviceTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserDeviceToken.
     * @param {UserDeviceTokenUpsertArgs} args - Arguments to update or create a UserDeviceToken.
     * @example
     * // Update or create a UserDeviceToken
     * const userDeviceToken = await prisma.userDeviceToken.upsert({
     *   create: {
     *     // ... data to create a UserDeviceToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDeviceToken we want to update
     *   }
     * })
     */
    upsert<T extends UserDeviceTokenUpsertArgs>(args: SelectSubset<T, UserDeviceTokenUpsertArgs<ExtArgs>>): Prisma__UserDeviceTokenClient<$Result.GetResult<Prisma.$UserDeviceTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserDeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceTokenCountArgs} args - Arguments to filter UserDeviceTokens to count.
     * @example
     * // Count the number of UserDeviceTokens
     * const count = await prisma.userDeviceToken.count({
     *   where: {
     *     // ... the filter for the UserDeviceTokens we want to count
     *   }
     * })
    **/
    count<T extends UserDeviceTokenCountArgs>(
      args?: Subset<T, UserDeviceTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDeviceTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDeviceTokenAggregateArgs>(args: Subset<T, UserDeviceTokenAggregateArgs>): Prisma.PrismaPromise<GetUserDeviceTokenAggregateType<T>>

    /**
     * Group by UserDeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDeviceTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDeviceTokenGroupByArgs['orderBy'] }
        : { orderBy?: UserDeviceTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDeviceTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDeviceTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDeviceToken model
   */
  readonly fields: UserDeviceTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDeviceToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDeviceTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDeviceToken model
   */ 
  interface UserDeviceTokenFieldRefs {
    readonly id: FieldRef<"UserDeviceToken", 'String'>
    readonly createdAt: FieldRef<"UserDeviceToken", 'DateTime'>
    readonly updatedAt: FieldRef<"UserDeviceToken", 'DateTime'>
    readonly userId: FieldRef<"UserDeviceToken", 'String'>
    readonly token: FieldRef<"UserDeviceToken", 'String'>
    readonly device_type: FieldRef<"UserDeviceToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserDeviceToken findUnique
   */
  export type UserDeviceTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceToken to fetch.
     */
    where: UserDeviceTokenWhereUniqueInput
  }

  /**
   * UserDeviceToken findUniqueOrThrow
   */
  export type UserDeviceTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceToken to fetch.
     */
    where: UserDeviceTokenWhereUniqueInput
  }

  /**
   * UserDeviceToken findFirst
   */
  export type UserDeviceTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceToken to fetch.
     */
    where?: UserDeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceTokens to fetch.
     */
    orderBy?: UserDeviceTokenOrderByWithRelationInput | UserDeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDeviceTokens.
     */
    cursor?: UserDeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDeviceTokens.
     */
    distinct?: UserDeviceTokenScalarFieldEnum | UserDeviceTokenScalarFieldEnum[]
  }

  /**
   * UserDeviceToken findFirstOrThrow
   */
  export type UserDeviceTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceToken to fetch.
     */
    where?: UserDeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceTokens to fetch.
     */
    orderBy?: UserDeviceTokenOrderByWithRelationInput | UserDeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDeviceTokens.
     */
    cursor?: UserDeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDeviceTokens.
     */
    distinct?: UserDeviceTokenScalarFieldEnum | UserDeviceTokenScalarFieldEnum[]
  }

  /**
   * UserDeviceToken findMany
   */
  export type UserDeviceTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceTokens to fetch.
     */
    where?: UserDeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceTokens to fetch.
     */
    orderBy?: UserDeviceTokenOrderByWithRelationInput | UserDeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDeviceTokens.
     */
    cursor?: UserDeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceTokens.
     */
    skip?: number
    distinct?: UserDeviceTokenScalarFieldEnum | UserDeviceTokenScalarFieldEnum[]
  }

  /**
   * UserDeviceToken create
   */
  export type UserDeviceTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDeviceToken.
     */
    data: XOR<UserDeviceTokenCreateInput, UserDeviceTokenUncheckedCreateInput>
  }

  /**
   * UserDeviceToken createMany
   */
  export type UserDeviceTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDeviceTokens.
     */
    data: UserDeviceTokenCreateManyInput | UserDeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDeviceToken createManyAndReturn
   */
  export type UserDeviceTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserDeviceTokens.
     */
    data: UserDeviceTokenCreateManyInput | UserDeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDeviceToken update
   */
  export type UserDeviceTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDeviceToken.
     */
    data: XOR<UserDeviceTokenUpdateInput, UserDeviceTokenUncheckedUpdateInput>
    /**
     * Choose, which UserDeviceToken to update.
     */
    where: UserDeviceTokenWhereUniqueInput
  }

  /**
   * UserDeviceToken updateMany
   */
  export type UserDeviceTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDeviceTokens.
     */
    data: XOR<UserDeviceTokenUpdateManyMutationInput, UserDeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which UserDeviceTokens to update
     */
    where?: UserDeviceTokenWhereInput
  }

  /**
   * UserDeviceToken upsert
   */
  export type UserDeviceTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDeviceToken to update in case it exists.
     */
    where: UserDeviceTokenWhereUniqueInput
    /**
     * In case the UserDeviceToken found by the `where` argument doesn't exist, create a new UserDeviceToken with this data.
     */
    create: XOR<UserDeviceTokenCreateInput, UserDeviceTokenUncheckedCreateInput>
    /**
     * In case the UserDeviceToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDeviceTokenUpdateInput, UserDeviceTokenUncheckedUpdateInput>
  }

  /**
   * UserDeviceToken delete
   */
  export type UserDeviceTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
    /**
     * Filter which UserDeviceToken to delete.
     */
    where: UserDeviceTokenWhereUniqueInput
  }

  /**
   * UserDeviceToken deleteMany
   */
  export type UserDeviceTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDeviceTokens to delete
     */
    where?: UserDeviceTokenWhereInput
  }

  /**
   * UserDeviceToken without action
   */
  export type UserDeviceTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceToken
     */
    select?: UserDeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceTokenInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    token: string | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    token: string | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    token: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    token?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    token?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    token?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    token: string
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    token?: boolean
  }

  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      token: string
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */ 
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly token: FieldRef<"UserSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model UserMood
   */

  export type AggregateUserMood = {
    _count: UserMoodCountAggregateOutputType | null
    _min: UserMoodMinAggregateOutputType | null
    _max: UserMoodMaxAggregateOutputType | null
  }

  export type UserMoodMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    mood: $Enums.UserMoodType | null
    note: string | null
  }

  export type UserMoodMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    mood: $Enums.UserMoodType | null
    note: string | null
  }

  export type UserMoodCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    mood: number
    note: number
    _all: number
  }


  export type UserMoodMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    mood?: true
    note?: true
  }

  export type UserMoodMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    mood?: true
    note?: true
  }

  export type UserMoodCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    mood?: true
    note?: true
    _all?: true
  }

  export type UserMoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMood to aggregate.
     */
    where?: UserMoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMoods to fetch.
     */
    orderBy?: UserMoodOrderByWithRelationInput | UserMoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMoods
    **/
    _count?: true | UserMoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMoodMaxAggregateInputType
  }

  export type GetUserMoodAggregateType<T extends UserMoodAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMood[P]>
      : GetScalarType<T[P], AggregateUserMood[P]>
  }




  export type UserMoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMoodWhereInput
    orderBy?: UserMoodOrderByWithAggregationInput | UserMoodOrderByWithAggregationInput[]
    by: UserMoodScalarFieldEnum[] | UserMoodScalarFieldEnum
    having?: UserMoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMoodCountAggregateInputType | true
    _min?: UserMoodMinAggregateInputType
    _max?: UserMoodMaxAggregateInputType
  }

  export type UserMoodGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    mood: $Enums.UserMoodType
    note: string | null
    _count: UserMoodCountAggregateOutputType | null
    _min: UserMoodMinAggregateOutputType | null
    _max: UserMoodMaxAggregateOutputType | null
  }

  type GetUserMoodGroupByPayload<T extends UserMoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMoodGroupByOutputType[P]>
            : GetScalarType<T[P], UserMoodGroupByOutputType[P]>
        }
      >
    >


  export type UserMoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    mood?: boolean
    note?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMood"]>

  export type UserMoodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    mood?: boolean
    note?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMood"]>

  export type UserMoodSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    mood?: boolean
    note?: boolean
  }

  export type UserMoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserMoodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserMoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMood"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      mood: $Enums.UserMoodType
      note: string | null
    }, ExtArgs["result"]["userMood"]>
    composites: {}
  }

  type UserMoodGetPayload<S extends boolean | null | undefined | UserMoodDefaultArgs> = $Result.GetResult<Prisma.$UserMoodPayload, S>

  type UserMoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserMoodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserMoodCountAggregateInputType | true
    }

  export interface UserMoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMood'], meta: { name: 'UserMood' } }
    /**
     * Find zero or one UserMood that matches the filter.
     * @param {UserMoodFindUniqueArgs} args - Arguments to find a UserMood
     * @example
     * // Get one UserMood
     * const userMood = await prisma.userMood.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMoodFindUniqueArgs>(args: SelectSubset<T, UserMoodFindUniqueArgs<ExtArgs>>): Prisma__UserMoodClient<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserMood that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserMoodFindUniqueOrThrowArgs} args - Arguments to find a UserMood
     * @example
     * // Get one UserMood
     * const userMood = await prisma.userMood.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMoodFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMoodClient<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserMood that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMoodFindFirstArgs} args - Arguments to find a UserMood
     * @example
     * // Get one UserMood
     * const userMood = await prisma.userMood.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMoodFindFirstArgs>(args?: SelectSubset<T, UserMoodFindFirstArgs<ExtArgs>>): Prisma__UserMoodClient<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserMood that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMoodFindFirstOrThrowArgs} args - Arguments to find a UserMood
     * @example
     * // Get one UserMood
     * const userMood = await prisma.userMood.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMoodFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMoodClient<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserMoods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMoods
     * const userMoods = await prisma.userMood.findMany()
     * 
     * // Get first 10 UserMoods
     * const userMoods = await prisma.userMood.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMoodWithIdOnly = await prisma.userMood.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMoodFindManyArgs>(args?: SelectSubset<T, UserMoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserMood.
     * @param {UserMoodCreateArgs} args - Arguments to create a UserMood.
     * @example
     * // Create one UserMood
     * const UserMood = await prisma.userMood.create({
     *   data: {
     *     // ... data to create a UserMood
     *   }
     * })
     * 
     */
    create<T extends UserMoodCreateArgs>(args: SelectSubset<T, UserMoodCreateArgs<ExtArgs>>): Prisma__UserMoodClient<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserMoods.
     * @param {UserMoodCreateManyArgs} args - Arguments to create many UserMoods.
     * @example
     * // Create many UserMoods
     * const userMood = await prisma.userMood.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMoodCreateManyArgs>(args?: SelectSubset<T, UserMoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserMoods and returns the data saved in the database.
     * @param {UserMoodCreateManyAndReturnArgs} args - Arguments to create many UserMoods.
     * @example
     * // Create many UserMoods
     * const userMood = await prisma.userMood.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserMoods and only return the `id`
     * const userMoodWithIdOnly = await prisma.userMood.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserMoodCreateManyAndReturnArgs>(args?: SelectSubset<T, UserMoodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserMood.
     * @param {UserMoodDeleteArgs} args - Arguments to delete one UserMood.
     * @example
     * // Delete one UserMood
     * const UserMood = await prisma.userMood.delete({
     *   where: {
     *     // ... filter to delete one UserMood
     *   }
     * })
     * 
     */
    delete<T extends UserMoodDeleteArgs>(args: SelectSubset<T, UserMoodDeleteArgs<ExtArgs>>): Prisma__UserMoodClient<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserMood.
     * @param {UserMoodUpdateArgs} args - Arguments to update one UserMood.
     * @example
     * // Update one UserMood
     * const userMood = await prisma.userMood.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMoodUpdateArgs>(args: SelectSubset<T, UserMoodUpdateArgs<ExtArgs>>): Prisma__UserMoodClient<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserMoods.
     * @param {UserMoodDeleteManyArgs} args - Arguments to filter UserMoods to delete.
     * @example
     * // Delete a few UserMoods
     * const { count } = await prisma.userMood.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMoodDeleteManyArgs>(args?: SelectSubset<T, UserMoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMoods
     * const userMood = await prisma.userMood.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMoodUpdateManyArgs>(args: SelectSubset<T, UserMoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserMood.
     * @param {UserMoodUpsertArgs} args - Arguments to update or create a UserMood.
     * @example
     * // Update or create a UserMood
     * const userMood = await prisma.userMood.upsert({
     *   create: {
     *     // ... data to create a UserMood
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMood we want to update
     *   }
     * })
     */
    upsert<T extends UserMoodUpsertArgs>(args: SelectSubset<T, UserMoodUpsertArgs<ExtArgs>>): Prisma__UserMoodClient<$Result.GetResult<Prisma.$UserMoodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserMoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMoodCountArgs} args - Arguments to filter UserMoods to count.
     * @example
     * // Count the number of UserMoods
     * const count = await prisma.userMood.count({
     *   where: {
     *     // ... the filter for the UserMoods we want to count
     *   }
     * })
    **/
    count<T extends UserMoodCountArgs>(
      args?: Subset<T, UserMoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMoodAggregateArgs>(args: Subset<T, UserMoodAggregateArgs>): Prisma.PrismaPromise<GetUserMoodAggregateType<T>>

    /**
     * Group by UserMood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMoodGroupByArgs['orderBy'] }
        : { orderBy?: UserMoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMood model
   */
  readonly fields: UserMoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMood.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMood model
   */ 
  interface UserMoodFieldRefs {
    readonly id: FieldRef<"UserMood", 'String'>
    readonly createdAt: FieldRef<"UserMood", 'DateTime'>
    readonly updatedAt: FieldRef<"UserMood", 'DateTime'>
    readonly userId: FieldRef<"UserMood", 'String'>
    readonly mood: FieldRef<"UserMood", 'UserMoodType'>
    readonly note: FieldRef<"UserMood", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserMood findUnique
   */
  export type UserMoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    /**
     * Filter, which UserMood to fetch.
     */
    where: UserMoodWhereUniqueInput
  }

  /**
   * UserMood findUniqueOrThrow
   */
  export type UserMoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    /**
     * Filter, which UserMood to fetch.
     */
    where: UserMoodWhereUniqueInput
  }

  /**
   * UserMood findFirst
   */
  export type UserMoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    /**
     * Filter, which UserMood to fetch.
     */
    where?: UserMoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMoods to fetch.
     */
    orderBy?: UserMoodOrderByWithRelationInput | UserMoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMoods.
     */
    cursor?: UserMoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMoods.
     */
    distinct?: UserMoodScalarFieldEnum | UserMoodScalarFieldEnum[]
  }

  /**
   * UserMood findFirstOrThrow
   */
  export type UserMoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    /**
     * Filter, which UserMood to fetch.
     */
    where?: UserMoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMoods to fetch.
     */
    orderBy?: UserMoodOrderByWithRelationInput | UserMoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMoods.
     */
    cursor?: UserMoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMoods.
     */
    distinct?: UserMoodScalarFieldEnum | UserMoodScalarFieldEnum[]
  }

  /**
   * UserMood findMany
   */
  export type UserMoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    /**
     * Filter, which UserMoods to fetch.
     */
    where?: UserMoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMoods to fetch.
     */
    orderBy?: UserMoodOrderByWithRelationInput | UserMoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMoods.
     */
    cursor?: UserMoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMoods.
     */
    skip?: number
    distinct?: UserMoodScalarFieldEnum | UserMoodScalarFieldEnum[]
  }

  /**
   * UserMood create
   */
  export type UserMoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMood.
     */
    data: XOR<UserMoodCreateInput, UserMoodUncheckedCreateInput>
  }

  /**
   * UserMood createMany
   */
  export type UserMoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMoods.
     */
    data: UserMoodCreateManyInput | UserMoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMood createManyAndReturn
   */
  export type UserMoodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserMoods.
     */
    data: UserMoodCreateManyInput | UserMoodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMood update
   */
  export type UserMoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMood.
     */
    data: XOR<UserMoodUpdateInput, UserMoodUncheckedUpdateInput>
    /**
     * Choose, which UserMood to update.
     */
    where: UserMoodWhereUniqueInput
  }

  /**
   * UserMood updateMany
   */
  export type UserMoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMoods.
     */
    data: XOR<UserMoodUpdateManyMutationInput, UserMoodUncheckedUpdateManyInput>
    /**
     * Filter which UserMoods to update
     */
    where?: UserMoodWhereInput
  }

  /**
   * UserMood upsert
   */
  export type UserMoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMood to update in case it exists.
     */
    where: UserMoodWhereUniqueInput
    /**
     * In case the UserMood found by the `where` argument doesn't exist, create a new UserMood with this data.
     */
    create: XOR<UserMoodCreateInput, UserMoodUncheckedCreateInput>
    /**
     * In case the UserMood was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMoodUpdateInput, UserMoodUncheckedUpdateInput>
  }

  /**
   * UserMood delete
   */
  export type UserMoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
    /**
     * Filter which UserMood to delete.
     */
    where: UserMoodWhereUniqueInput
  }

  /**
   * UserMood deleteMany
   */
  export type UserMoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMoods to delete
     */
    where?: UserMoodWhereInput
  }

  /**
   * UserMood without action
   */
  export type UserMoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMood
     */
    select?: UserMoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMoodInclude<ExtArgs> | null
  }


  /**
   * Model Friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.FriendshipStatus | null
    user1Id: string | null
    user2Id: string | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.FriendshipStatus | null
    user1Id: string | null
    user2Id: string | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    user1Id: number
    user2Id: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    user1Id?: true
    user2Id?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    user1Id?: true
    user2Id?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    user1Id?: true
    user2Id?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendship to aggregate.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithAggregationInput | FriendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    status: $Enums.FriendshipStatus
    user1Id: string
    user2Id: string
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    user1Id?: boolean
    user2Id?: boolean
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    user1Id?: boolean
    user2Id?: boolean
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    user1Id?: boolean
    user2Id?: boolean
  }

  export type FriendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friendship"
    objects: {
      user1: Prisma.$UserPayload<ExtArgs>
      user2: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      status: $Enums.FriendshipStatus
      user1Id: string
      user2Id: string
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipDefaultArgs> = $Result.GetResult<Prisma.$FriendshipPayload, S>

  type FriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FriendshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface FriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friendship'], meta: { name: 'Friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendshipFindUniqueArgs>(args: SelectSubset<T, FriendshipFindUniqueArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendshipFindFirstArgs>(args?: SelectSubset<T, FriendshipFindFirstArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendshipFindManyArgs>(args?: SelectSubset<T, FriendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends FriendshipCreateArgs>(args: SelectSubset<T, FriendshipCreateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Friendships.
     * @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendshipCreateManyArgs>(args?: SelectSubset<T, FriendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {FriendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends FriendshipDeleteArgs>(args: SelectSubset<T, FriendshipDeleteArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendshipUpdateArgs>(args: SelectSubset<T, FriendshipUpdateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendshipDeleteManyArgs>(args?: SelectSubset<T, FriendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendshipUpdateManyArgs>(args: SelectSubset<T, FriendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends FriendshipUpsertArgs>(args: SelectSubset<T, FriendshipUpsertArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friendship model
   */
  readonly fields: FriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user1<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user2<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friendship model
   */ 
  interface FriendshipFieldRefs {
    readonly id: FieldRef<"Friendship", 'String'>
    readonly createdAt: FieldRef<"Friendship", 'DateTime'>
    readonly updatedAt: FieldRef<"Friendship", 'DateTime'>
    readonly status: FieldRef<"Friendship", 'FriendshipStatus'>
    readonly user1Id: FieldRef<"Friendship", 'String'>
    readonly user2Id: FieldRef<"Friendship", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Friendship findUnique
   */
  export type FriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findFirst
   */
  export type FriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendships to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship create
   */
  export type FriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Friendship.
     */
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }

  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friendship createManyAndReturn
   */
  export type FriendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Friendship.
     */
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     */
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     */
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }

  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter which Friendship to delete.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendships to delete
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship without action
   */
  export type FriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
  }


  /**
   * Model Chatroom
   */

  export type AggregateChatroom = {
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  export type ChatroomMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    lastMessage: string | null
  }

  export type ChatroomMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    lastMessage: string | null
  }

  export type ChatroomCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    lastMessage: number
    _all: number
  }


  export type ChatroomMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    lastMessage?: true
  }

  export type ChatroomMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    lastMessage?: true
  }

  export type ChatroomCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    lastMessage?: true
    _all?: true
  }

  export type ChatroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatroom to aggregate.
     */
    where?: ChatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatrooms to fetch.
     */
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chatrooms
    **/
    _count?: true | ChatroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatroomMaxAggregateInputType
  }

  export type GetChatroomAggregateType<T extends ChatroomAggregateArgs> = {
        [P in keyof T & keyof AggregateChatroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatroom[P]>
      : GetScalarType<T[P], AggregateChatroom[P]>
  }




  export type ChatroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomWhereInput
    orderBy?: ChatroomOrderByWithAggregationInput | ChatroomOrderByWithAggregationInput[]
    by: ChatroomScalarFieldEnum[] | ChatroomScalarFieldEnum
    having?: ChatroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatroomCountAggregateInputType | true
    _min?: ChatroomMinAggregateInputType
    _max?: ChatroomMaxAggregateInputType
  }

  export type ChatroomGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string | null
    lastMessage: string | null
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  type GetChatroomGroupByPayload<T extends ChatroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
            : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
        }
      >
    >


  export type ChatroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    lastMessage?: boolean
    readStatuses?: boolean | Chatroom$readStatusesArgs<ExtArgs>
    messages?: boolean | Chatroom$messagesArgs<ExtArgs>
    members?: boolean | Chatroom$membersArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type ChatroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    lastMessage?: boolean
  }, ExtArgs["result"]["chatroom"]>

  export type ChatroomSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    lastMessage?: boolean
  }

  export type ChatroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    readStatuses?: boolean | Chatroom$readStatusesArgs<ExtArgs>
    messages?: boolean | Chatroom$messagesArgs<ExtArgs>
    members?: boolean | Chatroom$membersArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChatroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chatroom"
    objects: {
      readStatuses: Prisma.$ChatroomReadStatusPayload<ExtArgs>[]
      messages: Prisma.$ChatroomMessagePayload<ExtArgs>[]
      members: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string | null
      lastMessage: string | null
    }, ExtArgs["result"]["chatroom"]>
    composites: {}
  }

  type ChatroomGetPayload<S extends boolean | null | undefined | ChatroomDefaultArgs> = $Result.GetResult<Prisma.$ChatroomPayload, S>

  type ChatroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatroomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatroomCountAggregateInputType | true
    }

  export interface ChatroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chatroom'], meta: { name: 'Chatroom' } }
    /**
     * Find zero or one Chatroom that matches the filter.
     * @param {ChatroomFindUniqueArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatroomFindUniqueArgs>(args: SelectSubset<T, ChatroomFindUniqueArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chatroom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatroomFindUniqueOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatroomFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chatroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomFindFirstArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatroomFindFirstArgs>(args?: SelectSubset<T, ChatroomFindFirstArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chatroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomFindFirstOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatroomFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chatrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatrooms
     * const chatrooms = await prisma.chatroom.findMany()
     * 
     * // Get first 10 Chatrooms
     * const chatrooms = await prisma.chatroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatroomFindManyArgs>(args?: SelectSubset<T, ChatroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chatroom.
     * @param {ChatroomCreateArgs} args - Arguments to create a Chatroom.
     * @example
     * // Create one Chatroom
     * const Chatroom = await prisma.chatroom.create({
     *   data: {
     *     // ... data to create a Chatroom
     *   }
     * })
     * 
     */
    create<T extends ChatroomCreateArgs>(args: SelectSubset<T, ChatroomCreateArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chatrooms.
     * @param {ChatroomCreateManyArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatroomCreateManyArgs>(args?: SelectSubset<T, ChatroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatrooms and returns the data saved in the database.
     * @param {ChatroomCreateManyAndReturnArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatrooms and only return the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatroomCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chatroom.
     * @param {ChatroomDeleteArgs} args - Arguments to delete one Chatroom.
     * @example
     * // Delete one Chatroom
     * const Chatroom = await prisma.chatroom.delete({
     *   where: {
     *     // ... filter to delete one Chatroom
     *   }
     * })
     * 
     */
    delete<T extends ChatroomDeleteArgs>(args: SelectSubset<T, ChatroomDeleteArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chatroom.
     * @param {ChatroomUpdateArgs} args - Arguments to update one Chatroom.
     * @example
     * // Update one Chatroom
     * const chatroom = await prisma.chatroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatroomUpdateArgs>(args: SelectSubset<T, ChatroomUpdateArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chatrooms.
     * @param {ChatroomDeleteManyArgs} args - Arguments to filter Chatrooms to delete.
     * @example
     * // Delete a few Chatrooms
     * const { count } = await prisma.chatroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatroomDeleteManyArgs>(args?: SelectSubset<T, ChatroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatrooms
     * const chatroom = await prisma.chatroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatroomUpdateManyArgs>(args: SelectSubset<T, ChatroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chatroom.
     * @param {ChatroomUpsertArgs} args - Arguments to update or create a Chatroom.
     * @example
     * // Update or create a Chatroom
     * const chatroom = await prisma.chatroom.upsert({
     *   create: {
     *     // ... data to create a Chatroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatroom we want to update
     *   }
     * })
     */
    upsert<T extends ChatroomUpsertArgs>(args: SelectSubset<T, ChatroomUpsertArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomCountArgs} args - Arguments to filter Chatrooms to count.
     * @example
     * // Count the number of Chatrooms
     * const count = await prisma.chatroom.count({
     *   where: {
     *     // ... the filter for the Chatrooms we want to count
     *   }
     * })
    **/
    count<T extends ChatroomCountArgs>(
      args?: Subset<T, ChatroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatroomAggregateArgs>(args: Subset<T, ChatroomAggregateArgs>): Prisma.PrismaPromise<GetChatroomAggregateType<T>>

    /**
     * Group by Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatroomGroupByArgs['orderBy'] }
        : { orderBy?: ChatroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chatroom model
   */
  readonly fields: ChatroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chatroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    readStatuses<T extends Chatroom$readStatusesArgs<ExtArgs> = {}>(args?: Subset<T, Chatroom$readStatusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Chatroom$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chatroom$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findMany"> | Null>
    members<T extends Chatroom$membersArgs<ExtArgs> = {}>(args?: Subset<T, Chatroom$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chatroom model
   */ 
  interface ChatroomFieldRefs {
    readonly id: FieldRef<"Chatroom", 'String'>
    readonly createdAt: FieldRef<"Chatroom", 'DateTime'>
    readonly updatedAt: FieldRef<"Chatroom", 'DateTime'>
    readonly name: FieldRef<"Chatroom", 'String'>
    readonly lastMessage: FieldRef<"Chatroom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chatroom findUnique
   */
  export type ChatroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatroom to fetch.
     */
    where: ChatroomWhereUniqueInput
  }

  /**
   * Chatroom findUniqueOrThrow
   */
  export type ChatroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatroom to fetch.
     */
    where: ChatroomWhereUniqueInput
  }

  /**
   * Chatroom findFirst
   */
  export type ChatroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatroom to fetch.
     */
    where?: ChatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatrooms to fetch.
     */
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatrooms.
     */
    cursor?: ChatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * Chatroom findFirstOrThrow
   */
  export type ChatroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatroom to fetch.
     */
    where?: ChatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatrooms to fetch.
     */
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatrooms.
     */
    cursor?: ChatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * Chatroom findMany
   */
  export type ChatroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatrooms to fetch.
     */
    where?: ChatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatrooms to fetch.
     */
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chatrooms.
     */
    cursor?: ChatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatrooms.
     */
    skip?: number
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * Chatroom create
   */
  export type ChatroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * The data needed to create a Chatroom.
     */
    data: XOR<ChatroomCreateInput, ChatroomUncheckedCreateInput>
  }

  /**
   * Chatroom createMany
   */
  export type ChatroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chatrooms.
     */
    data: ChatroomCreateManyInput | ChatroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chatroom createManyAndReturn
   */
  export type ChatroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chatrooms.
     */
    data: ChatroomCreateManyInput | ChatroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chatroom update
   */
  export type ChatroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * The data needed to update a Chatroom.
     */
    data: XOR<ChatroomUpdateInput, ChatroomUncheckedUpdateInput>
    /**
     * Choose, which Chatroom to update.
     */
    where: ChatroomWhereUniqueInput
  }

  /**
   * Chatroom updateMany
   */
  export type ChatroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chatrooms.
     */
    data: XOR<ChatroomUpdateManyMutationInput, ChatroomUncheckedUpdateManyInput>
    /**
     * Filter which Chatrooms to update
     */
    where?: ChatroomWhereInput
  }

  /**
   * Chatroom upsert
   */
  export type ChatroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * The filter to search for the Chatroom to update in case it exists.
     */
    where: ChatroomWhereUniqueInput
    /**
     * In case the Chatroom found by the `where` argument doesn't exist, create a new Chatroom with this data.
     */
    create: XOR<ChatroomCreateInput, ChatroomUncheckedCreateInput>
    /**
     * In case the Chatroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatroomUpdateInput, ChatroomUncheckedUpdateInput>
  }

  /**
   * Chatroom delete
   */
  export type ChatroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter which Chatroom to delete.
     */
    where: ChatroomWhereUniqueInput
  }

  /**
   * Chatroom deleteMany
   */
  export type ChatroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatrooms to delete
     */
    where?: ChatroomWhereInput
  }

  /**
   * Chatroom.readStatuses
   */
  export type Chatroom$readStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    where?: ChatroomReadStatusWhereInput
    orderBy?: ChatroomReadStatusOrderByWithRelationInput | ChatroomReadStatusOrderByWithRelationInput[]
    cursor?: ChatroomReadStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatroomReadStatusScalarFieldEnum | ChatroomReadStatusScalarFieldEnum[]
  }

  /**
   * Chatroom.messages
   */
  export type Chatroom$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    where?: ChatroomMessageWhereInput
    orderBy?: ChatroomMessageOrderByWithRelationInput | ChatroomMessageOrderByWithRelationInput[]
    cursor?: ChatroomMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatroomMessageScalarFieldEnum | ChatroomMessageScalarFieldEnum[]
  }

  /**
   * Chatroom.members
   */
  export type Chatroom$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Chatroom without action
   */
  export type ChatroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
  }


  /**
   * Model ChatroomMessage
   */

  export type AggregateChatroomMessage = {
    _count: ChatroomMessageCountAggregateOutputType | null
    _min: ChatroomMessageMinAggregateOutputType | null
    _max: ChatroomMessageMaxAggregateOutputType | null
  }

  export type ChatroomMessageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    chatroomId: string | null
    senderId: string | null
    message: string | null
    status: $Enums.ChatroomMessageStatus | null
    type: $Enums.ChatroomMessageType | null
    file: string | null
    reply_id: string | null
    call_message_status: $Enums.CallMessageStatus | null
    isDeleted: boolean | null
    payload: string | null
  }

  export type ChatroomMessageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    chatroomId: string | null
    senderId: string | null
    message: string | null
    status: $Enums.ChatroomMessageStatus | null
    type: $Enums.ChatroomMessageType | null
    file: string | null
    reply_id: string | null
    call_message_status: $Enums.CallMessageStatus | null
    isDeleted: boolean | null
    payload: string | null
  }

  export type ChatroomMessageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    chatroomId: number
    senderId: number
    message: number
    status: number
    type: number
    file: number
    reply_id: number
    call_message_status: number
    isDeleted: number
    payload: number
    _all: number
  }


  export type ChatroomMessageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    chatroomId?: true
    senderId?: true
    message?: true
    status?: true
    type?: true
    file?: true
    reply_id?: true
    call_message_status?: true
    isDeleted?: true
    payload?: true
  }

  export type ChatroomMessageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    chatroomId?: true
    senderId?: true
    message?: true
    status?: true
    type?: true
    file?: true
    reply_id?: true
    call_message_status?: true
    isDeleted?: true
    payload?: true
  }

  export type ChatroomMessageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    chatroomId?: true
    senderId?: true
    message?: true
    status?: true
    type?: true
    file?: true
    reply_id?: true
    call_message_status?: true
    isDeleted?: true
    payload?: true
    _all?: true
  }

  export type ChatroomMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatroomMessage to aggregate.
     */
    where?: ChatroomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatroomMessages to fetch.
     */
    orderBy?: ChatroomMessageOrderByWithRelationInput | ChatroomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatroomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatroomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatroomMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatroomMessages
    **/
    _count?: true | ChatroomMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatroomMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatroomMessageMaxAggregateInputType
  }

  export type GetChatroomMessageAggregateType<T extends ChatroomMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatroomMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatroomMessage[P]>
      : GetScalarType<T[P], AggregateChatroomMessage[P]>
  }




  export type ChatroomMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomMessageWhereInput
    orderBy?: ChatroomMessageOrderByWithAggregationInput | ChatroomMessageOrderByWithAggregationInput[]
    by: ChatroomMessageScalarFieldEnum[] | ChatroomMessageScalarFieldEnum
    having?: ChatroomMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatroomMessageCountAggregateInputType | true
    _min?: ChatroomMessageMinAggregateInputType
    _max?: ChatroomMessageMaxAggregateInputType
  }

  export type ChatroomMessageGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    chatroomId: string
    senderId: string
    message: string
    status: $Enums.ChatroomMessageStatus
    type: $Enums.ChatroomMessageType
    file: string | null
    reply_id: string | null
    call_message_status: $Enums.CallMessageStatus | null
    isDeleted: boolean
    payload: string | null
    _count: ChatroomMessageCountAggregateOutputType | null
    _min: ChatroomMessageMinAggregateOutputType | null
    _max: ChatroomMessageMaxAggregateOutputType | null
  }

  type GetChatroomMessageGroupByPayload<T extends ChatroomMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatroomMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatroomMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatroomMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatroomMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatroomMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatroomId?: boolean
    senderId?: boolean
    message?: boolean
    status?: boolean
    type?: boolean
    file?: boolean
    reply_id?: boolean
    call_message_status?: boolean
    isDeleted?: boolean
    payload?: boolean
    readBy?: boolean | ChatroomMessage$readByArgs<ExtArgs>
    chatroom?: boolean | ChatroomDefaultArgs<ExtArgs>
    reply?: boolean | ChatroomMessage$replyArgs<ExtArgs>
    chat_message?: boolean | ChatroomMessage$chat_messageArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ChatroomMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroomMessage"]>

  export type ChatroomMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatroomId?: boolean
    senderId?: boolean
    message?: boolean
    status?: boolean
    type?: boolean
    file?: boolean
    reply_id?: boolean
    call_message_status?: boolean
    isDeleted?: boolean
    payload?: boolean
    chatroom?: boolean | ChatroomDefaultArgs<ExtArgs>
    reply?: boolean | ChatroomMessage$replyArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroomMessage"]>

  export type ChatroomMessageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatroomId?: boolean
    senderId?: boolean
    message?: boolean
    status?: boolean
    type?: boolean
    file?: boolean
    reply_id?: boolean
    call_message_status?: boolean
    isDeleted?: boolean
    payload?: boolean
  }

  export type ChatroomMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    readBy?: boolean | ChatroomMessage$readByArgs<ExtArgs>
    chatroom?: boolean | ChatroomDefaultArgs<ExtArgs>
    reply?: boolean | ChatroomMessage$replyArgs<ExtArgs>
    chat_message?: boolean | ChatroomMessage$chat_messageArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ChatroomMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatroomMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | ChatroomDefaultArgs<ExtArgs>
    reply?: boolean | ChatroomMessage$replyArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatroomMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatroomMessage"
    objects: {
      readBy: Prisma.$ChatroomReadStatusPayload<ExtArgs>[]
      chatroom: Prisma.$ChatroomPayload<ExtArgs>
      reply: Prisma.$ChatroomMessagePayload<ExtArgs> | null
      chat_message: Prisma.$ChatroomMessagePayload<ExtArgs>[]
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      chatroomId: string
      senderId: string
      message: string
      status: $Enums.ChatroomMessageStatus
      type: $Enums.ChatroomMessageType
      file: string | null
      reply_id: string | null
      call_message_status: $Enums.CallMessageStatus | null
      isDeleted: boolean
      payload: string | null
    }, ExtArgs["result"]["chatroomMessage"]>
    composites: {}
  }

  type ChatroomMessageGetPayload<S extends boolean | null | undefined | ChatroomMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatroomMessagePayload, S>

  type ChatroomMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatroomMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatroomMessageCountAggregateInputType | true
    }

  export interface ChatroomMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatroomMessage'], meta: { name: 'ChatroomMessage' } }
    /**
     * Find zero or one ChatroomMessage that matches the filter.
     * @param {ChatroomMessageFindUniqueArgs} args - Arguments to find a ChatroomMessage
     * @example
     * // Get one ChatroomMessage
     * const chatroomMessage = await prisma.chatroomMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatroomMessageFindUniqueArgs>(args: SelectSubset<T, ChatroomMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatroomMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatroomMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatroomMessage
     * @example
     * // Get one ChatroomMessage
     * const chatroomMessage = await prisma.chatroomMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatroomMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatroomMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatroomMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomMessageFindFirstArgs} args - Arguments to find a ChatroomMessage
     * @example
     * // Get one ChatroomMessage
     * const chatroomMessage = await prisma.chatroomMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatroomMessageFindFirstArgs>(args?: SelectSubset<T, ChatroomMessageFindFirstArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatroomMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomMessageFindFirstOrThrowArgs} args - Arguments to find a ChatroomMessage
     * @example
     * // Get one ChatroomMessage
     * const chatroomMessage = await prisma.chatroomMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatroomMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatroomMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatroomMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatroomMessages
     * const chatroomMessages = await prisma.chatroomMessage.findMany()
     * 
     * // Get first 10 ChatroomMessages
     * const chatroomMessages = await prisma.chatroomMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatroomMessageWithIdOnly = await prisma.chatroomMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatroomMessageFindManyArgs>(args?: SelectSubset<T, ChatroomMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatroomMessage.
     * @param {ChatroomMessageCreateArgs} args - Arguments to create a ChatroomMessage.
     * @example
     * // Create one ChatroomMessage
     * const ChatroomMessage = await prisma.chatroomMessage.create({
     *   data: {
     *     // ... data to create a ChatroomMessage
     *   }
     * })
     * 
     */
    create<T extends ChatroomMessageCreateArgs>(args: SelectSubset<T, ChatroomMessageCreateArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatroomMessages.
     * @param {ChatroomMessageCreateManyArgs} args - Arguments to create many ChatroomMessages.
     * @example
     * // Create many ChatroomMessages
     * const chatroomMessage = await prisma.chatroomMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatroomMessageCreateManyArgs>(args?: SelectSubset<T, ChatroomMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatroomMessages and returns the data saved in the database.
     * @param {ChatroomMessageCreateManyAndReturnArgs} args - Arguments to create many ChatroomMessages.
     * @example
     * // Create many ChatroomMessages
     * const chatroomMessage = await prisma.chatroomMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatroomMessages and only return the `id`
     * const chatroomMessageWithIdOnly = await prisma.chatroomMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatroomMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatroomMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatroomMessage.
     * @param {ChatroomMessageDeleteArgs} args - Arguments to delete one ChatroomMessage.
     * @example
     * // Delete one ChatroomMessage
     * const ChatroomMessage = await prisma.chatroomMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatroomMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatroomMessageDeleteArgs>(args: SelectSubset<T, ChatroomMessageDeleteArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatroomMessage.
     * @param {ChatroomMessageUpdateArgs} args - Arguments to update one ChatroomMessage.
     * @example
     * // Update one ChatroomMessage
     * const chatroomMessage = await prisma.chatroomMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatroomMessageUpdateArgs>(args: SelectSubset<T, ChatroomMessageUpdateArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatroomMessages.
     * @param {ChatroomMessageDeleteManyArgs} args - Arguments to filter ChatroomMessages to delete.
     * @example
     * // Delete a few ChatroomMessages
     * const { count } = await prisma.chatroomMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatroomMessageDeleteManyArgs>(args?: SelectSubset<T, ChatroomMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatroomMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatroomMessages
     * const chatroomMessage = await prisma.chatroomMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatroomMessageUpdateManyArgs>(args: SelectSubset<T, ChatroomMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatroomMessage.
     * @param {ChatroomMessageUpsertArgs} args - Arguments to update or create a ChatroomMessage.
     * @example
     * // Update or create a ChatroomMessage
     * const chatroomMessage = await prisma.chatroomMessage.upsert({
     *   create: {
     *     // ... data to create a ChatroomMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatroomMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatroomMessageUpsertArgs>(args: SelectSubset<T, ChatroomMessageUpsertArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatroomMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomMessageCountArgs} args - Arguments to filter ChatroomMessages to count.
     * @example
     * // Count the number of ChatroomMessages
     * const count = await prisma.chatroomMessage.count({
     *   where: {
     *     // ... the filter for the ChatroomMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatroomMessageCountArgs>(
      args?: Subset<T, ChatroomMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatroomMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatroomMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatroomMessageAggregateArgs>(args: Subset<T, ChatroomMessageAggregateArgs>): Prisma.PrismaPromise<GetChatroomMessageAggregateType<T>>

    /**
     * Group by ChatroomMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatroomMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatroomMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatroomMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatroomMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatroomMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatroomMessage model
   */
  readonly fields: ChatroomMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatroomMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatroomMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    readBy<T extends ChatroomMessage$readByArgs<ExtArgs> = {}>(args?: Subset<T, ChatroomMessage$readByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "findMany"> | Null>
    chatroom<T extends ChatroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatroomDefaultArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reply<T extends ChatroomMessage$replyArgs<ExtArgs> = {}>(args?: Subset<T, ChatroomMessage$replyArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    chat_message<T extends ChatroomMessage$chat_messageArgs<ExtArgs> = {}>(args?: Subset<T, ChatroomMessage$chat_messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findMany"> | Null>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatroomMessage model
   */ 
  interface ChatroomMessageFieldRefs {
    readonly id: FieldRef<"ChatroomMessage", 'String'>
    readonly createdAt: FieldRef<"ChatroomMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatroomMessage", 'DateTime'>
    readonly chatroomId: FieldRef<"ChatroomMessage", 'String'>
    readonly senderId: FieldRef<"ChatroomMessage", 'String'>
    readonly message: FieldRef<"ChatroomMessage", 'String'>
    readonly status: FieldRef<"ChatroomMessage", 'ChatroomMessageStatus'>
    readonly type: FieldRef<"ChatroomMessage", 'ChatroomMessageType'>
    readonly file: FieldRef<"ChatroomMessage", 'String'>
    readonly reply_id: FieldRef<"ChatroomMessage", 'String'>
    readonly call_message_status: FieldRef<"ChatroomMessage", 'CallMessageStatus'>
    readonly isDeleted: FieldRef<"ChatroomMessage", 'Boolean'>
    readonly payload: FieldRef<"ChatroomMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChatroomMessage findUnique
   */
  export type ChatroomMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomMessage to fetch.
     */
    where: ChatroomMessageWhereUniqueInput
  }

  /**
   * ChatroomMessage findUniqueOrThrow
   */
  export type ChatroomMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomMessage to fetch.
     */
    where: ChatroomMessageWhereUniqueInput
  }

  /**
   * ChatroomMessage findFirst
   */
  export type ChatroomMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomMessage to fetch.
     */
    where?: ChatroomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatroomMessages to fetch.
     */
    orderBy?: ChatroomMessageOrderByWithRelationInput | ChatroomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatroomMessages.
     */
    cursor?: ChatroomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatroomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatroomMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatroomMessages.
     */
    distinct?: ChatroomMessageScalarFieldEnum | ChatroomMessageScalarFieldEnum[]
  }

  /**
   * ChatroomMessage findFirstOrThrow
   */
  export type ChatroomMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomMessage to fetch.
     */
    where?: ChatroomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatroomMessages to fetch.
     */
    orderBy?: ChatroomMessageOrderByWithRelationInput | ChatroomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatroomMessages.
     */
    cursor?: ChatroomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatroomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatroomMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatroomMessages.
     */
    distinct?: ChatroomMessageScalarFieldEnum | ChatroomMessageScalarFieldEnum[]
  }

  /**
   * ChatroomMessage findMany
   */
  export type ChatroomMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomMessages to fetch.
     */
    where?: ChatroomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatroomMessages to fetch.
     */
    orderBy?: ChatroomMessageOrderByWithRelationInput | ChatroomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatroomMessages.
     */
    cursor?: ChatroomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatroomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatroomMessages.
     */
    skip?: number
    distinct?: ChatroomMessageScalarFieldEnum | ChatroomMessageScalarFieldEnum[]
  }

  /**
   * ChatroomMessage create
   */
  export type ChatroomMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatroomMessage.
     */
    data: XOR<ChatroomMessageCreateInput, ChatroomMessageUncheckedCreateInput>
  }

  /**
   * ChatroomMessage createMany
   */
  export type ChatroomMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatroomMessages.
     */
    data: ChatroomMessageCreateManyInput | ChatroomMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatroomMessage createManyAndReturn
   */
  export type ChatroomMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatroomMessages.
     */
    data: ChatroomMessageCreateManyInput | ChatroomMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatroomMessage update
   */
  export type ChatroomMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatroomMessage.
     */
    data: XOR<ChatroomMessageUpdateInput, ChatroomMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatroomMessage to update.
     */
    where: ChatroomMessageWhereUniqueInput
  }

  /**
   * ChatroomMessage updateMany
   */
  export type ChatroomMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatroomMessages.
     */
    data: XOR<ChatroomMessageUpdateManyMutationInput, ChatroomMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatroomMessages to update
     */
    where?: ChatroomMessageWhereInput
  }

  /**
   * ChatroomMessage upsert
   */
  export type ChatroomMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatroomMessage to update in case it exists.
     */
    where: ChatroomMessageWhereUniqueInput
    /**
     * In case the ChatroomMessage found by the `where` argument doesn't exist, create a new ChatroomMessage with this data.
     */
    create: XOR<ChatroomMessageCreateInput, ChatroomMessageUncheckedCreateInput>
    /**
     * In case the ChatroomMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatroomMessageUpdateInput, ChatroomMessageUncheckedUpdateInput>
  }

  /**
   * ChatroomMessage delete
   */
  export type ChatroomMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatroomMessage to delete.
     */
    where: ChatroomMessageWhereUniqueInput
  }

  /**
   * ChatroomMessage deleteMany
   */
  export type ChatroomMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatroomMessages to delete
     */
    where?: ChatroomMessageWhereInput
  }

  /**
   * ChatroomMessage.readBy
   */
  export type ChatroomMessage$readByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    where?: ChatroomReadStatusWhereInput
    orderBy?: ChatroomReadStatusOrderByWithRelationInput | ChatroomReadStatusOrderByWithRelationInput[]
    cursor?: ChatroomReadStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatroomReadStatusScalarFieldEnum | ChatroomReadStatusScalarFieldEnum[]
  }

  /**
   * ChatroomMessage.reply
   */
  export type ChatroomMessage$replyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    where?: ChatroomMessageWhereInput
  }

  /**
   * ChatroomMessage.chat_message
   */
  export type ChatroomMessage$chat_messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
    where?: ChatroomMessageWhereInput
    orderBy?: ChatroomMessageOrderByWithRelationInput | ChatroomMessageOrderByWithRelationInput[]
    cursor?: ChatroomMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatroomMessageScalarFieldEnum | ChatroomMessageScalarFieldEnum[]
  }

  /**
   * ChatroomMessage without action
   */
  export type ChatroomMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomMessage
     */
    select?: ChatroomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomMessageInclude<ExtArgs> | null
  }


  /**
   * Model ChatroomReadStatus
   */

  export type AggregateChatroomReadStatus = {
    _count: ChatroomReadStatusCountAggregateOutputType | null
    _min: ChatroomReadStatusMinAggregateOutputType | null
    _max: ChatroomReadStatusMaxAggregateOutputType | null
  }

  export type ChatroomReadStatusMinAggregateOutputType = {
    id: string | null
    chatroomId: string | null
    userId: string | null
    messageId: string | null
    createdAt: Date | null
  }

  export type ChatroomReadStatusMaxAggregateOutputType = {
    id: string | null
    chatroomId: string | null
    userId: string | null
    messageId: string | null
    createdAt: Date | null
  }

  export type ChatroomReadStatusCountAggregateOutputType = {
    id: number
    chatroomId: number
    userId: number
    messageId: number
    createdAt: number
    _all: number
  }


  export type ChatroomReadStatusMinAggregateInputType = {
    id?: true
    chatroomId?: true
    userId?: true
    messageId?: true
    createdAt?: true
  }

  export type ChatroomReadStatusMaxAggregateInputType = {
    id?: true
    chatroomId?: true
    userId?: true
    messageId?: true
    createdAt?: true
  }

  export type ChatroomReadStatusCountAggregateInputType = {
    id?: true
    chatroomId?: true
    userId?: true
    messageId?: true
    createdAt?: true
    _all?: true
  }

  export type ChatroomReadStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatroomReadStatus to aggregate.
     */
    where?: ChatroomReadStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatroomReadStatuses to fetch.
     */
    orderBy?: ChatroomReadStatusOrderByWithRelationInput | ChatroomReadStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatroomReadStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatroomReadStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatroomReadStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatroomReadStatuses
    **/
    _count?: true | ChatroomReadStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatroomReadStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatroomReadStatusMaxAggregateInputType
  }

  export type GetChatroomReadStatusAggregateType<T extends ChatroomReadStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateChatroomReadStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatroomReadStatus[P]>
      : GetScalarType<T[P], AggregateChatroomReadStatus[P]>
  }




  export type ChatroomReadStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomReadStatusWhereInput
    orderBy?: ChatroomReadStatusOrderByWithAggregationInput | ChatroomReadStatusOrderByWithAggregationInput[]
    by: ChatroomReadStatusScalarFieldEnum[] | ChatroomReadStatusScalarFieldEnum
    having?: ChatroomReadStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatroomReadStatusCountAggregateInputType | true
    _min?: ChatroomReadStatusMinAggregateInputType
    _max?: ChatroomReadStatusMaxAggregateInputType
  }

  export type ChatroomReadStatusGroupByOutputType = {
    id: string
    chatroomId: string
    userId: string
    messageId: string
    createdAt: Date
    _count: ChatroomReadStatusCountAggregateOutputType | null
    _min: ChatroomReadStatusMinAggregateOutputType | null
    _max: ChatroomReadStatusMaxAggregateOutputType | null
  }

  type GetChatroomReadStatusGroupByPayload<T extends ChatroomReadStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatroomReadStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatroomReadStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatroomReadStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ChatroomReadStatusGroupByOutputType[P]>
        }
      >
    >


  export type ChatroomReadStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatroomId?: boolean
    userId?: boolean
    messageId?: boolean
    createdAt?: boolean
    chatroom?: boolean | ChatroomDefaultArgs<ExtArgs>
    message?: boolean | ChatroomMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroomReadStatus"]>

  export type ChatroomReadStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatroomId?: boolean
    userId?: boolean
    messageId?: boolean
    createdAt?: boolean
    chatroom?: boolean | ChatroomDefaultArgs<ExtArgs>
    message?: boolean | ChatroomMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroomReadStatus"]>

  export type ChatroomReadStatusSelectScalar = {
    id?: boolean
    chatroomId?: boolean
    userId?: boolean
    messageId?: boolean
    createdAt?: boolean
  }

  export type ChatroomReadStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | ChatroomDefaultArgs<ExtArgs>
    message?: boolean | ChatroomMessageDefaultArgs<ExtArgs>
  }
  export type ChatroomReadStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | ChatroomDefaultArgs<ExtArgs>
    message?: boolean | ChatroomMessageDefaultArgs<ExtArgs>
  }

  export type $ChatroomReadStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatroomReadStatus"
    objects: {
      chatroom: Prisma.$ChatroomPayload<ExtArgs>
      message: Prisma.$ChatroomMessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatroomId: string
      userId: string
      messageId: string
      createdAt: Date
    }, ExtArgs["result"]["chatroomReadStatus"]>
    composites: {}
  }

  type ChatroomReadStatusGetPayload<S extends boolean | null | undefined | ChatroomReadStatusDefaultArgs> = $Result.GetResult<Prisma.$ChatroomReadStatusPayload, S>

  type ChatroomReadStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatroomReadStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatroomReadStatusCountAggregateInputType | true
    }

  export interface ChatroomReadStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatroomReadStatus'], meta: { name: 'ChatroomReadStatus' } }
    /**
     * Find zero or one ChatroomReadStatus that matches the filter.
     * @param {ChatroomReadStatusFindUniqueArgs} args - Arguments to find a ChatroomReadStatus
     * @example
     * // Get one ChatroomReadStatus
     * const chatroomReadStatus = await prisma.chatroomReadStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatroomReadStatusFindUniqueArgs>(args: SelectSubset<T, ChatroomReadStatusFindUniqueArgs<ExtArgs>>): Prisma__ChatroomReadStatusClient<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatroomReadStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatroomReadStatusFindUniqueOrThrowArgs} args - Arguments to find a ChatroomReadStatus
     * @example
     * // Get one ChatroomReadStatus
     * const chatroomReadStatus = await prisma.chatroomReadStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatroomReadStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatroomReadStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatroomReadStatusClient<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatroomReadStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomReadStatusFindFirstArgs} args - Arguments to find a ChatroomReadStatus
     * @example
     * // Get one ChatroomReadStatus
     * const chatroomReadStatus = await prisma.chatroomReadStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatroomReadStatusFindFirstArgs>(args?: SelectSubset<T, ChatroomReadStatusFindFirstArgs<ExtArgs>>): Prisma__ChatroomReadStatusClient<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatroomReadStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomReadStatusFindFirstOrThrowArgs} args - Arguments to find a ChatroomReadStatus
     * @example
     * // Get one ChatroomReadStatus
     * const chatroomReadStatus = await prisma.chatroomReadStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatroomReadStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatroomReadStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatroomReadStatusClient<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatroomReadStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomReadStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatroomReadStatuses
     * const chatroomReadStatuses = await prisma.chatroomReadStatus.findMany()
     * 
     * // Get first 10 ChatroomReadStatuses
     * const chatroomReadStatuses = await prisma.chatroomReadStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatroomReadStatusWithIdOnly = await prisma.chatroomReadStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatroomReadStatusFindManyArgs>(args?: SelectSubset<T, ChatroomReadStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatroomReadStatus.
     * @param {ChatroomReadStatusCreateArgs} args - Arguments to create a ChatroomReadStatus.
     * @example
     * // Create one ChatroomReadStatus
     * const ChatroomReadStatus = await prisma.chatroomReadStatus.create({
     *   data: {
     *     // ... data to create a ChatroomReadStatus
     *   }
     * })
     * 
     */
    create<T extends ChatroomReadStatusCreateArgs>(args: SelectSubset<T, ChatroomReadStatusCreateArgs<ExtArgs>>): Prisma__ChatroomReadStatusClient<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatroomReadStatuses.
     * @param {ChatroomReadStatusCreateManyArgs} args - Arguments to create many ChatroomReadStatuses.
     * @example
     * // Create many ChatroomReadStatuses
     * const chatroomReadStatus = await prisma.chatroomReadStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatroomReadStatusCreateManyArgs>(args?: SelectSubset<T, ChatroomReadStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatroomReadStatuses and returns the data saved in the database.
     * @param {ChatroomReadStatusCreateManyAndReturnArgs} args - Arguments to create many ChatroomReadStatuses.
     * @example
     * // Create many ChatroomReadStatuses
     * const chatroomReadStatus = await prisma.chatroomReadStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatroomReadStatuses and only return the `id`
     * const chatroomReadStatusWithIdOnly = await prisma.chatroomReadStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatroomReadStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatroomReadStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatroomReadStatus.
     * @param {ChatroomReadStatusDeleteArgs} args - Arguments to delete one ChatroomReadStatus.
     * @example
     * // Delete one ChatroomReadStatus
     * const ChatroomReadStatus = await prisma.chatroomReadStatus.delete({
     *   where: {
     *     // ... filter to delete one ChatroomReadStatus
     *   }
     * })
     * 
     */
    delete<T extends ChatroomReadStatusDeleteArgs>(args: SelectSubset<T, ChatroomReadStatusDeleteArgs<ExtArgs>>): Prisma__ChatroomReadStatusClient<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatroomReadStatus.
     * @param {ChatroomReadStatusUpdateArgs} args - Arguments to update one ChatroomReadStatus.
     * @example
     * // Update one ChatroomReadStatus
     * const chatroomReadStatus = await prisma.chatroomReadStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatroomReadStatusUpdateArgs>(args: SelectSubset<T, ChatroomReadStatusUpdateArgs<ExtArgs>>): Prisma__ChatroomReadStatusClient<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatroomReadStatuses.
     * @param {ChatroomReadStatusDeleteManyArgs} args - Arguments to filter ChatroomReadStatuses to delete.
     * @example
     * // Delete a few ChatroomReadStatuses
     * const { count } = await prisma.chatroomReadStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatroomReadStatusDeleteManyArgs>(args?: SelectSubset<T, ChatroomReadStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatroomReadStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomReadStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatroomReadStatuses
     * const chatroomReadStatus = await prisma.chatroomReadStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatroomReadStatusUpdateManyArgs>(args: SelectSubset<T, ChatroomReadStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatroomReadStatus.
     * @param {ChatroomReadStatusUpsertArgs} args - Arguments to update or create a ChatroomReadStatus.
     * @example
     * // Update or create a ChatroomReadStatus
     * const chatroomReadStatus = await prisma.chatroomReadStatus.upsert({
     *   create: {
     *     // ... data to create a ChatroomReadStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatroomReadStatus we want to update
     *   }
     * })
     */
    upsert<T extends ChatroomReadStatusUpsertArgs>(args: SelectSubset<T, ChatroomReadStatusUpsertArgs<ExtArgs>>): Prisma__ChatroomReadStatusClient<$Result.GetResult<Prisma.$ChatroomReadStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatroomReadStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomReadStatusCountArgs} args - Arguments to filter ChatroomReadStatuses to count.
     * @example
     * // Count the number of ChatroomReadStatuses
     * const count = await prisma.chatroomReadStatus.count({
     *   where: {
     *     // ... the filter for the ChatroomReadStatuses we want to count
     *   }
     * })
    **/
    count<T extends ChatroomReadStatusCountArgs>(
      args?: Subset<T, ChatroomReadStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatroomReadStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatroomReadStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomReadStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatroomReadStatusAggregateArgs>(args: Subset<T, ChatroomReadStatusAggregateArgs>): Prisma.PrismaPromise<GetChatroomReadStatusAggregateType<T>>

    /**
     * Group by ChatroomReadStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomReadStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatroomReadStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatroomReadStatusGroupByArgs['orderBy'] }
        : { orderBy?: ChatroomReadStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatroomReadStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatroomReadStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatroomReadStatus model
   */
  readonly fields: ChatroomReadStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatroomReadStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatroomReadStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatroom<T extends ChatroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatroomDefaultArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    message<T extends ChatroomMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatroomMessageDefaultArgs<ExtArgs>>): Prisma__ChatroomMessageClient<$Result.GetResult<Prisma.$ChatroomMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatroomReadStatus model
   */ 
  interface ChatroomReadStatusFieldRefs {
    readonly id: FieldRef<"ChatroomReadStatus", 'String'>
    readonly chatroomId: FieldRef<"ChatroomReadStatus", 'String'>
    readonly userId: FieldRef<"ChatroomReadStatus", 'String'>
    readonly messageId: FieldRef<"ChatroomReadStatus", 'String'>
    readonly createdAt: FieldRef<"ChatroomReadStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatroomReadStatus findUnique
   */
  export type ChatroomReadStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomReadStatus to fetch.
     */
    where: ChatroomReadStatusWhereUniqueInput
  }

  /**
   * ChatroomReadStatus findUniqueOrThrow
   */
  export type ChatroomReadStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomReadStatus to fetch.
     */
    where: ChatroomReadStatusWhereUniqueInput
  }

  /**
   * ChatroomReadStatus findFirst
   */
  export type ChatroomReadStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomReadStatus to fetch.
     */
    where?: ChatroomReadStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatroomReadStatuses to fetch.
     */
    orderBy?: ChatroomReadStatusOrderByWithRelationInput | ChatroomReadStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatroomReadStatuses.
     */
    cursor?: ChatroomReadStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatroomReadStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatroomReadStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatroomReadStatuses.
     */
    distinct?: ChatroomReadStatusScalarFieldEnum | ChatroomReadStatusScalarFieldEnum[]
  }

  /**
   * ChatroomReadStatus findFirstOrThrow
   */
  export type ChatroomReadStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomReadStatus to fetch.
     */
    where?: ChatroomReadStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatroomReadStatuses to fetch.
     */
    orderBy?: ChatroomReadStatusOrderByWithRelationInput | ChatroomReadStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatroomReadStatuses.
     */
    cursor?: ChatroomReadStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatroomReadStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatroomReadStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatroomReadStatuses.
     */
    distinct?: ChatroomReadStatusScalarFieldEnum | ChatroomReadStatusScalarFieldEnum[]
  }

  /**
   * ChatroomReadStatus findMany
   */
  export type ChatroomReadStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatroomReadStatuses to fetch.
     */
    where?: ChatroomReadStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatroomReadStatuses to fetch.
     */
    orderBy?: ChatroomReadStatusOrderByWithRelationInput | ChatroomReadStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatroomReadStatuses.
     */
    cursor?: ChatroomReadStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatroomReadStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatroomReadStatuses.
     */
    skip?: number
    distinct?: ChatroomReadStatusScalarFieldEnum | ChatroomReadStatusScalarFieldEnum[]
  }

  /**
   * ChatroomReadStatus create
   */
  export type ChatroomReadStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatroomReadStatus.
     */
    data: XOR<ChatroomReadStatusCreateInput, ChatroomReadStatusUncheckedCreateInput>
  }

  /**
   * ChatroomReadStatus createMany
   */
  export type ChatroomReadStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatroomReadStatuses.
     */
    data: ChatroomReadStatusCreateManyInput | ChatroomReadStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatroomReadStatus createManyAndReturn
   */
  export type ChatroomReadStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatroomReadStatuses.
     */
    data: ChatroomReadStatusCreateManyInput | ChatroomReadStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatroomReadStatus update
   */
  export type ChatroomReadStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatroomReadStatus.
     */
    data: XOR<ChatroomReadStatusUpdateInput, ChatroomReadStatusUncheckedUpdateInput>
    /**
     * Choose, which ChatroomReadStatus to update.
     */
    where: ChatroomReadStatusWhereUniqueInput
  }

  /**
   * ChatroomReadStatus updateMany
   */
  export type ChatroomReadStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatroomReadStatuses.
     */
    data: XOR<ChatroomReadStatusUpdateManyMutationInput, ChatroomReadStatusUncheckedUpdateManyInput>
    /**
     * Filter which ChatroomReadStatuses to update
     */
    where?: ChatroomReadStatusWhereInput
  }

  /**
   * ChatroomReadStatus upsert
   */
  export type ChatroomReadStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatroomReadStatus to update in case it exists.
     */
    where: ChatroomReadStatusWhereUniqueInput
    /**
     * In case the ChatroomReadStatus found by the `where` argument doesn't exist, create a new ChatroomReadStatus with this data.
     */
    create: XOR<ChatroomReadStatusCreateInput, ChatroomReadStatusUncheckedCreateInput>
    /**
     * In case the ChatroomReadStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatroomReadStatusUpdateInput, ChatroomReadStatusUncheckedUpdateInput>
  }

  /**
   * ChatroomReadStatus delete
   */
  export type ChatroomReadStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
    /**
     * Filter which ChatroomReadStatus to delete.
     */
    where: ChatroomReadStatusWhereUniqueInput
  }

  /**
   * ChatroomReadStatus deleteMany
   */
  export type ChatroomReadStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatroomReadStatuses to delete
     */
    where?: ChatroomReadStatusWhereInput
  }

  /**
   * ChatroomReadStatus without action
   */
  export type ChatroomReadStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomReadStatus
     */
    select?: ChatroomReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomReadStatusInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    total_likes: number | null
    total_comments: number | null
  }

  export type PostSumAggregateOutputType = {
    total_likes: number | null
    total_comments: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    is_anonymous: boolean | null
    text: string | null
    mood: string | null
    userId: string | null
    total_likes: number | null
    total_comments: number | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    is_anonymous: boolean | null
    text: string | null
    mood: string | null
    userId: string | null
    total_likes: number | null
    total_comments: number | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    is_anonymous: number
    text: number
    mood: number
    userId: number
    total_likes: number
    total_comments: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    total_likes?: true
    total_comments?: true
  }

  export type PostSumAggregateInputType = {
    total_likes?: true
    total_comments?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    is_anonymous?: true
    text?: true
    mood?: true
    userId?: true
    total_likes?: true
    total_comments?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    is_anonymous?: true
    text?: true
    mood?: true
    userId?: true
    total_likes?: true
    total_comments?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    is_anonymous?: true
    text?: true
    mood?: true
    userId?: true
    total_likes?: true
    total_comments?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    is_anonymous: boolean
    text: string | null
    mood: string | null
    userId: string
    total_likes: number
    total_comments: number
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    is_anonymous?: boolean
    text?: boolean
    mood?: boolean
    userId?: boolean
    total_likes?: boolean
    total_comments?: boolean
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    mediaAttachments?: boolean | Post$mediaAttachmentsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    viewStatus?: boolean | Post$viewStatusArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    is_anonymous?: boolean
    text?: boolean
    mood?: boolean
    userId?: boolean
    total_likes?: boolean
    total_comments?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    is_anonymous?: boolean
    text?: boolean
    mood?: boolean
    userId?: boolean
    total_likes?: boolean
    total_comments?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    mediaAttachments?: boolean | Post$mediaAttachmentsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    viewStatus?: boolean | Post$viewStatusArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      mediaAttachments: Prisma.$MediaAttachmentPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      viewStatus: Prisma.$PostViewStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      is_anonymous: boolean
      text: string | null
      mood: string | null
      userId: string
      total_likes: number
      total_comments: number
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends Post$likesArgs<ExtArgs> = {}>(args?: Subset<T, Post$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    mediaAttachments<T extends Post$mediaAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$mediaAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viewStatus<T extends Post$viewStatusArgs<ExtArgs> = {}>(args?: Subset<T, Post$viewStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly is_anonymous: FieldRef<"Post", 'Boolean'>
    readonly text: FieldRef<"Post", 'String'>
    readonly mood: FieldRef<"Post", 'String'>
    readonly userId: FieldRef<"Post", 'String'>
    readonly total_likes: FieldRef<"Post", 'Int'>
    readonly total_comments: FieldRef<"Post", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.likes
   */
  export type Post$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Post.mediaAttachments
   */
  export type Post$mediaAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    where?: MediaAttachmentWhereInput
    orderBy?: MediaAttachmentOrderByWithRelationInput | MediaAttachmentOrderByWithRelationInput[]
    cursor?: MediaAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaAttachmentScalarFieldEnum | MediaAttachmentScalarFieldEnum[]
  }

  /**
   * Post.viewStatus
   */
  export type Post$viewStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    where?: PostViewStatusWhereInput
    orderBy?: PostViewStatusOrderByWithRelationInput | PostViewStatusOrderByWithRelationInput[]
    cursor?: PostViewStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostViewStatusScalarFieldEnum | PostViewStatusScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model MediaAttachment
   */

  export type AggregateMediaAttachment = {
    _count: MediaAttachmentCountAggregateOutputType | null
    _min: MediaAttachmentMinAggregateOutputType | null
    _max: MediaAttachmentMaxAggregateOutputType | null
  }

  export type MediaAttachmentMinAggregateOutputType = {
    id: string | null
    type: $Enums.MediaType | null
    url: string | null
    postId: string | null
  }

  export type MediaAttachmentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.MediaType | null
    url: string | null
    postId: string | null
  }

  export type MediaAttachmentCountAggregateOutputType = {
    id: number
    type: number
    url: number
    postId: number
    _all: number
  }


  export type MediaAttachmentMinAggregateInputType = {
    id?: true
    type?: true
    url?: true
    postId?: true
  }

  export type MediaAttachmentMaxAggregateInputType = {
    id?: true
    type?: true
    url?: true
    postId?: true
  }

  export type MediaAttachmentCountAggregateInputType = {
    id?: true
    type?: true
    url?: true
    postId?: true
    _all?: true
  }

  export type MediaAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAttachment to aggregate.
     */
    where?: MediaAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAttachments to fetch.
     */
    orderBy?: MediaAttachmentOrderByWithRelationInput | MediaAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaAttachments
    **/
    _count?: true | MediaAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaAttachmentMaxAggregateInputType
  }

  export type GetMediaAttachmentAggregateType<T extends MediaAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaAttachment[P]>
      : GetScalarType<T[P], AggregateMediaAttachment[P]>
  }




  export type MediaAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAttachmentWhereInput
    orderBy?: MediaAttachmentOrderByWithAggregationInput | MediaAttachmentOrderByWithAggregationInput[]
    by: MediaAttachmentScalarFieldEnum[] | MediaAttachmentScalarFieldEnum
    having?: MediaAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaAttachmentCountAggregateInputType | true
    _min?: MediaAttachmentMinAggregateInputType
    _max?: MediaAttachmentMaxAggregateInputType
  }

  export type MediaAttachmentGroupByOutputType = {
    id: string
    type: $Enums.MediaType
    url: string
    postId: string
    _count: MediaAttachmentCountAggregateOutputType | null
    _min: MediaAttachmentMinAggregateOutputType | null
    _max: MediaAttachmentMaxAggregateOutputType | null
  }

  type GetMediaAttachmentGroupByPayload<T extends MediaAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MediaAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MediaAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    postId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAttachment"]>

  export type MediaAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    url?: boolean
    postId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAttachment"]>

  export type MediaAttachmentSelectScalar = {
    id?: boolean
    type?: boolean
    url?: boolean
    postId?: boolean
  }

  export type MediaAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type MediaAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $MediaAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaAttachment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.MediaType
      url: string
      postId: string
    }, ExtArgs["result"]["mediaAttachment"]>
    composites: {}
  }

  type MediaAttachmentGetPayload<S extends boolean | null | undefined | MediaAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MediaAttachmentPayload, S>

  type MediaAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaAttachmentCountAggregateInputType | true
    }

  export interface MediaAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaAttachment'], meta: { name: 'MediaAttachment' } }
    /**
     * Find zero or one MediaAttachment that matches the filter.
     * @param {MediaAttachmentFindUniqueArgs} args - Arguments to find a MediaAttachment
     * @example
     * // Get one MediaAttachment
     * const mediaAttachment = await prisma.mediaAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaAttachmentFindUniqueArgs>(args: SelectSubset<T, MediaAttachmentFindUniqueArgs<ExtArgs>>): Prisma__MediaAttachmentClient<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MediaAttachment
     * @example
     * // Get one MediaAttachment
     * const mediaAttachment = await prisma.mediaAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaAttachmentClient<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAttachmentFindFirstArgs} args - Arguments to find a MediaAttachment
     * @example
     * // Get one MediaAttachment
     * const mediaAttachment = await prisma.mediaAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaAttachmentFindFirstArgs>(args?: SelectSubset<T, MediaAttachmentFindFirstArgs<ExtArgs>>): Prisma__MediaAttachmentClient<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAttachmentFindFirstOrThrowArgs} args - Arguments to find a MediaAttachment
     * @example
     * // Get one MediaAttachment
     * const mediaAttachment = await prisma.mediaAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaAttachmentClient<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaAttachments
     * const mediaAttachments = await prisma.mediaAttachment.findMany()
     * 
     * // Get first 10 MediaAttachments
     * const mediaAttachments = await prisma.mediaAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaAttachmentWithIdOnly = await prisma.mediaAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaAttachmentFindManyArgs>(args?: SelectSubset<T, MediaAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaAttachment.
     * @param {MediaAttachmentCreateArgs} args - Arguments to create a MediaAttachment.
     * @example
     * // Create one MediaAttachment
     * const MediaAttachment = await prisma.mediaAttachment.create({
     *   data: {
     *     // ... data to create a MediaAttachment
     *   }
     * })
     * 
     */
    create<T extends MediaAttachmentCreateArgs>(args: SelectSubset<T, MediaAttachmentCreateArgs<ExtArgs>>): Prisma__MediaAttachmentClient<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaAttachments.
     * @param {MediaAttachmentCreateManyArgs} args - Arguments to create many MediaAttachments.
     * @example
     * // Create many MediaAttachments
     * const mediaAttachment = await prisma.mediaAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaAttachmentCreateManyArgs>(args?: SelectSubset<T, MediaAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaAttachments and returns the data saved in the database.
     * @param {MediaAttachmentCreateManyAndReturnArgs} args - Arguments to create many MediaAttachments.
     * @example
     * // Create many MediaAttachments
     * const mediaAttachment = await prisma.mediaAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaAttachments and only return the `id`
     * const mediaAttachmentWithIdOnly = await prisma.mediaAttachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaAttachment.
     * @param {MediaAttachmentDeleteArgs} args - Arguments to delete one MediaAttachment.
     * @example
     * // Delete one MediaAttachment
     * const MediaAttachment = await prisma.mediaAttachment.delete({
     *   where: {
     *     // ... filter to delete one MediaAttachment
     *   }
     * })
     * 
     */
    delete<T extends MediaAttachmentDeleteArgs>(args: SelectSubset<T, MediaAttachmentDeleteArgs<ExtArgs>>): Prisma__MediaAttachmentClient<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaAttachment.
     * @param {MediaAttachmentUpdateArgs} args - Arguments to update one MediaAttachment.
     * @example
     * // Update one MediaAttachment
     * const mediaAttachment = await prisma.mediaAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaAttachmentUpdateArgs>(args: SelectSubset<T, MediaAttachmentUpdateArgs<ExtArgs>>): Prisma__MediaAttachmentClient<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaAttachments.
     * @param {MediaAttachmentDeleteManyArgs} args - Arguments to filter MediaAttachments to delete.
     * @example
     * // Delete a few MediaAttachments
     * const { count } = await prisma.mediaAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaAttachmentDeleteManyArgs>(args?: SelectSubset<T, MediaAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaAttachments
     * const mediaAttachment = await prisma.mediaAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaAttachmentUpdateManyArgs>(args: SelectSubset<T, MediaAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaAttachment.
     * @param {MediaAttachmentUpsertArgs} args - Arguments to update or create a MediaAttachment.
     * @example
     * // Update or create a MediaAttachment
     * const mediaAttachment = await prisma.mediaAttachment.upsert({
     *   create: {
     *     // ... data to create a MediaAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaAttachment we want to update
     *   }
     * })
     */
    upsert<T extends MediaAttachmentUpsertArgs>(args: SelectSubset<T, MediaAttachmentUpsertArgs<ExtArgs>>): Prisma__MediaAttachmentClient<$Result.GetResult<Prisma.$MediaAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAttachmentCountArgs} args - Arguments to filter MediaAttachments to count.
     * @example
     * // Count the number of MediaAttachments
     * const count = await prisma.mediaAttachment.count({
     *   where: {
     *     // ... the filter for the MediaAttachments we want to count
     *   }
     * })
    **/
    count<T extends MediaAttachmentCountArgs>(
      args?: Subset<T, MediaAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAttachmentAggregateArgs>(args: Subset<T, MediaAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMediaAttachmentAggregateType<T>>

    /**
     * Group by MediaAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MediaAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaAttachment model
   */
  readonly fields: MediaAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaAttachment model
   */ 
  interface MediaAttachmentFieldRefs {
    readonly id: FieldRef<"MediaAttachment", 'String'>
    readonly type: FieldRef<"MediaAttachment", 'MediaType'>
    readonly url: FieldRef<"MediaAttachment", 'String'>
    readonly postId: FieldRef<"MediaAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MediaAttachment findUnique
   */
  export type MediaAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MediaAttachment to fetch.
     */
    where: MediaAttachmentWhereUniqueInput
  }

  /**
   * MediaAttachment findUniqueOrThrow
   */
  export type MediaAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MediaAttachment to fetch.
     */
    where: MediaAttachmentWhereUniqueInput
  }

  /**
   * MediaAttachment findFirst
   */
  export type MediaAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MediaAttachment to fetch.
     */
    where?: MediaAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAttachments to fetch.
     */
    orderBy?: MediaAttachmentOrderByWithRelationInput | MediaAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAttachments.
     */
    cursor?: MediaAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAttachments.
     */
    distinct?: MediaAttachmentScalarFieldEnum | MediaAttachmentScalarFieldEnum[]
  }

  /**
   * MediaAttachment findFirstOrThrow
   */
  export type MediaAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MediaAttachment to fetch.
     */
    where?: MediaAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAttachments to fetch.
     */
    orderBy?: MediaAttachmentOrderByWithRelationInput | MediaAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAttachments.
     */
    cursor?: MediaAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAttachments.
     */
    distinct?: MediaAttachmentScalarFieldEnum | MediaAttachmentScalarFieldEnum[]
  }

  /**
   * MediaAttachment findMany
   */
  export type MediaAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MediaAttachments to fetch.
     */
    where?: MediaAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAttachments to fetch.
     */
    orderBy?: MediaAttachmentOrderByWithRelationInput | MediaAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaAttachments.
     */
    cursor?: MediaAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAttachments.
     */
    skip?: number
    distinct?: MediaAttachmentScalarFieldEnum | MediaAttachmentScalarFieldEnum[]
  }

  /**
   * MediaAttachment create
   */
  export type MediaAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaAttachment.
     */
    data: XOR<MediaAttachmentCreateInput, MediaAttachmentUncheckedCreateInput>
  }

  /**
   * MediaAttachment createMany
   */
  export type MediaAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaAttachments.
     */
    data: MediaAttachmentCreateManyInput | MediaAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaAttachment createManyAndReturn
   */
  export type MediaAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaAttachments.
     */
    data: MediaAttachmentCreateManyInput | MediaAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaAttachment update
   */
  export type MediaAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaAttachment.
     */
    data: XOR<MediaAttachmentUpdateInput, MediaAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MediaAttachment to update.
     */
    where: MediaAttachmentWhereUniqueInput
  }

  /**
   * MediaAttachment updateMany
   */
  export type MediaAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaAttachments.
     */
    data: XOR<MediaAttachmentUpdateManyMutationInput, MediaAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MediaAttachments to update
     */
    where?: MediaAttachmentWhereInput
  }

  /**
   * MediaAttachment upsert
   */
  export type MediaAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaAttachment to update in case it exists.
     */
    where: MediaAttachmentWhereUniqueInput
    /**
     * In case the MediaAttachment found by the `where` argument doesn't exist, create a new MediaAttachment with this data.
     */
    create: XOR<MediaAttachmentCreateInput, MediaAttachmentUncheckedCreateInput>
    /**
     * In case the MediaAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaAttachmentUpdateInput, MediaAttachmentUncheckedUpdateInput>
  }

  /**
   * MediaAttachment delete
   */
  export type MediaAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MediaAttachment to delete.
     */
    where: MediaAttachmentWhereUniqueInput
  }

  /**
   * MediaAttachment deleteMany
   */
  export type MediaAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAttachments to delete
     */
    where?: MediaAttachmentWhereInput
  }

  /**
   * MediaAttachment without action
   */
  export type MediaAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAttachment
     */
    select?: MediaAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    text: string | null
    postId: string | null
    userId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    text: string | null
    postId: string | null
    userId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    text: number
    postId: number
    userId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    text?: true
    postId?: true
    userId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    text?: true
    postId?: true
    userId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    text?: true
    postId?: true
    userId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    text: string
    postId: string
    userId: string
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    text?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    text?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    text?: boolean
    postId?: boolean
    userId?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      text: string
      postId: string
      userId: string
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postId: string | null
    userId: string | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postId: string | null
    userId: string | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    postId: number
    userId: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    postId?: true
    userId?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    postId?: true
    userId?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    postId?: true
    userId?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    postId: string
    userId: string
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postId?: boolean
    userId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postId?: boolean
    userId?: boolean
  }

  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      postId: string
      userId: string
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */ 
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
    readonly updatedAt: FieldRef<"Like", 'DateTime'>
    readonly postId: FieldRef<"Like", 'String'>
    readonly userId: FieldRef<"Like", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Help
   */

  export type AggregateHelp = {
    _count: HelpCountAggregateOutputType | null
    _avg: HelpAvgAggregateOutputType | null
    _sum: HelpSumAggregateOutputType | null
    _min: HelpMinAggregateOutputType | null
    _max: HelpMaxAggregateOutputType | null
  }

  export type HelpAvgAggregateOutputType = {
    locationLat: number | null
    locationLng: number | null
  }

  export type HelpSumAggregateOutputType = {
    locationLat: number | null
    locationLng: number | null
  }

  export type HelpMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    requestedById: string | null
    helperId: string | null
    status: $Enums.HelpStatus | null
    locationLat: number | null
    locationLng: number | null
    address: string | null
    isDeleted: boolean | null
  }

  export type HelpMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    requestedById: string | null
    helperId: string | null
    status: $Enums.HelpStatus | null
    locationLat: number | null
    locationLng: number | null
    address: string | null
    isDeleted: boolean | null
  }

  export type HelpCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    requestedById: number
    helperId: number
    status: number
    locationLat: number
    locationLng: number
    address: number
    isDeleted: number
    _all: number
  }


  export type HelpAvgAggregateInputType = {
    locationLat?: true
    locationLng?: true
  }

  export type HelpSumAggregateInputType = {
    locationLat?: true
    locationLng?: true
  }

  export type HelpMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    requestedById?: true
    helperId?: true
    status?: true
    locationLat?: true
    locationLng?: true
    address?: true
    isDeleted?: true
  }

  export type HelpMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    requestedById?: true
    helperId?: true
    status?: true
    locationLat?: true
    locationLng?: true
    address?: true
    isDeleted?: true
  }

  export type HelpCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    requestedById?: true
    helperId?: true
    status?: true
    locationLat?: true
    locationLng?: true
    address?: true
    isDeleted?: true
    _all?: true
  }

  export type HelpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Help to aggregate.
     */
    where?: HelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helps to fetch.
     */
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Helps
    **/
    _count?: true | HelpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpMaxAggregateInputType
  }

  export type GetHelpAggregateType<T extends HelpAggregateArgs> = {
        [P in keyof T & keyof AggregateHelp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelp[P]>
      : GetScalarType<T[P], AggregateHelp[P]>
  }




  export type HelpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpWhereInput
    orderBy?: HelpOrderByWithAggregationInput | HelpOrderByWithAggregationInput[]
    by: HelpScalarFieldEnum[] | HelpScalarFieldEnum
    having?: HelpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpCountAggregateInputType | true
    _avg?: HelpAvgAggregateInputType
    _sum?: HelpSumAggregateInputType
    _min?: HelpMinAggregateInputType
    _max?: HelpMaxAggregateInputType
  }

  export type HelpGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    expiresAt: Date
    requestedById: string
    helperId: string | null
    status: $Enums.HelpStatus
    locationLat: number | null
    locationLng: number | null
    address: string | null
    isDeleted: boolean
    _count: HelpCountAggregateOutputType | null
    _avg: HelpAvgAggregateOutputType | null
    _sum: HelpSumAggregateOutputType | null
    _min: HelpMinAggregateOutputType | null
    _max: HelpMaxAggregateOutputType | null
  }

  type GetHelpGroupByPayload<T extends HelpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpGroupByOutputType[P]>
            : GetScalarType<T[P], HelpGroupByOutputType[P]>
        }
      >
    >


  export type HelpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    requestedById?: boolean
    helperId?: boolean
    status?: boolean
    locationLat?: boolean
    locationLng?: boolean
    address?: boolean
    isDeleted?: boolean
    helpReadStatus?: boolean | Help$helpReadStatusArgs<ExtArgs>
    messages?: boolean | Help$messagesArgs<ExtArgs>
    helper?: boolean | Help$helperArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | HelpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["help"]>

  export type HelpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    requestedById?: boolean
    helperId?: boolean
    status?: boolean
    locationLat?: boolean
    locationLng?: boolean
    address?: boolean
    isDeleted?: boolean
    helper?: boolean | Help$helperArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["help"]>

  export type HelpSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    requestedById?: boolean
    helperId?: boolean
    status?: boolean
    locationLat?: boolean
    locationLng?: boolean
    address?: boolean
    isDeleted?: boolean
  }

  export type HelpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpReadStatus?: boolean | Help$helpReadStatusArgs<ExtArgs>
    messages?: boolean | Help$messagesArgs<ExtArgs>
    helper?: boolean | Help$helperArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | HelpCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HelpIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helper?: boolean | Help$helperArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HelpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Help"
    objects: {
      helpReadStatus: Prisma.$HelpReadStatusPayload<ExtArgs>[]
      messages: Prisma.$HelpMessagePayload<ExtArgs>[]
      helper: Prisma.$UserPayload<ExtArgs> | null
      requestedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      expiresAt: Date
      requestedById: string
      helperId: string | null
      status: $Enums.HelpStatus
      locationLat: number | null
      locationLng: number | null
      address: string | null
      isDeleted: boolean
    }, ExtArgs["result"]["help"]>
    composites: {}
  }

  type HelpGetPayload<S extends boolean | null | undefined | HelpDefaultArgs> = $Result.GetResult<Prisma.$HelpPayload, S>

  type HelpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpCountAggregateInputType | true
    }

  export interface HelpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Help'], meta: { name: 'Help' } }
    /**
     * Find zero or one Help that matches the filter.
     * @param {HelpFindUniqueArgs} args - Arguments to find a Help
     * @example
     * // Get one Help
     * const help = await prisma.help.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpFindUniqueArgs>(args: SelectSubset<T, HelpFindUniqueArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Help that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpFindUniqueOrThrowArgs} args - Arguments to find a Help
     * @example
     * // Get one Help
     * const help = await prisma.help.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Help that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpFindFirstArgs} args - Arguments to find a Help
     * @example
     * // Get one Help
     * const help = await prisma.help.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpFindFirstArgs>(args?: SelectSubset<T, HelpFindFirstArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Help that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpFindFirstOrThrowArgs} args - Arguments to find a Help
     * @example
     * // Get one Help
     * const help = await prisma.help.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Helps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Helps
     * const helps = await prisma.help.findMany()
     * 
     * // Get first 10 Helps
     * const helps = await prisma.help.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpWithIdOnly = await prisma.help.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpFindManyArgs>(args?: SelectSubset<T, HelpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Help.
     * @param {HelpCreateArgs} args - Arguments to create a Help.
     * @example
     * // Create one Help
     * const Help = await prisma.help.create({
     *   data: {
     *     // ... data to create a Help
     *   }
     * })
     * 
     */
    create<T extends HelpCreateArgs>(args: SelectSubset<T, HelpCreateArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Helps.
     * @param {HelpCreateManyArgs} args - Arguments to create many Helps.
     * @example
     * // Create many Helps
     * const help = await prisma.help.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpCreateManyArgs>(args?: SelectSubset<T, HelpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Helps and returns the data saved in the database.
     * @param {HelpCreateManyAndReturnArgs} args - Arguments to create many Helps.
     * @example
     * // Create many Helps
     * const help = await prisma.help.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Helps and only return the `id`
     * const helpWithIdOnly = await prisma.help.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Help.
     * @param {HelpDeleteArgs} args - Arguments to delete one Help.
     * @example
     * // Delete one Help
     * const Help = await prisma.help.delete({
     *   where: {
     *     // ... filter to delete one Help
     *   }
     * })
     * 
     */
    delete<T extends HelpDeleteArgs>(args: SelectSubset<T, HelpDeleteArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Help.
     * @param {HelpUpdateArgs} args - Arguments to update one Help.
     * @example
     * // Update one Help
     * const help = await prisma.help.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpUpdateArgs>(args: SelectSubset<T, HelpUpdateArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Helps.
     * @param {HelpDeleteManyArgs} args - Arguments to filter Helps to delete.
     * @example
     * // Delete a few Helps
     * const { count } = await prisma.help.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpDeleteManyArgs>(args?: SelectSubset<T, HelpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Helps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Helps
     * const help = await prisma.help.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpUpdateManyArgs>(args: SelectSubset<T, HelpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Help.
     * @param {HelpUpsertArgs} args - Arguments to update or create a Help.
     * @example
     * // Update or create a Help
     * const help = await prisma.help.upsert({
     *   create: {
     *     // ... data to create a Help
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Help we want to update
     *   }
     * })
     */
    upsert<T extends HelpUpsertArgs>(args: SelectSubset<T, HelpUpsertArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Helps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCountArgs} args - Arguments to filter Helps to count.
     * @example
     * // Count the number of Helps
     * const count = await prisma.help.count({
     *   where: {
     *     // ... the filter for the Helps we want to count
     *   }
     * })
    **/
    count<T extends HelpCountArgs>(
      args?: Subset<T, HelpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Help.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpAggregateArgs>(args: Subset<T, HelpAggregateArgs>): Prisma.PrismaPromise<GetHelpAggregateType<T>>

    /**
     * Group by Help.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpGroupByArgs['orderBy'] }
        : { orderBy?: HelpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Help model
   */
  readonly fields: HelpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Help.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    helpReadStatus<T extends Help$helpReadStatusArgs<ExtArgs> = {}>(args?: Subset<T, Help$helpReadStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Help$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Help$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "findMany"> | Null>
    helper<T extends Help$helperArgs<ExtArgs> = {}>(args?: Subset<T, Help$helperArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    requestedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Help model
   */ 
  interface HelpFieldRefs {
    readonly id: FieldRef<"Help", 'String'>
    readonly createdAt: FieldRef<"Help", 'DateTime'>
    readonly updatedAt: FieldRef<"Help", 'DateTime'>
    readonly expiresAt: FieldRef<"Help", 'DateTime'>
    readonly requestedById: FieldRef<"Help", 'String'>
    readonly helperId: FieldRef<"Help", 'String'>
    readonly status: FieldRef<"Help", 'HelpStatus'>
    readonly locationLat: FieldRef<"Help", 'Float'>
    readonly locationLng: FieldRef<"Help", 'Float'>
    readonly address: FieldRef<"Help", 'String'>
    readonly isDeleted: FieldRef<"Help", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Help findUnique
   */
  export type HelpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    /**
     * Filter, which Help to fetch.
     */
    where: HelpWhereUniqueInput
  }

  /**
   * Help findUniqueOrThrow
   */
  export type HelpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    /**
     * Filter, which Help to fetch.
     */
    where: HelpWhereUniqueInput
  }

  /**
   * Help findFirst
   */
  export type HelpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    /**
     * Filter, which Help to fetch.
     */
    where?: HelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helps to fetch.
     */
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Helps.
     */
    cursor?: HelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Helps.
     */
    distinct?: HelpScalarFieldEnum | HelpScalarFieldEnum[]
  }

  /**
   * Help findFirstOrThrow
   */
  export type HelpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    /**
     * Filter, which Help to fetch.
     */
    where?: HelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helps to fetch.
     */
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Helps.
     */
    cursor?: HelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Helps.
     */
    distinct?: HelpScalarFieldEnum | HelpScalarFieldEnum[]
  }

  /**
   * Help findMany
   */
  export type HelpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    /**
     * Filter, which Helps to fetch.
     */
    where?: HelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helps to fetch.
     */
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Helps.
     */
    cursor?: HelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helps.
     */
    skip?: number
    distinct?: HelpScalarFieldEnum | HelpScalarFieldEnum[]
  }

  /**
   * Help create
   */
  export type HelpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    /**
     * The data needed to create a Help.
     */
    data: XOR<HelpCreateInput, HelpUncheckedCreateInput>
  }

  /**
   * Help createMany
   */
  export type HelpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Helps.
     */
    data: HelpCreateManyInput | HelpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Help createManyAndReturn
   */
  export type HelpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Helps.
     */
    data: HelpCreateManyInput | HelpCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Help update
   */
  export type HelpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    /**
     * The data needed to update a Help.
     */
    data: XOR<HelpUpdateInput, HelpUncheckedUpdateInput>
    /**
     * Choose, which Help to update.
     */
    where: HelpWhereUniqueInput
  }

  /**
   * Help updateMany
   */
  export type HelpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Helps.
     */
    data: XOR<HelpUpdateManyMutationInput, HelpUncheckedUpdateManyInput>
    /**
     * Filter which Helps to update
     */
    where?: HelpWhereInput
  }

  /**
   * Help upsert
   */
  export type HelpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    /**
     * The filter to search for the Help to update in case it exists.
     */
    where: HelpWhereUniqueInput
    /**
     * In case the Help found by the `where` argument doesn't exist, create a new Help with this data.
     */
    create: XOR<HelpCreateInput, HelpUncheckedCreateInput>
    /**
     * In case the Help was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpUpdateInput, HelpUncheckedUpdateInput>
  }

  /**
   * Help delete
   */
  export type HelpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
    /**
     * Filter which Help to delete.
     */
    where: HelpWhereUniqueInput
  }

  /**
   * Help deleteMany
   */
  export type HelpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Helps to delete
     */
    where?: HelpWhereInput
  }

  /**
   * Help.helpReadStatus
   */
  export type Help$helpReadStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    where?: HelpReadStatusWhereInput
    orderBy?: HelpReadStatusOrderByWithRelationInput | HelpReadStatusOrderByWithRelationInput[]
    cursor?: HelpReadStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpReadStatusScalarFieldEnum | HelpReadStatusScalarFieldEnum[]
  }

  /**
   * Help.messages
   */
  export type Help$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    where?: HelpMessageWhereInput
    orderBy?: HelpMessageOrderByWithRelationInput | HelpMessageOrderByWithRelationInput[]
    cursor?: HelpMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpMessageScalarFieldEnum | HelpMessageScalarFieldEnum[]
  }

  /**
   * Help.helper
   */
  export type Help$helperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Help without action
   */
  export type HelpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpInclude<ExtArgs> | null
  }


  /**
   * Model HelpMessage
   */

  export type AggregateHelpMessage = {
    _count: HelpMessageCountAggregateOutputType | null
    _avg: HelpMessageAvgAggregateOutputType | null
    _sum: HelpMessageSumAggregateOutputType | null
    _min: HelpMessageMinAggregateOutputType | null
    _max: HelpMessageMaxAggregateOutputType | null
  }

  export type HelpMessageAvgAggregateOutputType = {
    locationLat: number | null
    locationLng: number | null
  }

  export type HelpMessageSumAggregateOutputType = {
    locationLat: number | null
    locationLng: number | null
  }

  export type HelpMessageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    helpId: string | null
    senderId: string | null
    message: string | null
    status: $Enums.ChatroomMessageStatus | null
    type: $Enums.ChatroomMessageType | null
    file: string | null
    locationLat: number | null
    locationLng: number | null
    isDeleted: boolean | null
    reply_id: string | null
  }

  export type HelpMessageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    helpId: string | null
    senderId: string | null
    message: string | null
    status: $Enums.ChatroomMessageStatus | null
    type: $Enums.ChatroomMessageType | null
    file: string | null
    locationLat: number | null
    locationLng: number | null
    isDeleted: boolean | null
    reply_id: string | null
  }

  export type HelpMessageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    helpId: number
    senderId: number
    message: number
    status: number
    type: number
    file: number
    locationLat: number
    locationLng: number
    isDeleted: number
    reply_id: number
    _all: number
  }


  export type HelpMessageAvgAggregateInputType = {
    locationLat?: true
    locationLng?: true
  }

  export type HelpMessageSumAggregateInputType = {
    locationLat?: true
    locationLng?: true
  }

  export type HelpMessageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    helpId?: true
    senderId?: true
    message?: true
    status?: true
    type?: true
    file?: true
    locationLat?: true
    locationLng?: true
    isDeleted?: true
    reply_id?: true
  }

  export type HelpMessageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    helpId?: true
    senderId?: true
    message?: true
    status?: true
    type?: true
    file?: true
    locationLat?: true
    locationLng?: true
    isDeleted?: true
    reply_id?: true
  }

  export type HelpMessageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    helpId?: true
    senderId?: true
    message?: true
    status?: true
    type?: true
    file?: true
    locationLat?: true
    locationLng?: true
    isDeleted?: true
    reply_id?: true
    _all?: true
  }

  export type HelpMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpMessage to aggregate.
     */
    where?: HelpMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpMessages to fetch.
     */
    orderBy?: HelpMessageOrderByWithRelationInput | HelpMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpMessages
    **/
    _count?: true | HelpMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpMessageMaxAggregateInputType
  }

  export type GetHelpMessageAggregateType<T extends HelpMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpMessage[P]>
      : GetScalarType<T[P], AggregateHelpMessage[P]>
  }




  export type HelpMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpMessageWhereInput
    orderBy?: HelpMessageOrderByWithAggregationInput | HelpMessageOrderByWithAggregationInput[]
    by: HelpMessageScalarFieldEnum[] | HelpMessageScalarFieldEnum
    having?: HelpMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpMessageCountAggregateInputType | true
    _avg?: HelpMessageAvgAggregateInputType
    _sum?: HelpMessageSumAggregateInputType
    _min?: HelpMessageMinAggregateInputType
    _max?: HelpMessageMaxAggregateInputType
  }

  export type HelpMessageGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    helpId: string
    senderId: string
    message: string | null
    status: $Enums.ChatroomMessageStatus
    type: $Enums.ChatroomMessageType
    file: string | null
    locationLat: number | null
    locationLng: number | null
    isDeleted: boolean
    reply_id: string | null
    _count: HelpMessageCountAggregateOutputType | null
    _avg: HelpMessageAvgAggregateOutputType | null
    _sum: HelpMessageSumAggregateOutputType | null
    _min: HelpMessageMinAggregateOutputType | null
    _max: HelpMessageMaxAggregateOutputType | null
  }

  type GetHelpMessageGroupByPayload<T extends HelpMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpMessageGroupByOutputType[P]>
            : GetScalarType<T[P], HelpMessageGroupByOutputType[P]>
        }
      >
    >


  export type HelpMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    helpId?: boolean
    senderId?: boolean
    message?: boolean
    status?: boolean
    type?: boolean
    file?: boolean
    locationLat?: boolean
    locationLng?: boolean
    isDeleted?: boolean
    reply_id?: boolean
    readBy?: boolean | HelpMessage$readByArgs<ExtArgs>
    help?: boolean | HelpDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | HelpMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpMessage"]>

  export type HelpMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    helpId?: boolean
    senderId?: boolean
    message?: boolean
    status?: boolean
    type?: boolean
    file?: boolean
    locationLat?: boolean
    locationLng?: boolean
    isDeleted?: boolean
    reply_id?: boolean
    help?: boolean | HelpDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpMessage"]>

  export type HelpMessageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    helpId?: boolean
    senderId?: boolean
    message?: boolean
    status?: boolean
    type?: boolean
    file?: boolean
    locationLat?: boolean
    locationLng?: boolean
    isDeleted?: boolean
    reply_id?: boolean
  }

  export type HelpMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    readBy?: boolean | HelpMessage$readByArgs<ExtArgs>
    help?: boolean | HelpDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | HelpMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HelpMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    help?: boolean | HelpDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HelpMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpMessage"
    objects: {
      readBy: Prisma.$HelpReadStatusPayload<ExtArgs>[]
      help: Prisma.$HelpPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      helpId: string
      senderId: string
      message: string | null
      status: $Enums.ChatroomMessageStatus
      type: $Enums.ChatroomMessageType
      file: string | null
      locationLat: number | null
      locationLng: number | null
      isDeleted: boolean
      reply_id: string | null
    }, ExtArgs["result"]["helpMessage"]>
    composites: {}
  }

  type HelpMessageGetPayload<S extends boolean | null | undefined | HelpMessageDefaultArgs> = $Result.GetResult<Prisma.$HelpMessagePayload, S>

  type HelpMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpMessageCountAggregateInputType | true
    }

  export interface HelpMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpMessage'], meta: { name: 'HelpMessage' } }
    /**
     * Find zero or one HelpMessage that matches the filter.
     * @param {HelpMessageFindUniqueArgs} args - Arguments to find a HelpMessage
     * @example
     * // Get one HelpMessage
     * const helpMessage = await prisma.helpMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpMessageFindUniqueArgs>(args: SelectSubset<T, HelpMessageFindUniqueArgs<ExtArgs>>): Prisma__HelpMessageClient<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpMessageFindUniqueOrThrowArgs} args - Arguments to find a HelpMessage
     * @example
     * // Get one HelpMessage
     * const helpMessage = await prisma.helpMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpMessageClient<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpMessageFindFirstArgs} args - Arguments to find a HelpMessage
     * @example
     * // Get one HelpMessage
     * const helpMessage = await prisma.helpMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpMessageFindFirstArgs>(args?: SelectSubset<T, HelpMessageFindFirstArgs<ExtArgs>>): Prisma__HelpMessageClient<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpMessageFindFirstOrThrowArgs} args - Arguments to find a HelpMessage
     * @example
     * // Get one HelpMessage
     * const helpMessage = await prisma.helpMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpMessageClient<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpMessages
     * const helpMessages = await prisma.helpMessage.findMany()
     * 
     * // Get first 10 HelpMessages
     * const helpMessages = await prisma.helpMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpMessageWithIdOnly = await prisma.helpMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpMessageFindManyArgs>(args?: SelectSubset<T, HelpMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpMessage.
     * @param {HelpMessageCreateArgs} args - Arguments to create a HelpMessage.
     * @example
     * // Create one HelpMessage
     * const HelpMessage = await prisma.helpMessage.create({
     *   data: {
     *     // ... data to create a HelpMessage
     *   }
     * })
     * 
     */
    create<T extends HelpMessageCreateArgs>(args: SelectSubset<T, HelpMessageCreateArgs<ExtArgs>>): Prisma__HelpMessageClient<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpMessages.
     * @param {HelpMessageCreateManyArgs} args - Arguments to create many HelpMessages.
     * @example
     * // Create many HelpMessages
     * const helpMessage = await prisma.helpMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpMessageCreateManyArgs>(args?: SelectSubset<T, HelpMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpMessages and returns the data saved in the database.
     * @param {HelpMessageCreateManyAndReturnArgs} args - Arguments to create many HelpMessages.
     * @example
     * // Create many HelpMessages
     * const helpMessage = await prisma.helpMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpMessages and only return the `id`
     * const helpMessageWithIdOnly = await prisma.helpMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HelpMessage.
     * @param {HelpMessageDeleteArgs} args - Arguments to delete one HelpMessage.
     * @example
     * // Delete one HelpMessage
     * const HelpMessage = await prisma.helpMessage.delete({
     *   where: {
     *     // ... filter to delete one HelpMessage
     *   }
     * })
     * 
     */
    delete<T extends HelpMessageDeleteArgs>(args: SelectSubset<T, HelpMessageDeleteArgs<ExtArgs>>): Prisma__HelpMessageClient<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpMessage.
     * @param {HelpMessageUpdateArgs} args - Arguments to update one HelpMessage.
     * @example
     * // Update one HelpMessage
     * const helpMessage = await prisma.helpMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpMessageUpdateArgs>(args: SelectSubset<T, HelpMessageUpdateArgs<ExtArgs>>): Prisma__HelpMessageClient<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpMessages.
     * @param {HelpMessageDeleteManyArgs} args - Arguments to filter HelpMessages to delete.
     * @example
     * // Delete a few HelpMessages
     * const { count } = await prisma.helpMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpMessageDeleteManyArgs>(args?: SelectSubset<T, HelpMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpMessages
     * const helpMessage = await prisma.helpMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpMessageUpdateManyArgs>(args: SelectSubset<T, HelpMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpMessage.
     * @param {HelpMessageUpsertArgs} args - Arguments to update or create a HelpMessage.
     * @example
     * // Update or create a HelpMessage
     * const helpMessage = await prisma.helpMessage.upsert({
     *   create: {
     *     // ... data to create a HelpMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpMessage we want to update
     *   }
     * })
     */
    upsert<T extends HelpMessageUpsertArgs>(args: SelectSubset<T, HelpMessageUpsertArgs<ExtArgs>>): Prisma__HelpMessageClient<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpMessageCountArgs} args - Arguments to filter HelpMessages to count.
     * @example
     * // Count the number of HelpMessages
     * const count = await prisma.helpMessage.count({
     *   where: {
     *     // ... the filter for the HelpMessages we want to count
     *   }
     * })
    **/
    count<T extends HelpMessageCountArgs>(
      args?: Subset<T, HelpMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpMessageAggregateArgs>(args: Subset<T, HelpMessageAggregateArgs>): Prisma.PrismaPromise<GetHelpMessageAggregateType<T>>

    /**
     * Group by HelpMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpMessageGroupByArgs['orderBy'] }
        : { orderBy?: HelpMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpMessage model
   */
  readonly fields: HelpMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    readBy<T extends HelpMessage$readByArgs<ExtArgs> = {}>(args?: Subset<T, HelpMessage$readByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "findMany"> | Null>
    help<T extends HelpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HelpDefaultArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpMessage model
   */ 
  interface HelpMessageFieldRefs {
    readonly id: FieldRef<"HelpMessage", 'String'>
    readonly createdAt: FieldRef<"HelpMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"HelpMessage", 'DateTime'>
    readonly helpId: FieldRef<"HelpMessage", 'String'>
    readonly senderId: FieldRef<"HelpMessage", 'String'>
    readonly message: FieldRef<"HelpMessage", 'String'>
    readonly status: FieldRef<"HelpMessage", 'ChatroomMessageStatus'>
    readonly type: FieldRef<"HelpMessage", 'ChatroomMessageType'>
    readonly file: FieldRef<"HelpMessage", 'String'>
    readonly locationLat: FieldRef<"HelpMessage", 'Float'>
    readonly locationLng: FieldRef<"HelpMessage", 'Float'>
    readonly isDeleted: FieldRef<"HelpMessage", 'Boolean'>
    readonly reply_id: FieldRef<"HelpMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HelpMessage findUnique
   */
  export type HelpMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpMessage to fetch.
     */
    where: HelpMessageWhereUniqueInput
  }

  /**
   * HelpMessage findUniqueOrThrow
   */
  export type HelpMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpMessage to fetch.
     */
    where: HelpMessageWhereUniqueInput
  }

  /**
   * HelpMessage findFirst
   */
  export type HelpMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpMessage to fetch.
     */
    where?: HelpMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpMessages to fetch.
     */
    orderBy?: HelpMessageOrderByWithRelationInput | HelpMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpMessages.
     */
    cursor?: HelpMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpMessages.
     */
    distinct?: HelpMessageScalarFieldEnum | HelpMessageScalarFieldEnum[]
  }

  /**
   * HelpMessage findFirstOrThrow
   */
  export type HelpMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpMessage to fetch.
     */
    where?: HelpMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpMessages to fetch.
     */
    orderBy?: HelpMessageOrderByWithRelationInput | HelpMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpMessages.
     */
    cursor?: HelpMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpMessages.
     */
    distinct?: HelpMessageScalarFieldEnum | HelpMessageScalarFieldEnum[]
  }

  /**
   * HelpMessage findMany
   */
  export type HelpMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    /**
     * Filter, which HelpMessages to fetch.
     */
    where?: HelpMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpMessages to fetch.
     */
    orderBy?: HelpMessageOrderByWithRelationInput | HelpMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpMessages.
     */
    cursor?: HelpMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpMessages.
     */
    skip?: number
    distinct?: HelpMessageScalarFieldEnum | HelpMessageScalarFieldEnum[]
  }

  /**
   * HelpMessage create
   */
  export type HelpMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpMessage.
     */
    data: XOR<HelpMessageCreateInput, HelpMessageUncheckedCreateInput>
  }

  /**
   * HelpMessage createMany
   */
  export type HelpMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpMessages.
     */
    data: HelpMessageCreateManyInput | HelpMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HelpMessage createManyAndReturn
   */
  export type HelpMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HelpMessages.
     */
    data: HelpMessageCreateManyInput | HelpMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpMessage update
   */
  export type HelpMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpMessage.
     */
    data: XOR<HelpMessageUpdateInput, HelpMessageUncheckedUpdateInput>
    /**
     * Choose, which HelpMessage to update.
     */
    where: HelpMessageWhereUniqueInput
  }

  /**
   * HelpMessage updateMany
   */
  export type HelpMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpMessages.
     */
    data: XOR<HelpMessageUpdateManyMutationInput, HelpMessageUncheckedUpdateManyInput>
    /**
     * Filter which HelpMessages to update
     */
    where?: HelpMessageWhereInput
  }

  /**
   * HelpMessage upsert
   */
  export type HelpMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpMessage to update in case it exists.
     */
    where: HelpMessageWhereUniqueInput
    /**
     * In case the HelpMessage found by the `where` argument doesn't exist, create a new HelpMessage with this data.
     */
    create: XOR<HelpMessageCreateInput, HelpMessageUncheckedCreateInput>
    /**
     * In case the HelpMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpMessageUpdateInput, HelpMessageUncheckedUpdateInput>
  }

  /**
   * HelpMessage delete
   */
  export type HelpMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    /**
     * Filter which HelpMessage to delete.
     */
    where: HelpMessageWhereUniqueInput
  }

  /**
   * HelpMessage deleteMany
   */
  export type HelpMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpMessages to delete
     */
    where?: HelpMessageWhereInput
  }

  /**
   * HelpMessage.readBy
   */
  export type HelpMessage$readByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    where?: HelpReadStatusWhereInput
    orderBy?: HelpReadStatusOrderByWithRelationInput | HelpReadStatusOrderByWithRelationInput[]
    cursor?: HelpReadStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpReadStatusScalarFieldEnum | HelpReadStatusScalarFieldEnum[]
  }

  /**
   * HelpMessage without action
   */
  export type HelpMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
  }


  /**
   * Model HelpReadStatus
   */

  export type AggregateHelpReadStatus = {
    _count: HelpReadStatusCountAggregateOutputType | null
    _min: HelpReadStatusMinAggregateOutputType | null
    _max: HelpReadStatusMaxAggregateOutputType | null
  }

  export type HelpReadStatusMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    helpId: string | null
    userId: string | null
    helpMessageId: string | null
  }

  export type HelpReadStatusMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    helpId: string | null
    userId: string | null
    helpMessageId: string | null
  }

  export type HelpReadStatusCountAggregateOutputType = {
    id: number
    createdAt: number
    helpId: number
    userId: number
    helpMessageId: number
    _all: number
  }


  export type HelpReadStatusMinAggregateInputType = {
    id?: true
    createdAt?: true
    helpId?: true
    userId?: true
    helpMessageId?: true
  }

  export type HelpReadStatusMaxAggregateInputType = {
    id?: true
    createdAt?: true
    helpId?: true
    userId?: true
    helpMessageId?: true
  }

  export type HelpReadStatusCountAggregateInputType = {
    id?: true
    createdAt?: true
    helpId?: true
    userId?: true
    helpMessageId?: true
    _all?: true
  }

  export type HelpReadStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpReadStatus to aggregate.
     */
    where?: HelpReadStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpReadStatuses to fetch.
     */
    orderBy?: HelpReadStatusOrderByWithRelationInput | HelpReadStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpReadStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpReadStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpReadStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpReadStatuses
    **/
    _count?: true | HelpReadStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpReadStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpReadStatusMaxAggregateInputType
  }

  export type GetHelpReadStatusAggregateType<T extends HelpReadStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpReadStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpReadStatus[P]>
      : GetScalarType<T[P], AggregateHelpReadStatus[P]>
  }




  export type HelpReadStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpReadStatusWhereInput
    orderBy?: HelpReadStatusOrderByWithAggregationInput | HelpReadStatusOrderByWithAggregationInput[]
    by: HelpReadStatusScalarFieldEnum[] | HelpReadStatusScalarFieldEnum
    having?: HelpReadStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpReadStatusCountAggregateInputType | true
    _min?: HelpReadStatusMinAggregateInputType
    _max?: HelpReadStatusMaxAggregateInputType
  }

  export type HelpReadStatusGroupByOutputType = {
    id: string
    createdAt: Date
    helpId: string
    userId: string
    helpMessageId: string | null
    _count: HelpReadStatusCountAggregateOutputType | null
    _min: HelpReadStatusMinAggregateOutputType | null
    _max: HelpReadStatusMaxAggregateOutputType | null
  }

  type GetHelpReadStatusGroupByPayload<T extends HelpReadStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpReadStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpReadStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpReadStatusGroupByOutputType[P]>
            : GetScalarType<T[P], HelpReadStatusGroupByOutputType[P]>
        }
      >
    >


  export type HelpReadStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    helpId?: boolean
    userId?: boolean
    helpMessageId?: boolean
    help?: boolean | HelpDefaultArgs<ExtArgs>
    helpMessage?: boolean | HelpReadStatus$helpMessageArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpReadStatus"]>

  export type HelpReadStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    helpId?: boolean
    userId?: boolean
    helpMessageId?: boolean
    help?: boolean | HelpDefaultArgs<ExtArgs>
    helpMessage?: boolean | HelpReadStatus$helpMessageArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpReadStatus"]>

  export type HelpReadStatusSelectScalar = {
    id?: boolean
    createdAt?: boolean
    helpId?: boolean
    userId?: boolean
    helpMessageId?: boolean
  }

  export type HelpReadStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    help?: boolean | HelpDefaultArgs<ExtArgs>
    helpMessage?: boolean | HelpReadStatus$helpMessageArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HelpReadStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    help?: boolean | HelpDefaultArgs<ExtArgs>
    helpMessage?: boolean | HelpReadStatus$helpMessageArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HelpReadStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpReadStatus"
    objects: {
      help: Prisma.$HelpPayload<ExtArgs>
      helpMessage: Prisma.$HelpMessagePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      helpId: string
      userId: string
      helpMessageId: string | null
    }, ExtArgs["result"]["helpReadStatus"]>
    composites: {}
  }

  type HelpReadStatusGetPayload<S extends boolean | null | undefined | HelpReadStatusDefaultArgs> = $Result.GetResult<Prisma.$HelpReadStatusPayload, S>

  type HelpReadStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpReadStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpReadStatusCountAggregateInputType | true
    }

  export interface HelpReadStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpReadStatus'], meta: { name: 'HelpReadStatus' } }
    /**
     * Find zero or one HelpReadStatus that matches the filter.
     * @param {HelpReadStatusFindUniqueArgs} args - Arguments to find a HelpReadStatus
     * @example
     * // Get one HelpReadStatus
     * const helpReadStatus = await prisma.helpReadStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpReadStatusFindUniqueArgs>(args: SelectSubset<T, HelpReadStatusFindUniqueArgs<ExtArgs>>): Prisma__HelpReadStatusClient<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpReadStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpReadStatusFindUniqueOrThrowArgs} args - Arguments to find a HelpReadStatus
     * @example
     * // Get one HelpReadStatus
     * const helpReadStatus = await prisma.helpReadStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpReadStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpReadStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpReadStatusClient<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpReadStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpReadStatusFindFirstArgs} args - Arguments to find a HelpReadStatus
     * @example
     * // Get one HelpReadStatus
     * const helpReadStatus = await prisma.helpReadStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpReadStatusFindFirstArgs>(args?: SelectSubset<T, HelpReadStatusFindFirstArgs<ExtArgs>>): Prisma__HelpReadStatusClient<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpReadStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpReadStatusFindFirstOrThrowArgs} args - Arguments to find a HelpReadStatus
     * @example
     * // Get one HelpReadStatus
     * const helpReadStatus = await prisma.helpReadStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpReadStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpReadStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpReadStatusClient<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpReadStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpReadStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpReadStatuses
     * const helpReadStatuses = await prisma.helpReadStatus.findMany()
     * 
     * // Get first 10 HelpReadStatuses
     * const helpReadStatuses = await prisma.helpReadStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpReadStatusWithIdOnly = await prisma.helpReadStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpReadStatusFindManyArgs>(args?: SelectSubset<T, HelpReadStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpReadStatus.
     * @param {HelpReadStatusCreateArgs} args - Arguments to create a HelpReadStatus.
     * @example
     * // Create one HelpReadStatus
     * const HelpReadStatus = await prisma.helpReadStatus.create({
     *   data: {
     *     // ... data to create a HelpReadStatus
     *   }
     * })
     * 
     */
    create<T extends HelpReadStatusCreateArgs>(args: SelectSubset<T, HelpReadStatusCreateArgs<ExtArgs>>): Prisma__HelpReadStatusClient<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpReadStatuses.
     * @param {HelpReadStatusCreateManyArgs} args - Arguments to create many HelpReadStatuses.
     * @example
     * // Create many HelpReadStatuses
     * const helpReadStatus = await prisma.helpReadStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpReadStatusCreateManyArgs>(args?: SelectSubset<T, HelpReadStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpReadStatuses and returns the data saved in the database.
     * @param {HelpReadStatusCreateManyAndReturnArgs} args - Arguments to create many HelpReadStatuses.
     * @example
     * // Create many HelpReadStatuses
     * const helpReadStatus = await prisma.helpReadStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpReadStatuses and only return the `id`
     * const helpReadStatusWithIdOnly = await prisma.helpReadStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpReadStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpReadStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HelpReadStatus.
     * @param {HelpReadStatusDeleteArgs} args - Arguments to delete one HelpReadStatus.
     * @example
     * // Delete one HelpReadStatus
     * const HelpReadStatus = await prisma.helpReadStatus.delete({
     *   where: {
     *     // ... filter to delete one HelpReadStatus
     *   }
     * })
     * 
     */
    delete<T extends HelpReadStatusDeleteArgs>(args: SelectSubset<T, HelpReadStatusDeleteArgs<ExtArgs>>): Prisma__HelpReadStatusClient<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpReadStatus.
     * @param {HelpReadStatusUpdateArgs} args - Arguments to update one HelpReadStatus.
     * @example
     * // Update one HelpReadStatus
     * const helpReadStatus = await prisma.helpReadStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpReadStatusUpdateArgs>(args: SelectSubset<T, HelpReadStatusUpdateArgs<ExtArgs>>): Prisma__HelpReadStatusClient<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpReadStatuses.
     * @param {HelpReadStatusDeleteManyArgs} args - Arguments to filter HelpReadStatuses to delete.
     * @example
     * // Delete a few HelpReadStatuses
     * const { count } = await prisma.helpReadStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpReadStatusDeleteManyArgs>(args?: SelectSubset<T, HelpReadStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpReadStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpReadStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpReadStatuses
     * const helpReadStatus = await prisma.helpReadStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpReadStatusUpdateManyArgs>(args: SelectSubset<T, HelpReadStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpReadStatus.
     * @param {HelpReadStatusUpsertArgs} args - Arguments to update or create a HelpReadStatus.
     * @example
     * // Update or create a HelpReadStatus
     * const helpReadStatus = await prisma.helpReadStatus.upsert({
     *   create: {
     *     // ... data to create a HelpReadStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpReadStatus we want to update
     *   }
     * })
     */
    upsert<T extends HelpReadStatusUpsertArgs>(args: SelectSubset<T, HelpReadStatusUpsertArgs<ExtArgs>>): Prisma__HelpReadStatusClient<$Result.GetResult<Prisma.$HelpReadStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpReadStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpReadStatusCountArgs} args - Arguments to filter HelpReadStatuses to count.
     * @example
     * // Count the number of HelpReadStatuses
     * const count = await prisma.helpReadStatus.count({
     *   where: {
     *     // ... the filter for the HelpReadStatuses we want to count
     *   }
     * })
    **/
    count<T extends HelpReadStatusCountArgs>(
      args?: Subset<T, HelpReadStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpReadStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpReadStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpReadStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpReadStatusAggregateArgs>(args: Subset<T, HelpReadStatusAggregateArgs>): Prisma.PrismaPromise<GetHelpReadStatusAggregateType<T>>

    /**
     * Group by HelpReadStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpReadStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpReadStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpReadStatusGroupByArgs['orderBy'] }
        : { orderBy?: HelpReadStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpReadStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpReadStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpReadStatus model
   */
  readonly fields: HelpReadStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpReadStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpReadStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    help<T extends HelpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HelpDefaultArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    helpMessage<T extends HelpReadStatus$helpMessageArgs<ExtArgs> = {}>(args?: Subset<T, HelpReadStatus$helpMessageArgs<ExtArgs>>): Prisma__HelpMessageClient<$Result.GetResult<Prisma.$HelpMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpReadStatus model
   */ 
  interface HelpReadStatusFieldRefs {
    readonly id: FieldRef<"HelpReadStatus", 'String'>
    readonly createdAt: FieldRef<"HelpReadStatus", 'DateTime'>
    readonly helpId: FieldRef<"HelpReadStatus", 'String'>
    readonly userId: FieldRef<"HelpReadStatus", 'String'>
    readonly helpMessageId: FieldRef<"HelpReadStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HelpReadStatus findUnique
   */
  export type HelpReadStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which HelpReadStatus to fetch.
     */
    where: HelpReadStatusWhereUniqueInput
  }

  /**
   * HelpReadStatus findUniqueOrThrow
   */
  export type HelpReadStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which HelpReadStatus to fetch.
     */
    where: HelpReadStatusWhereUniqueInput
  }

  /**
   * HelpReadStatus findFirst
   */
  export type HelpReadStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which HelpReadStatus to fetch.
     */
    where?: HelpReadStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpReadStatuses to fetch.
     */
    orderBy?: HelpReadStatusOrderByWithRelationInput | HelpReadStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpReadStatuses.
     */
    cursor?: HelpReadStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpReadStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpReadStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpReadStatuses.
     */
    distinct?: HelpReadStatusScalarFieldEnum | HelpReadStatusScalarFieldEnum[]
  }

  /**
   * HelpReadStatus findFirstOrThrow
   */
  export type HelpReadStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which HelpReadStatus to fetch.
     */
    where?: HelpReadStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpReadStatuses to fetch.
     */
    orderBy?: HelpReadStatusOrderByWithRelationInput | HelpReadStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpReadStatuses.
     */
    cursor?: HelpReadStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpReadStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpReadStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpReadStatuses.
     */
    distinct?: HelpReadStatusScalarFieldEnum | HelpReadStatusScalarFieldEnum[]
  }

  /**
   * HelpReadStatus findMany
   */
  export type HelpReadStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    /**
     * Filter, which HelpReadStatuses to fetch.
     */
    where?: HelpReadStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpReadStatuses to fetch.
     */
    orderBy?: HelpReadStatusOrderByWithRelationInput | HelpReadStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpReadStatuses.
     */
    cursor?: HelpReadStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpReadStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpReadStatuses.
     */
    skip?: number
    distinct?: HelpReadStatusScalarFieldEnum | HelpReadStatusScalarFieldEnum[]
  }

  /**
   * HelpReadStatus create
   */
  export type HelpReadStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpReadStatus.
     */
    data: XOR<HelpReadStatusCreateInput, HelpReadStatusUncheckedCreateInput>
  }

  /**
   * HelpReadStatus createMany
   */
  export type HelpReadStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpReadStatuses.
     */
    data: HelpReadStatusCreateManyInput | HelpReadStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HelpReadStatus createManyAndReturn
   */
  export type HelpReadStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HelpReadStatuses.
     */
    data: HelpReadStatusCreateManyInput | HelpReadStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpReadStatus update
   */
  export type HelpReadStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpReadStatus.
     */
    data: XOR<HelpReadStatusUpdateInput, HelpReadStatusUncheckedUpdateInput>
    /**
     * Choose, which HelpReadStatus to update.
     */
    where: HelpReadStatusWhereUniqueInput
  }

  /**
   * HelpReadStatus updateMany
   */
  export type HelpReadStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpReadStatuses.
     */
    data: XOR<HelpReadStatusUpdateManyMutationInput, HelpReadStatusUncheckedUpdateManyInput>
    /**
     * Filter which HelpReadStatuses to update
     */
    where?: HelpReadStatusWhereInput
  }

  /**
   * HelpReadStatus upsert
   */
  export type HelpReadStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpReadStatus to update in case it exists.
     */
    where: HelpReadStatusWhereUniqueInput
    /**
     * In case the HelpReadStatus found by the `where` argument doesn't exist, create a new HelpReadStatus with this data.
     */
    create: XOR<HelpReadStatusCreateInput, HelpReadStatusUncheckedCreateInput>
    /**
     * In case the HelpReadStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpReadStatusUpdateInput, HelpReadStatusUncheckedUpdateInput>
  }

  /**
   * HelpReadStatus delete
   */
  export type HelpReadStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
    /**
     * Filter which HelpReadStatus to delete.
     */
    where: HelpReadStatusWhereUniqueInput
  }

  /**
   * HelpReadStatus deleteMany
   */
  export type HelpReadStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpReadStatuses to delete
     */
    where?: HelpReadStatusWhereInput
  }

  /**
   * HelpReadStatus.helpMessage
   */
  export type HelpReadStatus$helpMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpMessage
     */
    select?: HelpMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpMessageInclude<ExtArgs> | null
    where?: HelpMessageWhereInput
  }

  /**
   * HelpReadStatus without action
   */
  export type HelpReadStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpReadStatus
     */
    select?: HelpReadStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpReadStatusInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    type: string | null
    content: string | null
    read: boolean | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    type: string | null
    content: string | null
    read: boolean | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    type: number
    content: number
    read: number
    metadata: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    type?: true
    content?: true
    read?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    type?: true
    content?: true
    read?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    type?: true
    content?: true
    read?: true
    metadata?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    type: string
    content: string
    read: boolean
    metadata: JsonValue | null
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    metadata?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    metadata?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    read?: boolean
    metadata?: boolean
  }

  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      type: string
      content: string
      read: boolean
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */ 
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'String'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
    readonly updatedAt: FieldRef<"notifications", 'DateTime'>
    readonly userId: FieldRef<"notifications", 'String'>
    readonly type: FieldRef<"notifications", 'String'>
    readonly content: FieldRef<"notifications", 'String'>
    readonly read: FieldRef<"notifications", 'Boolean'>
    readonly metadata: FieldRef<"notifications", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model PostViewStatus
   */

  export type AggregatePostViewStatus = {
    _count: PostViewStatusCountAggregateOutputType | null
    _min: PostViewStatusMinAggregateOutputType | null
    _max: PostViewStatusMaxAggregateOutputType | null
  }

  export type PostViewStatusMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    postId: string | null
    lastViewedAt: Date | null
  }

  export type PostViewStatusMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    postId: string | null
    lastViewedAt: Date | null
  }

  export type PostViewStatusCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    postId: number
    lastViewedAt: number
    _all: number
  }


  export type PostViewStatusMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    postId?: true
    lastViewedAt?: true
  }

  export type PostViewStatusMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    postId?: true
    lastViewedAt?: true
  }

  export type PostViewStatusCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    postId?: true
    lastViewedAt?: true
    _all?: true
  }

  export type PostViewStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostViewStatus to aggregate.
     */
    where?: PostViewStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostViewStatuses to fetch.
     */
    orderBy?: PostViewStatusOrderByWithRelationInput | PostViewStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostViewStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostViewStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostViewStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostViewStatuses
    **/
    _count?: true | PostViewStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostViewStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostViewStatusMaxAggregateInputType
  }

  export type GetPostViewStatusAggregateType<T extends PostViewStatusAggregateArgs> = {
        [P in keyof T & keyof AggregatePostViewStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostViewStatus[P]>
      : GetScalarType<T[P], AggregatePostViewStatus[P]>
  }




  export type PostViewStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostViewStatusWhereInput
    orderBy?: PostViewStatusOrderByWithAggregationInput | PostViewStatusOrderByWithAggregationInput[]
    by: PostViewStatusScalarFieldEnum[] | PostViewStatusScalarFieldEnum
    having?: PostViewStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostViewStatusCountAggregateInputType | true
    _min?: PostViewStatusMinAggregateInputType
    _max?: PostViewStatusMaxAggregateInputType
  }

  export type PostViewStatusGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    postId: string
    lastViewedAt: Date
    _count: PostViewStatusCountAggregateOutputType | null
    _min: PostViewStatusMinAggregateOutputType | null
    _max: PostViewStatusMaxAggregateOutputType | null
  }

  type GetPostViewStatusGroupByPayload<T extends PostViewStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostViewStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostViewStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostViewStatusGroupByOutputType[P]>
            : GetScalarType<T[P], PostViewStatusGroupByOutputType[P]>
        }
      >
    >


  export type PostViewStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    postId?: boolean
    lastViewedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postViewStatus"]>

  export type PostViewStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    postId?: boolean
    lastViewedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postViewStatus"]>

  export type PostViewStatusSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    postId?: boolean
    lastViewedAt?: boolean
  }

  export type PostViewStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostViewStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostViewStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostViewStatus"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      postId: string
      lastViewedAt: Date
    }, ExtArgs["result"]["postViewStatus"]>
    composites: {}
  }

  type PostViewStatusGetPayload<S extends boolean | null | undefined | PostViewStatusDefaultArgs> = $Result.GetResult<Prisma.$PostViewStatusPayload, S>

  type PostViewStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostViewStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostViewStatusCountAggregateInputType | true
    }

  export interface PostViewStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostViewStatus'], meta: { name: 'PostViewStatus' } }
    /**
     * Find zero or one PostViewStatus that matches the filter.
     * @param {PostViewStatusFindUniqueArgs} args - Arguments to find a PostViewStatus
     * @example
     * // Get one PostViewStatus
     * const postViewStatus = await prisma.postViewStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostViewStatusFindUniqueArgs>(args: SelectSubset<T, PostViewStatusFindUniqueArgs<ExtArgs>>): Prisma__PostViewStatusClient<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostViewStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostViewStatusFindUniqueOrThrowArgs} args - Arguments to find a PostViewStatus
     * @example
     * // Get one PostViewStatus
     * const postViewStatus = await prisma.postViewStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostViewStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, PostViewStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostViewStatusClient<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostViewStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewStatusFindFirstArgs} args - Arguments to find a PostViewStatus
     * @example
     * // Get one PostViewStatus
     * const postViewStatus = await prisma.postViewStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostViewStatusFindFirstArgs>(args?: SelectSubset<T, PostViewStatusFindFirstArgs<ExtArgs>>): Prisma__PostViewStatusClient<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostViewStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewStatusFindFirstOrThrowArgs} args - Arguments to find a PostViewStatus
     * @example
     * // Get one PostViewStatus
     * const postViewStatus = await prisma.postViewStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostViewStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, PostViewStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostViewStatusClient<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostViewStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostViewStatuses
     * const postViewStatuses = await prisma.postViewStatus.findMany()
     * 
     * // Get first 10 PostViewStatuses
     * const postViewStatuses = await prisma.postViewStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postViewStatusWithIdOnly = await prisma.postViewStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostViewStatusFindManyArgs>(args?: SelectSubset<T, PostViewStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostViewStatus.
     * @param {PostViewStatusCreateArgs} args - Arguments to create a PostViewStatus.
     * @example
     * // Create one PostViewStatus
     * const PostViewStatus = await prisma.postViewStatus.create({
     *   data: {
     *     // ... data to create a PostViewStatus
     *   }
     * })
     * 
     */
    create<T extends PostViewStatusCreateArgs>(args: SelectSubset<T, PostViewStatusCreateArgs<ExtArgs>>): Prisma__PostViewStatusClient<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostViewStatuses.
     * @param {PostViewStatusCreateManyArgs} args - Arguments to create many PostViewStatuses.
     * @example
     * // Create many PostViewStatuses
     * const postViewStatus = await prisma.postViewStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostViewStatusCreateManyArgs>(args?: SelectSubset<T, PostViewStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostViewStatuses and returns the data saved in the database.
     * @param {PostViewStatusCreateManyAndReturnArgs} args - Arguments to create many PostViewStatuses.
     * @example
     * // Create many PostViewStatuses
     * const postViewStatus = await prisma.postViewStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostViewStatuses and only return the `id`
     * const postViewStatusWithIdOnly = await prisma.postViewStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostViewStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, PostViewStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostViewStatus.
     * @param {PostViewStatusDeleteArgs} args - Arguments to delete one PostViewStatus.
     * @example
     * // Delete one PostViewStatus
     * const PostViewStatus = await prisma.postViewStatus.delete({
     *   where: {
     *     // ... filter to delete one PostViewStatus
     *   }
     * })
     * 
     */
    delete<T extends PostViewStatusDeleteArgs>(args: SelectSubset<T, PostViewStatusDeleteArgs<ExtArgs>>): Prisma__PostViewStatusClient<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostViewStatus.
     * @param {PostViewStatusUpdateArgs} args - Arguments to update one PostViewStatus.
     * @example
     * // Update one PostViewStatus
     * const postViewStatus = await prisma.postViewStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostViewStatusUpdateArgs>(args: SelectSubset<T, PostViewStatusUpdateArgs<ExtArgs>>): Prisma__PostViewStatusClient<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostViewStatuses.
     * @param {PostViewStatusDeleteManyArgs} args - Arguments to filter PostViewStatuses to delete.
     * @example
     * // Delete a few PostViewStatuses
     * const { count } = await prisma.postViewStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostViewStatusDeleteManyArgs>(args?: SelectSubset<T, PostViewStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostViewStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostViewStatuses
     * const postViewStatus = await prisma.postViewStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostViewStatusUpdateManyArgs>(args: SelectSubset<T, PostViewStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostViewStatus.
     * @param {PostViewStatusUpsertArgs} args - Arguments to update or create a PostViewStatus.
     * @example
     * // Update or create a PostViewStatus
     * const postViewStatus = await prisma.postViewStatus.upsert({
     *   create: {
     *     // ... data to create a PostViewStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostViewStatus we want to update
     *   }
     * })
     */
    upsert<T extends PostViewStatusUpsertArgs>(args: SelectSubset<T, PostViewStatusUpsertArgs<ExtArgs>>): Prisma__PostViewStatusClient<$Result.GetResult<Prisma.$PostViewStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostViewStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewStatusCountArgs} args - Arguments to filter PostViewStatuses to count.
     * @example
     * // Count the number of PostViewStatuses
     * const count = await prisma.postViewStatus.count({
     *   where: {
     *     // ... the filter for the PostViewStatuses we want to count
     *   }
     * })
    **/
    count<T extends PostViewStatusCountArgs>(
      args?: Subset<T, PostViewStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostViewStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostViewStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostViewStatusAggregateArgs>(args: Subset<T, PostViewStatusAggregateArgs>): Prisma.PrismaPromise<GetPostViewStatusAggregateType<T>>

    /**
     * Group by PostViewStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostViewStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostViewStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostViewStatusGroupByArgs['orderBy'] }
        : { orderBy?: PostViewStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostViewStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostViewStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostViewStatus model
   */
  readonly fields: PostViewStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostViewStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostViewStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostViewStatus model
   */ 
  interface PostViewStatusFieldRefs {
    readonly id: FieldRef<"PostViewStatus", 'String'>
    readonly createdAt: FieldRef<"PostViewStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"PostViewStatus", 'DateTime'>
    readonly userId: FieldRef<"PostViewStatus", 'String'>
    readonly postId: FieldRef<"PostViewStatus", 'String'>
    readonly lastViewedAt: FieldRef<"PostViewStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostViewStatus findUnique
   */
  export type PostViewStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    /**
     * Filter, which PostViewStatus to fetch.
     */
    where: PostViewStatusWhereUniqueInput
  }

  /**
   * PostViewStatus findUniqueOrThrow
   */
  export type PostViewStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    /**
     * Filter, which PostViewStatus to fetch.
     */
    where: PostViewStatusWhereUniqueInput
  }

  /**
   * PostViewStatus findFirst
   */
  export type PostViewStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    /**
     * Filter, which PostViewStatus to fetch.
     */
    where?: PostViewStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostViewStatuses to fetch.
     */
    orderBy?: PostViewStatusOrderByWithRelationInput | PostViewStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostViewStatuses.
     */
    cursor?: PostViewStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostViewStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostViewStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostViewStatuses.
     */
    distinct?: PostViewStatusScalarFieldEnum | PostViewStatusScalarFieldEnum[]
  }

  /**
   * PostViewStatus findFirstOrThrow
   */
  export type PostViewStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    /**
     * Filter, which PostViewStatus to fetch.
     */
    where?: PostViewStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostViewStatuses to fetch.
     */
    orderBy?: PostViewStatusOrderByWithRelationInput | PostViewStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostViewStatuses.
     */
    cursor?: PostViewStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostViewStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostViewStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostViewStatuses.
     */
    distinct?: PostViewStatusScalarFieldEnum | PostViewStatusScalarFieldEnum[]
  }

  /**
   * PostViewStatus findMany
   */
  export type PostViewStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    /**
     * Filter, which PostViewStatuses to fetch.
     */
    where?: PostViewStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostViewStatuses to fetch.
     */
    orderBy?: PostViewStatusOrderByWithRelationInput | PostViewStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostViewStatuses.
     */
    cursor?: PostViewStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostViewStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostViewStatuses.
     */
    skip?: number
    distinct?: PostViewStatusScalarFieldEnum | PostViewStatusScalarFieldEnum[]
  }

  /**
   * PostViewStatus create
   */
  export type PostViewStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a PostViewStatus.
     */
    data: XOR<PostViewStatusCreateInput, PostViewStatusUncheckedCreateInput>
  }

  /**
   * PostViewStatus createMany
   */
  export type PostViewStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostViewStatuses.
     */
    data: PostViewStatusCreateManyInput | PostViewStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostViewStatus createManyAndReturn
   */
  export type PostViewStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostViewStatuses.
     */
    data: PostViewStatusCreateManyInput | PostViewStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostViewStatus update
   */
  export type PostViewStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a PostViewStatus.
     */
    data: XOR<PostViewStatusUpdateInput, PostViewStatusUncheckedUpdateInput>
    /**
     * Choose, which PostViewStatus to update.
     */
    where: PostViewStatusWhereUniqueInput
  }

  /**
   * PostViewStatus updateMany
   */
  export type PostViewStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostViewStatuses.
     */
    data: XOR<PostViewStatusUpdateManyMutationInput, PostViewStatusUncheckedUpdateManyInput>
    /**
     * Filter which PostViewStatuses to update
     */
    where?: PostViewStatusWhereInput
  }

  /**
   * PostViewStatus upsert
   */
  export type PostViewStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the PostViewStatus to update in case it exists.
     */
    where: PostViewStatusWhereUniqueInput
    /**
     * In case the PostViewStatus found by the `where` argument doesn't exist, create a new PostViewStatus with this data.
     */
    create: XOR<PostViewStatusCreateInput, PostViewStatusUncheckedCreateInput>
    /**
     * In case the PostViewStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostViewStatusUpdateInput, PostViewStatusUncheckedUpdateInput>
  }

  /**
   * PostViewStatus delete
   */
  export type PostViewStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
    /**
     * Filter which PostViewStatus to delete.
     */
    where: PostViewStatusWhereUniqueInput
  }

  /**
   * PostViewStatus deleteMany
   */
  export type PostViewStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostViewStatuses to delete
     */
    where?: PostViewStatusWhereInput
  }

  /**
   * PostViewStatus without action
   */
  export type PostViewStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostViewStatus
     */
    select?: PostViewStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostViewStatusInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    username: 'username',
    phone: 'phone',
    password: 'password',
    userType: 'userType',
    local: 'local',
    firstName: 'firstName',
    lastName: 'lastName',
    profilePicture: 'profilePicture',
    address: 'address',
    city: 'city',
    state: 'state',
    zip: 'zip',
    country: 'country',
    schoolName: 'schoolName',
    className: 'className',
    teacherName: 'teacherName',
    isVerified: 'isVerified',
    isBlocked: 'isBlocked',
    isOnline: 'isOnline',
    isDeleted: 'isDeleted',
    isHelping: 'isHelping',
    Aliyun_token: 'Aliyun_token',
    device_type: 'device_type'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserDeviceTokenScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    token: 'token',
    device_type: 'device_type'
  };

  export type UserDeviceTokenScalarFieldEnum = (typeof UserDeviceTokenScalarFieldEnum)[keyof typeof UserDeviceTokenScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    token: 'token'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const UserMoodScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    mood: 'mood',
    note: 'note'
  };

  export type UserMoodScalarFieldEnum = (typeof UserMoodScalarFieldEnum)[keyof typeof UserMoodScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    user1Id: 'user1Id',
    user2Id: 'user2Id'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const ChatroomScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    lastMessage: 'lastMessage'
  };

  export type ChatroomScalarFieldEnum = (typeof ChatroomScalarFieldEnum)[keyof typeof ChatroomScalarFieldEnum]


  export const ChatroomMessageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    chatroomId: 'chatroomId',
    senderId: 'senderId',
    message: 'message',
    status: 'status',
    type: 'type',
    file: 'file',
    reply_id: 'reply_id',
    call_message_status: 'call_message_status',
    isDeleted: 'isDeleted',
    payload: 'payload'
  };

  export type ChatroomMessageScalarFieldEnum = (typeof ChatroomMessageScalarFieldEnum)[keyof typeof ChatroomMessageScalarFieldEnum]


  export const ChatroomReadStatusScalarFieldEnum: {
    id: 'id',
    chatroomId: 'chatroomId',
    userId: 'userId',
    messageId: 'messageId',
    createdAt: 'createdAt'
  };

  export type ChatroomReadStatusScalarFieldEnum = (typeof ChatroomReadStatusScalarFieldEnum)[keyof typeof ChatroomReadStatusScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    is_anonymous: 'is_anonymous',
    text: 'text',
    mood: 'mood',
    userId: 'userId',
    total_likes: 'total_likes',
    total_comments: 'total_comments'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const MediaAttachmentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    url: 'url',
    postId: 'postId'
  };

  export type MediaAttachmentScalarFieldEnum = (typeof MediaAttachmentScalarFieldEnum)[keyof typeof MediaAttachmentScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    text: 'text',
    postId: 'postId',
    userId: 'userId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    postId: 'postId',
    userId: 'userId'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const HelpScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt',
    requestedById: 'requestedById',
    helperId: 'helperId',
    status: 'status',
    locationLat: 'locationLat',
    locationLng: 'locationLng',
    address: 'address',
    isDeleted: 'isDeleted'
  };

  export type HelpScalarFieldEnum = (typeof HelpScalarFieldEnum)[keyof typeof HelpScalarFieldEnum]


  export const HelpMessageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    helpId: 'helpId',
    senderId: 'senderId',
    message: 'message',
    status: 'status',
    type: 'type',
    file: 'file',
    locationLat: 'locationLat',
    locationLng: 'locationLng',
    isDeleted: 'isDeleted',
    reply_id: 'reply_id'
  };

  export type HelpMessageScalarFieldEnum = (typeof HelpMessageScalarFieldEnum)[keyof typeof HelpMessageScalarFieldEnum]


  export const HelpReadStatusScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    helpId: 'helpId',
    userId: 'userId',
    helpMessageId: 'helpMessageId'
  };

  export type HelpReadStatusScalarFieldEnum = (typeof HelpReadStatusScalarFieldEnum)[keyof typeof HelpReadStatusScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    type: 'type',
    content: 'content',
    read: 'read',
    metadata: 'metadata'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const PostViewStatusScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    postId: 'postId',
    lastViewedAt: 'lastViewedAt'
  };

  export type PostViewStatusScalarFieldEnum = (typeof PostViewStatusScalarFieldEnum)[keyof typeof PostViewStatusScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserMoodType'
   */
  export type EnumUserMoodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserMoodType'>
    


  /**
   * Reference to a field of type 'UserMoodType[]'
   */
  export type ListEnumUserMoodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserMoodType[]'>
    


  /**
   * Reference to a field of type 'FriendshipStatus'
   */
  export type EnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus'>
    


  /**
   * Reference to a field of type 'FriendshipStatus[]'
   */
  export type ListEnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus[]'>
    


  /**
   * Reference to a field of type 'ChatroomMessageStatus'
   */
  export type EnumChatroomMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatroomMessageStatus'>
    


  /**
   * Reference to a field of type 'ChatroomMessageStatus[]'
   */
  export type ListEnumChatroomMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatroomMessageStatus[]'>
    


  /**
   * Reference to a field of type 'ChatroomMessageType'
   */
  export type EnumChatroomMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatroomMessageType'>
    


  /**
   * Reference to a field of type 'ChatroomMessageType[]'
   */
  export type ListEnumChatroomMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatroomMessageType[]'>
    


  /**
   * Reference to a field of type 'CallMessageStatus'
   */
  export type EnumCallMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallMessageStatus'>
    


  /**
   * Reference to a field of type 'CallMessageStatus[]'
   */
  export type ListEnumCallMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallMessageStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'HelpStatus'
   */
  export type EnumHelpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HelpStatus'>
    


  /**
   * Reference to a field of type 'HelpStatus[]'
   */
  export type ListEnumHelpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HelpStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    local?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profilePicture?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    schoolName?: StringNullableFilter<"User"> | string | null
    className?: StringNullableFilter<"User"> | string | null
    teacherName?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isBlocked?: BoolFilter<"User"> | boolean
    isOnline?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    isHelping?: BoolFilter<"User"> | boolean
    Aliyun_token?: StringNullableFilter<"User"> | string | null
    device_type?: StringNullableFilter<"User"> | string | null
    comments?: CommentListRelationFilter
    helpReadStatus?: HelpReadStatusListRelationFilter
    likes?: LikeListRelationFilter
    posts?: PostListRelationFilter
    chatroomMessage?: ChatroomMessageListRelationFilter
    friends1?: FriendshipListRelationFilter
    friends2?: FriendshipListRelationFilter
    help_messages?: HelpMessageListRelationFilter
    helper?: HelpListRelationFilter
    requestedHelp?: HelpListRelationFilter
    notifications?: NotificationsListRelationFilter
    postViews?: PostViewStatusListRelationFilter
    deviceTokens?: UserDeviceTokenListRelationFilter
    moods?: UserMoodListRelationFilter
    sessions?: UserSessionListRelationFilter
    chatrooms?: ChatroomListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    local?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    schoolName?: SortOrderInput | SortOrder
    className?: SortOrderInput | SortOrder
    teacherName?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isBlocked?: SortOrder
    isOnline?: SortOrder
    isDeleted?: SortOrder
    isHelping?: SortOrder
    Aliyun_token?: SortOrderInput | SortOrder
    device_type?: SortOrderInput | SortOrder
    comments?: CommentOrderByRelationAggregateInput
    helpReadStatus?: HelpReadStatusOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    chatroomMessage?: ChatroomMessageOrderByRelationAggregateInput
    friends1?: FriendshipOrderByRelationAggregateInput
    friends2?: FriendshipOrderByRelationAggregateInput
    help_messages?: HelpMessageOrderByRelationAggregateInput
    helper?: HelpOrderByRelationAggregateInput
    requestedHelp?: HelpOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    postViews?: PostViewStatusOrderByRelationAggregateInput
    deviceTokens?: UserDeviceTokenOrderByRelationAggregateInput
    moods?: UserMoodOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
    chatrooms?: ChatroomOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    local?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profilePicture?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    schoolName?: StringNullableFilter<"User"> | string | null
    className?: StringNullableFilter<"User"> | string | null
    teacherName?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isBlocked?: BoolFilter<"User"> | boolean
    isOnline?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    isHelping?: BoolFilter<"User"> | boolean
    Aliyun_token?: StringNullableFilter<"User"> | string | null
    device_type?: StringNullableFilter<"User"> | string | null
    comments?: CommentListRelationFilter
    helpReadStatus?: HelpReadStatusListRelationFilter
    likes?: LikeListRelationFilter
    posts?: PostListRelationFilter
    chatroomMessage?: ChatroomMessageListRelationFilter
    friends1?: FriendshipListRelationFilter
    friends2?: FriendshipListRelationFilter
    help_messages?: HelpMessageListRelationFilter
    helper?: HelpListRelationFilter
    requestedHelp?: HelpListRelationFilter
    notifications?: NotificationsListRelationFilter
    postViews?: PostViewStatusListRelationFilter
    deviceTokens?: UserDeviceTokenListRelationFilter
    moods?: UserMoodListRelationFilter
    sessions?: UserSessionListRelationFilter
    chatrooms?: ChatroomListRelationFilter
  }, "id" | "email" | "username" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    local?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    schoolName?: SortOrderInput | SortOrder
    className?: SortOrderInput | SortOrder
    teacherName?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isBlocked?: SortOrder
    isOnline?: SortOrder
    isDeleted?: SortOrder
    isHelping?: SortOrder
    Aliyun_token?: SortOrderInput | SortOrder
    device_type?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    userType?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    local?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    zip?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    schoolName?: StringNullableWithAggregatesFilter<"User"> | string | null
    className?: StringNullableWithAggregatesFilter<"User"> | string | null
    teacherName?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isBlocked?: BoolWithAggregatesFilter<"User"> | boolean
    isOnline?: BoolWithAggregatesFilter<"User"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    isHelping?: BoolWithAggregatesFilter<"User"> | boolean
    Aliyun_token?: StringNullableWithAggregatesFilter<"User"> | string | null
    device_type?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserDeviceTokenWhereInput = {
    AND?: UserDeviceTokenWhereInput | UserDeviceTokenWhereInput[]
    OR?: UserDeviceTokenWhereInput[]
    NOT?: UserDeviceTokenWhereInput | UserDeviceTokenWhereInput[]
    id?: StringFilter<"UserDeviceToken"> | string
    createdAt?: DateTimeFilter<"UserDeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"UserDeviceToken"> | Date | string
    userId?: StringFilter<"UserDeviceToken"> | string
    token?: StringFilter<"UserDeviceToken"> | string
    device_type?: StringFilter<"UserDeviceToken"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserDeviceTokenOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device_type?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserDeviceTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserDeviceTokenWhereInput | UserDeviceTokenWhereInput[]
    OR?: UserDeviceTokenWhereInput[]
    NOT?: UserDeviceTokenWhereInput | UserDeviceTokenWhereInput[]
    createdAt?: DateTimeFilter<"UserDeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"UserDeviceToken"> | Date | string
    userId?: StringFilter<"UserDeviceToken"> | string
    token?: StringFilter<"UserDeviceToken"> | string
    device_type?: StringFilter<"UserDeviceToken"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserDeviceTokenOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device_type?: SortOrder
    _count?: UserDeviceTokenCountOrderByAggregateInput
    _max?: UserDeviceTokenMaxOrderByAggregateInput
    _min?: UserDeviceTokenMinOrderByAggregateInput
  }

  export type UserDeviceTokenScalarWhereWithAggregatesInput = {
    AND?: UserDeviceTokenScalarWhereWithAggregatesInput | UserDeviceTokenScalarWhereWithAggregatesInput[]
    OR?: UserDeviceTokenScalarWhereWithAggregatesInput[]
    NOT?: UserDeviceTokenScalarWhereWithAggregatesInput | UserDeviceTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserDeviceToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserDeviceToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserDeviceToken"> | Date | string
    userId?: StringWithAggregatesFilter<"UserDeviceToken"> | string
    token?: StringWithAggregatesFilter<"UserDeviceToken"> | string
    device_type?: StringWithAggregatesFilter<"UserDeviceToken"> | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    token?: StringWithAggregatesFilter<"UserSession"> | string
  }

  export type UserMoodWhereInput = {
    AND?: UserMoodWhereInput | UserMoodWhereInput[]
    OR?: UserMoodWhereInput[]
    NOT?: UserMoodWhereInput | UserMoodWhereInput[]
    id?: StringFilter<"UserMood"> | string
    createdAt?: DateTimeFilter<"UserMood"> | Date | string
    updatedAt?: DateTimeFilter<"UserMood"> | Date | string
    userId?: StringFilter<"UserMood"> | string
    mood?: EnumUserMoodTypeFilter<"UserMood"> | $Enums.UserMoodType
    note?: StringNullableFilter<"UserMood"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserMoodOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    note?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserMoodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserMoodWhereInput | UserMoodWhereInput[]
    OR?: UserMoodWhereInput[]
    NOT?: UserMoodWhereInput | UserMoodWhereInput[]
    createdAt?: DateTimeFilter<"UserMood"> | Date | string
    updatedAt?: DateTimeFilter<"UserMood"> | Date | string
    userId?: StringFilter<"UserMood"> | string
    mood?: EnumUserMoodTypeFilter<"UserMood"> | $Enums.UserMoodType
    note?: StringNullableFilter<"UserMood"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserMoodOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: UserMoodCountOrderByAggregateInput
    _max?: UserMoodMaxOrderByAggregateInput
    _min?: UserMoodMinOrderByAggregateInput
  }

  export type UserMoodScalarWhereWithAggregatesInput = {
    AND?: UserMoodScalarWhereWithAggregatesInput | UserMoodScalarWhereWithAggregatesInput[]
    OR?: UserMoodScalarWhereWithAggregatesInput[]
    NOT?: UserMoodScalarWhereWithAggregatesInput | UserMoodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserMood"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserMood"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserMood"> | Date | string
    userId?: StringWithAggregatesFilter<"UserMood"> | string
    mood?: EnumUserMoodTypeWithAggregatesFilter<"UserMood"> | $Enums.UserMoodType
    note?: StringNullableWithAggregatesFilter<"UserMood"> | string | null
  }

  export type FriendshipWhereInput = {
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    id?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeFilter<"Friendship"> | Date | string
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    user1Id?: StringFilter<"Friendship"> | string
    user2Id?: StringFilter<"Friendship"> | string
    user1?: XOR<UserRelationFilter, UserWhereInput>
    user2?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    user1?: UserOrderByWithRelationInput
    user2?: UserOrderByWithRelationInput
  }

  export type FriendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeFilter<"Friendship"> | Date | string
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    user1Id?: StringFilter<"Friendship"> | string
    user2Id?: StringFilter<"Friendship"> | string
    user1?: XOR<UserRelationFilter, UserWhereInput>
    user2?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    OR?: FriendshipScalarWhereWithAggregatesInput[]
    NOT?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Friendship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
    status?: EnumFriendshipStatusWithAggregatesFilter<"Friendship"> | $Enums.FriendshipStatus
    user1Id?: StringWithAggregatesFilter<"Friendship"> | string
    user2Id?: StringWithAggregatesFilter<"Friendship"> | string
  }

  export type ChatroomWhereInput = {
    AND?: ChatroomWhereInput | ChatroomWhereInput[]
    OR?: ChatroomWhereInput[]
    NOT?: ChatroomWhereInput | ChatroomWhereInput[]
    id?: StringFilter<"Chatroom"> | string
    createdAt?: DateTimeFilter<"Chatroom"> | Date | string
    updatedAt?: DateTimeFilter<"Chatroom"> | Date | string
    name?: StringNullableFilter<"Chatroom"> | string | null
    lastMessage?: StringNullableFilter<"Chatroom"> | string | null
    readStatuses?: ChatroomReadStatusListRelationFilter
    messages?: ChatroomMessageListRelationFilter
    members?: UserListRelationFilter
  }

  export type ChatroomOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    lastMessage?: SortOrderInput | SortOrder
    readStatuses?: ChatroomReadStatusOrderByRelationAggregateInput
    messages?: ChatroomMessageOrderByRelationAggregateInput
    members?: UserOrderByRelationAggregateInput
  }

  export type ChatroomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatroomWhereInput | ChatroomWhereInput[]
    OR?: ChatroomWhereInput[]
    NOT?: ChatroomWhereInput | ChatroomWhereInput[]
    createdAt?: DateTimeFilter<"Chatroom"> | Date | string
    updatedAt?: DateTimeFilter<"Chatroom"> | Date | string
    name?: StringNullableFilter<"Chatroom"> | string | null
    lastMessage?: StringNullableFilter<"Chatroom"> | string | null
    readStatuses?: ChatroomReadStatusListRelationFilter
    messages?: ChatroomMessageListRelationFilter
    members?: UserListRelationFilter
  }, "id">

  export type ChatroomOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    lastMessage?: SortOrderInput | SortOrder
    _count?: ChatroomCountOrderByAggregateInput
    _max?: ChatroomMaxOrderByAggregateInput
    _min?: ChatroomMinOrderByAggregateInput
  }

  export type ChatroomScalarWhereWithAggregatesInput = {
    AND?: ChatroomScalarWhereWithAggregatesInput | ChatroomScalarWhereWithAggregatesInput[]
    OR?: ChatroomScalarWhereWithAggregatesInput[]
    NOT?: ChatroomScalarWhereWithAggregatesInput | ChatroomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chatroom"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chatroom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chatroom"> | Date | string
    name?: StringNullableWithAggregatesFilter<"Chatroom"> | string | null
    lastMessage?: StringNullableWithAggregatesFilter<"Chatroom"> | string | null
  }

  export type ChatroomMessageWhereInput = {
    AND?: ChatroomMessageWhereInput | ChatroomMessageWhereInput[]
    OR?: ChatroomMessageWhereInput[]
    NOT?: ChatroomMessageWhereInput | ChatroomMessageWhereInput[]
    id?: StringFilter<"ChatroomMessage"> | string
    createdAt?: DateTimeFilter<"ChatroomMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatroomMessage"> | Date | string
    chatroomId?: StringFilter<"ChatroomMessage"> | string
    senderId?: StringFilter<"ChatroomMessage"> | string
    message?: StringFilter<"ChatroomMessage"> | string
    status?: EnumChatroomMessageStatusFilter<"ChatroomMessage"> | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFilter<"ChatroomMessage"> | $Enums.ChatroomMessageType
    file?: StringNullableFilter<"ChatroomMessage"> | string | null
    reply_id?: StringNullableFilter<"ChatroomMessage"> | string | null
    call_message_status?: EnumCallMessageStatusNullableFilter<"ChatroomMessage"> | $Enums.CallMessageStatus | null
    isDeleted?: BoolFilter<"ChatroomMessage"> | boolean
    payload?: StringNullableFilter<"ChatroomMessage"> | string | null
    readBy?: ChatroomReadStatusListRelationFilter
    chatroom?: XOR<ChatroomRelationFilter, ChatroomWhereInput>
    reply?: XOR<ChatroomMessageNullableRelationFilter, ChatroomMessageWhereInput> | null
    chat_message?: ChatroomMessageListRelationFilter
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChatroomMessageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatroomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrderInput | SortOrder
    reply_id?: SortOrderInput | SortOrder
    call_message_status?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    payload?: SortOrderInput | SortOrder
    readBy?: ChatroomReadStatusOrderByRelationAggregateInput
    chatroom?: ChatroomOrderByWithRelationInput
    reply?: ChatroomMessageOrderByWithRelationInput
    chat_message?: ChatroomMessageOrderByRelationAggregateInput
    sender?: UserOrderByWithRelationInput
  }

  export type ChatroomMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatroomMessageWhereInput | ChatroomMessageWhereInput[]
    OR?: ChatroomMessageWhereInput[]
    NOT?: ChatroomMessageWhereInput | ChatroomMessageWhereInput[]
    createdAt?: DateTimeFilter<"ChatroomMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatroomMessage"> | Date | string
    chatroomId?: StringFilter<"ChatroomMessage"> | string
    senderId?: StringFilter<"ChatroomMessage"> | string
    message?: StringFilter<"ChatroomMessage"> | string
    status?: EnumChatroomMessageStatusFilter<"ChatroomMessage"> | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFilter<"ChatroomMessage"> | $Enums.ChatroomMessageType
    file?: StringNullableFilter<"ChatroomMessage"> | string | null
    reply_id?: StringNullableFilter<"ChatroomMessage"> | string | null
    call_message_status?: EnumCallMessageStatusNullableFilter<"ChatroomMessage"> | $Enums.CallMessageStatus | null
    isDeleted?: BoolFilter<"ChatroomMessage"> | boolean
    payload?: StringNullableFilter<"ChatroomMessage"> | string | null
    readBy?: ChatroomReadStatusListRelationFilter
    chatroom?: XOR<ChatroomRelationFilter, ChatroomWhereInput>
    reply?: XOR<ChatroomMessageNullableRelationFilter, ChatroomMessageWhereInput> | null
    chat_message?: ChatroomMessageListRelationFilter
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChatroomMessageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatroomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrderInput | SortOrder
    reply_id?: SortOrderInput | SortOrder
    call_message_status?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    payload?: SortOrderInput | SortOrder
    _count?: ChatroomMessageCountOrderByAggregateInput
    _max?: ChatroomMessageMaxOrderByAggregateInput
    _min?: ChatroomMessageMinOrderByAggregateInput
  }

  export type ChatroomMessageScalarWhereWithAggregatesInput = {
    AND?: ChatroomMessageScalarWhereWithAggregatesInput | ChatroomMessageScalarWhereWithAggregatesInput[]
    OR?: ChatroomMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatroomMessageScalarWhereWithAggregatesInput | ChatroomMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatroomMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatroomMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatroomMessage"> | Date | string
    chatroomId?: StringWithAggregatesFilter<"ChatroomMessage"> | string
    senderId?: StringWithAggregatesFilter<"ChatroomMessage"> | string
    message?: StringWithAggregatesFilter<"ChatroomMessage"> | string
    status?: EnumChatroomMessageStatusWithAggregatesFilter<"ChatroomMessage"> | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeWithAggregatesFilter<"ChatroomMessage"> | $Enums.ChatroomMessageType
    file?: StringNullableWithAggregatesFilter<"ChatroomMessage"> | string | null
    reply_id?: StringNullableWithAggregatesFilter<"ChatroomMessage"> | string | null
    call_message_status?: EnumCallMessageStatusNullableWithAggregatesFilter<"ChatroomMessage"> | $Enums.CallMessageStatus | null
    isDeleted?: BoolWithAggregatesFilter<"ChatroomMessage"> | boolean
    payload?: StringNullableWithAggregatesFilter<"ChatroomMessage"> | string | null
  }

  export type ChatroomReadStatusWhereInput = {
    AND?: ChatroomReadStatusWhereInput | ChatroomReadStatusWhereInput[]
    OR?: ChatroomReadStatusWhereInput[]
    NOT?: ChatroomReadStatusWhereInput | ChatroomReadStatusWhereInput[]
    id?: StringFilter<"ChatroomReadStatus"> | string
    chatroomId?: StringFilter<"ChatroomReadStatus"> | string
    userId?: StringFilter<"ChatroomReadStatus"> | string
    messageId?: StringFilter<"ChatroomReadStatus"> | string
    createdAt?: DateTimeFilter<"ChatroomReadStatus"> | Date | string
    chatroom?: XOR<ChatroomRelationFilter, ChatroomWhereInput>
    message?: XOR<ChatroomMessageRelationFilter, ChatroomMessageWhereInput>
  }

  export type ChatroomReadStatusOrderByWithRelationInput = {
    id?: SortOrder
    chatroomId?: SortOrder
    userId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    chatroom?: ChatroomOrderByWithRelationInput
    message?: ChatroomMessageOrderByWithRelationInput
  }

  export type ChatroomReadStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chatroomId_userId_messageId?: ChatroomReadStatusChatroomIdUserIdMessageIdCompoundUniqueInput
    AND?: ChatroomReadStatusWhereInput | ChatroomReadStatusWhereInput[]
    OR?: ChatroomReadStatusWhereInput[]
    NOT?: ChatroomReadStatusWhereInput | ChatroomReadStatusWhereInput[]
    chatroomId?: StringFilter<"ChatroomReadStatus"> | string
    userId?: StringFilter<"ChatroomReadStatus"> | string
    messageId?: StringFilter<"ChatroomReadStatus"> | string
    createdAt?: DateTimeFilter<"ChatroomReadStatus"> | Date | string
    chatroom?: XOR<ChatroomRelationFilter, ChatroomWhereInput>
    message?: XOR<ChatroomMessageRelationFilter, ChatroomMessageWhereInput>
  }, "id" | "chatroomId_userId_messageId">

  export type ChatroomReadStatusOrderByWithAggregationInput = {
    id?: SortOrder
    chatroomId?: SortOrder
    userId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    _count?: ChatroomReadStatusCountOrderByAggregateInput
    _max?: ChatroomReadStatusMaxOrderByAggregateInput
    _min?: ChatroomReadStatusMinOrderByAggregateInput
  }

  export type ChatroomReadStatusScalarWhereWithAggregatesInput = {
    AND?: ChatroomReadStatusScalarWhereWithAggregatesInput | ChatroomReadStatusScalarWhereWithAggregatesInput[]
    OR?: ChatroomReadStatusScalarWhereWithAggregatesInput[]
    NOT?: ChatroomReadStatusScalarWhereWithAggregatesInput | ChatroomReadStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatroomReadStatus"> | string
    chatroomId?: StringWithAggregatesFilter<"ChatroomReadStatus"> | string
    userId?: StringWithAggregatesFilter<"ChatroomReadStatus"> | string
    messageId?: StringWithAggregatesFilter<"ChatroomReadStatus"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatroomReadStatus"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    is_anonymous?: BoolFilter<"Post"> | boolean
    text?: StringNullableFilter<"Post"> | string | null
    mood?: StringNullableFilter<"Post"> | string | null
    userId?: StringFilter<"Post"> | string
    total_likes?: IntFilter<"Post"> | number
    total_comments?: IntFilter<"Post"> | number
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    mediaAttachments?: MediaAttachmentListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    viewStatus?: PostViewStatusListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_anonymous?: SortOrder
    text?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    userId?: SortOrder
    total_likes?: SortOrder
    total_comments?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    mediaAttachments?: MediaAttachmentOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    viewStatus?: PostViewStatusOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    is_anonymous?: BoolFilter<"Post"> | boolean
    text?: StringNullableFilter<"Post"> | string | null
    mood?: StringNullableFilter<"Post"> | string | null
    userId?: StringFilter<"Post"> | string
    total_likes?: IntFilter<"Post"> | number
    total_comments?: IntFilter<"Post"> | number
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    mediaAttachments?: MediaAttachmentListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    viewStatus?: PostViewStatusListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_anonymous?: SortOrder
    text?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    userId?: SortOrder
    total_likes?: SortOrder
    total_comments?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    is_anonymous?: BoolWithAggregatesFilter<"Post"> | boolean
    text?: StringNullableWithAggregatesFilter<"Post"> | string | null
    mood?: StringNullableWithAggregatesFilter<"Post"> | string | null
    userId?: StringWithAggregatesFilter<"Post"> | string
    total_likes?: IntWithAggregatesFilter<"Post"> | number
    total_comments?: IntWithAggregatesFilter<"Post"> | number
  }

  export type MediaAttachmentWhereInput = {
    AND?: MediaAttachmentWhereInput | MediaAttachmentWhereInput[]
    OR?: MediaAttachmentWhereInput[]
    NOT?: MediaAttachmentWhereInput | MediaAttachmentWhereInput[]
    id?: StringFilter<"MediaAttachment"> | string
    type?: EnumMediaTypeFilter<"MediaAttachment"> | $Enums.MediaType
    url?: StringFilter<"MediaAttachment"> | string
    postId?: StringFilter<"MediaAttachment"> | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type MediaAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    postId?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type MediaAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaAttachmentWhereInput | MediaAttachmentWhereInput[]
    OR?: MediaAttachmentWhereInput[]
    NOT?: MediaAttachmentWhereInput | MediaAttachmentWhereInput[]
    type?: EnumMediaTypeFilter<"MediaAttachment"> | $Enums.MediaType
    url?: StringFilter<"MediaAttachment"> | string
    postId?: StringFilter<"MediaAttachment"> | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }, "id">

  export type MediaAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    postId?: SortOrder
    _count?: MediaAttachmentCountOrderByAggregateInput
    _max?: MediaAttachmentMaxOrderByAggregateInput
    _min?: MediaAttachmentMinOrderByAggregateInput
  }

  export type MediaAttachmentScalarWhereWithAggregatesInput = {
    AND?: MediaAttachmentScalarWhereWithAggregatesInput | MediaAttachmentScalarWhereWithAggregatesInput[]
    OR?: MediaAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MediaAttachmentScalarWhereWithAggregatesInput | MediaAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaAttachment"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"MediaAttachment"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"MediaAttachment"> | string
    postId?: StringWithAggregatesFilter<"MediaAttachment"> | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    text?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    post?: XOR<PostRelationFilter, PostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    text?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    text?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    post?: XOR<PostRelationFilter, PostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    text?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    text?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    updatedAt?: DateTimeFilter<"Like"> | Date | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    post?: XOR<PostRelationFilter, PostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    createdAt?: DateTimeFilter<"Like"> | Date | string
    updatedAt?: DateTimeFilter<"Like"> | Date | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    post?: XOR<PostRelationFilter, PostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
    postId?: StringWithAggregatesFilter<"Like"> | string
    userId?: StringWithAggregatesFilter<"Like"> | string
  }

  export type HelpWhereInput = {
    AND?: HelpWhereInput | HelpWhereInput[]
    OR?: HelpWhereInput[]
    NOT?: HelpWhereInput | HelpWhereInput[]
    id?: StringFilter<"Help"> | string
    createdAt?: DateTimeFilter<"Help"> | Date | string
    updatedAt?: DateTimeFilter<"Help"> | Date | string
    expiresAt?: DateTimeFilter<"Help"> | Date | string
    requestedById?: StringFilter<"Help"> | string
    helperId?: StringNullableFilter<"Help"> | string | null
    status?: EnumHelpStatusFilter<"Help"> | $Enums.HelpStatus
    locationLat?: FloatNullableFilter<"Help"> | number | null
    locationLng?: FloatNullableFilter<"Help"> | number | null
    address?: StringNullableFilter<"Help"> | string | null
    isDeleted?: BoolFilter<"Help"> | boolean
    helpReadStatus?: HelpReadStatusListRelationFilter
    messages?: HelpMessageListRelationFilter
    helper?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    requestedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HelpOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    requestedById?: SortOrder
    helperId?: SortOrderInput | SortOrder
    status?: SortOrder
    locationLat?: SortOrderInput | SortOrder
    locationLng?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    helpReadStatus?: HelpReadStatusOrderByRelationAggregateInput
    messages?: HelpMessageOrderByRelationAggregateInput
    helper?: UserOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
  }

  export type HelpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HelpWhereInput | HelpWhereInput[]
    OR?: HelpWhereInput[]
    NOT?: HelpWhereInput | HelpWhereInput[]
    createdAt?: DateTimeFilter<"Help"> | Date | string
    updatedAt?: DateTimeFilter<"Help"> | Date | string
    expiresAt?: DateTimeFilter<"Help"> | Date | string
    requestedById?: StringFilter<"Help"> | string
    helperId?: StringNullableFilter<"Help"> | string | null
    status?: EnumHelpStatusFilter<"Help"> | $Enums.HelpStatus
    locationLat?: FloatNullableFilter<"Help"> | number | null
    locationLng?: FloatNullableFilter<"Help"> | number | null
    address?: StringNullableFilter<"Help"> | string | null
    isDeleted?: BoolFilter<"Help"> | boolean
    helpReadStatus?: HelpReadStatusListRelationFilter
    messages?: HelpMessageListRelationFilter
    helper?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    requestedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type HelpOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    requestedById?: SortOrder
    helperId?: SortOrderInput | SortOrder
    status?: SortOrder
    locationLat?: SortOrderInput | SortOrder
    locationLng?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: HelpCountOrderByAggregateInput
    _avg?: HelpAvgOrderByAggregateInput
    _max?: HelpMaxOrderByAggregateInput
    _min?: HelpMinOrderByAggregateInput
    _sum?: HelpSumOrderByAggregateInput
  }

  export type HelpScalarWhereWithAggregatesInput = {
    AND?: HelpScalarWhereWithAggregatesInput | HelpScalarWhereWithAggregatesInput[]
    OR?: HelpScalarWhereWithAggregatesInput[]
    NOT?: HelpScalarWhereWithAggregatesInput | HelpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Help"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Help"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Help"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Help"> | Date | string
    requestedById?: StringWithAggregatesFilter<"Help"> | string
    helperId?: StringNullableWithAggregatesFilter<"Help"> | string | null
    status?: EnumHelpStatusWithAggregatesFilter<"Help"> | $Enums.HelpStatus
    locationLat?: FloatNullableWithAggregatesFilter<"Help"> | number | null
    locationLng?: FloatNullableWithAggregatesFilter<"Help"> | number | null
    address?: StringNullableWithAggregatesFilter<"Help"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Help"> | boolean
  }

  export type HelpMessageWhereInput = {
    AND?: HelpMessageWhereInput | HelpMessageWhereInput[]
    OR?: HelpMessageWhereInput[]
    NOT?: HelpMessageWhereInput | HelpMessageWhereInput[]
    id?: StringFilter<"HelpMessage"> | string
    createdAt?: DateTimeFilter<"HelpMessage"> | Date | string
    updatedAt?: DateTimeFilter<"HelpMessage"> | Date | string
    helpId?: StringFilter<"HelpMessage"> | string
    senderId?: StringFilter<"HelpMessage"> | string
    message?: StringNullableFilter<"HelpMessage"> | string | null
    status?: EnumChatroomMessageStatusFilter<"HelpMessage"> | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFilter<"HelpMessage"> | $Enums.ChatroomMessageType
    file?: StringNullableFilter<"HelpMessage"> | string | null
    locationLat?: FloatNullableFilter<"HelpMessage"> | number | null
    locationLng?: FloatNullableFilter<"HelpMessage"> | number | null
    isDeleted?: BoolFilter<"HelpMessage"> | boolean
    reply_id?: StringNullableFilter<"HelpMessage"> | string | null
    readBy?: HelpReadStatusListRelationFilter
    help?: XOR<HelpRelationFilter, HelpWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HelpMessageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    helpId?: SortOrder
    senderId?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrderInput | SortOrder
    locationLat?: SortOrderInput | SortOrder
    locationLng?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    reply_id?: SortOrderInput | SortOrder
    readBy?: HelpReadStatusOrderByRelationAggregateInput
    help?: HelpOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type HelpMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HelpMessageWhereInput | HelpMessageWhereInput[]
    OR?: HelpMessageWhereInput[]
    NOT?: HelpMessageWhereInput | HelpMessageWhereInput[]
    createdAt?: DateTimeFilter<"HelpMessage"> | Date | string
    updatedAt?: DateTimeFilter<"HelpMessage"> | Date | string
    helpId?: StringFilter<"HelpMessage"> | string
    senderId?: StringFilter<"HelpMessage"> | string
    message?: StringNullableFilter<"HelpMessage"> | string | null
    status?: EnumChatroomMessageStatusFilter<"HelpMessage"> | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFilter<"HelpMessage"> | $Enums.ChatroomMessageType
    file?: StringNullableFilter<"HelpMessage"> | string | null
    locationLat?: FloatNullableFilter<"HelpMessage"> | number | null
    locationLng?: FloatNullableFilter<"HelpMessage"> | number | null
    isDeleted?: BoolFilter<"HelpMessage"> | boolean
    reply_id?: StringNullableFilter<"HelpMessage"> | string | null
    readBy?: HelpReadStatusListRelationFilter
    help?: XOR<HelpRelationFilter, HelpWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type HelpMessageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    helpId?: SortOrder
    senderId?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrderInput | SortOrder
    locationLat?: SortOrderInput | SortOrder
    locationLng?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    reply_id?: SortOrderInput | SortOrder
    _count?: HelpMessageCountOrderByAggregateInput
    _avg?: HelpMessageAvgOrderByAggregateInput
    _max?: HelpMessageMaxOrderByAggregateInput
    _min?: HelpMessageMinOrderByAggregateInput
    _sum?: HelpMessageSumOrderByAggregateInput
  }

  export type HelpMessageScalarWhereWithAggregatesInput = {
    AND?: HelpMessageScalarWhereWithAggregatesInput | HelpMessageScalarWhereWithAggregatesInput[]
    OR?: HelpMessageScalarWhereWithAggregatesInput[]
    NOT?: HelpMessageScalarWhereWithAggregatesInput | HelpMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HelpMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HelpMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HelpMessage"> | Date | string
    helpId?: StringWithAggregatesFilter<"HelpMessage"> | string
    senderId?: StringWithAggregatesFilter<"HelpMessage"> | string
    message?: StringNullableWithAggregatesFilter<"HelpMessage"> | string | null
    status?: EnumChatroomMessageStatusWithAggregatesFilter<"HelpMessage"> | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeWithAggregatesFilter<"HelpMessage"> | $Enums.ChatroomMessageType
    file?: StringNullableWithAggregatesFilter<"HelpMessage"> | string | null
    locationLat?: FloatNullableWithAggregatesFilter<"HelpMessage"> | number | null
    locationLng?: FloatNullableWithAggregatesFilter<"HelpMessage"> | number | null
    isDeleted?: BoolWithAggregatesFilter<"HelpMessage"> | boolean
    reply_id?: StringNullableWithAggregatesFilter<"HelpMessage"> | string | null
  }

  export type HelpReadStatusWhereInput = {
    AND?: HelpReadStatusWhereInput | HelpReadStatusWhereInput[]
    OR?: HelpReadStatusWhereInput[]
    NOT?: HelpReadStatusWhereInput | HelpReadStatusWhereInput[]
    id?: StringFilter<"HelpReadStatus"> | string
    createdAt?: DateTimeFilter<"HelpReadStatus"> | Date | string
    helpId?: StringFilter<"HelpReadStatus"> | string
    userId?: StringFilter<"HelpReadStatus"> | string
    helpMessageId?: StringNullableFilter<"HelpReadStatus"> | string | null
    help?: XOR<HelpRelationFilter, HelpWhereInput>
    helpMessage?: XOR<HelpMessageNullableRelationFilter, HelpMessageWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HelpReadStatusOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    helpId?: SortOrder
    userId?: SortOrder
    helpMessageId?: SortOrderInput | SortOrder
    help?: HelpOrderByWithRelationInput
    helpMessage?: HelpMessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type HelpReadStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    helpMessageId_helpId_userId?: HelpReadStatusHelpMessageIdHelpIdUserIdCompoundUniqueInput
    AND?: HelpReadStatusWhereInput | HelpReadStatusWhereInput[]
    OR?: HelpReadStatusWhereInput[]
    NOT?: HelpReadStatusWhereInput | HelpReadStatusWhereInput[]
    createdAt?: DateTimeFilter<"HelpReadStatus"> | Date | string
    helpId?: StringFilter<"HelpReadStatus"> | string
    userId?: StringFilter<"HelpReadStatus"> | string
    helpMessageId?: StringNullableFilter<"HelpReadStatus"> | string | null
    help?: XOR<HelpRelationFilter, HelpWhereInput>
    helpMessage?: XOR<HelpMessageNullableRelationFilter, HelpMessageWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "helpMessageId_helpId_userId">

  export type HelpReadStatusOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    helpId?: SortOrder
    userId?: SortOrder
    helpMessageId?: SortOrderInput | SortOrder
    _count?: HelpReadStatusCountOrderByAggregateInput
    _max?: HelpReadStatusMaxOrderByAggregateInput
    _min?: HelpReadStatusMinOrderByAggregateInput
  }

  export type HelpReadStatusScalarWhereWithAggregatesInput = {
    AND?: HelpReadStatusScalarWhereWithAggregatesInput | HelpReadStatusScalarWhereWithAggregatesInput[]
    OR?: HelpReadStatusScalarWhereWithAggregatesInput[]
    NOT?: HelpReadStatusScalarWhereWithAggregatesInput | HelpReadStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HelpReadStatus"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HelpReadStatus"> | Date | string
    helpId?: StringWithAggregatesFilter<"HelpReadStatus"> | string
    userId?: StringWithAggregatesFilter<"HelpReadStatus"> | string
    helpMessageId?: StringNullableWithAggregatesFilter<"HelpReadStatus"> | string | null
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: StringFilter<"notifications"> | string
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
    userId?: StringFilter<"notifications"> | string
    type?: StringFilter<"notifications"> | string
    content?: StringFilter<"notifications"> | string
    read?: BoolFilter<"notifications"> | boolean
    metadata?: JsonNullableFilter<"notifications">
    users?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    metadata?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
    userId?: StringFilter<"notifications"> | string
    type?: StringFilter<"notifications"> | string
    content?: StringFilter<"notifications"> | string
    read?: BoolFilter<"notifications"> | boolean
    metadata?: JsonNullableFilter<"notifications">
    users?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notifications"> | string
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    userId?: StringWithAggregatesFilter<"notifications"> | string
    type?: StringWithAggregatesFilter<"notifications"> | string
    content?: StringWithAggregatesFilter<"notifications"> | string
    read?: BoolWithAggregatesFilter<"notifications"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"notifications">
  }

  export type PostViewStatusWhereInput = {
    AND?: PostViewStatusWhereInput | PostViewStatusWhereInput[]
    OR?: PostViewStatusWhereInput[]
    NOT?: PostViewStatusWhereInput | PostViewStatusWhereInput[]
    id?: StringFilter<"PostViewStatus"> | string
    createdAt?: DateTimeFilter<"PostViewStatus"> | Date | string
    updatedAt?: DateTimeFilter<"PostViewStatus"> | Date | string
    userId?: StringFilter<"PostViewStatus"> | string
    postId?: StringFilter<"PostViewStatus"> | string
    lastViewedAt?: DateTimeFilter<"PostViewStatus"> | Date | string
    post?: XOR<PostRelationFilter, PostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PostViewStatusOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    lastViewedAt?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PostViewStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_postId?: PostViewStatusUserIdPostIdCompoundUniqueInput
    AND?: PostViewStatusWhereInput | PostViewStatusWhereInput[]
    OR?: PostViewStatusWhereInput[]
    NOT?: PostViewStatusWhereInput | PostViewStatusWhereInput[]
    createdAt?: DateTimeFilter<"PostViewStatus"> | Date | string
    updatedAt?: DateTimeFilter<"PostViewStatus"> | Date | string
    userId?: StringFilter<"PostViewStatus"> | string
    postId?: StringFilter<"PostViewStatus"> | string
    lastViewedAt?: DateTimeFilter<"PostViewStatus"> | Date | string
    post?: XOR<PostRelationFilter, PostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_postId">

  export type PostViewStatusOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    lastViewedAt?: SortOrder
    _count?: PostViewStatusCountOrderByAggregateInput
    _max?: PostViewStatusMaxOrderByAggregateInput
    _min?: PostViewStatusMinOrderByAggregateInput
  }

  export type PostViewStatusScalarWhereWithAggregatesInput = {
    AND?: PostViewStatusScalarWhereWithAggregatesInput | PostViewStatusScalarWhereWithAggregatesInput[]
    OR?: PostViewStatusScalarWhereWithAggregatesInput[]
    NOT?: PostViewStatusScalarWhereWithAggregatesInput | PostViewStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostViewStatus"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PostViewStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PostViewStatus"> | Date | string
    userId?: StringWithAggregatesFilter<"PostViewStatus"> | string
    postId?: StringWithAggregatesFilter<"PostViewStatus"> | string
    lastViewedAt?: DateTimeWithAggregatesFilter<"PostViewStatus"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDeviceTokenCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    device_type: string
    user: UserCreateNestedOneWithoutDeviceTokensInput
  }

  export type UserDeviceTokenUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    token: string
    device_type: string
  }

  export type UserDeviceTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    device_type?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDeviceTokensNestedInput
  }

  export type UserDeviceTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device_type?: StringFieldUpdateOperationsInput | string
  }

  export type UserDeviceTokenCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    token: string
    device_type: string
  }

  export type UserDeviceTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    device_type?: StringFieldUpdateOperationsInput | string
  }

  export type UserDeviceTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device_type?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    token: string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    token: string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type UserMoodCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mood: $Enums.UserMoodType
    note?: string | null
    user: UserCreateNestedOneWithoutMoodsInput
  }

  export type UserMoodUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    mood: $Enums.UserMoodType
    note?: string | null
  }

  export type UserMoodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: EnumUserMoodTypeFieldUpdateOperationsInput | $Enums.UserMoodType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutMoodsNestedInput
  }

  export type UserMoodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    mood?: EnumUserMoodTypeFieldUpdateOperationsInput | $Enums.UserMoodType
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserMoodCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    mood: $Enums.UserMoodType
    note?: string | null
  }

  export type UserMoodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: EnumUserMoodTypeFieldUpdateOperationsInput | $Enums.UserMoodType
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserMoodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    mood?: EnumUserMoodTypeFieldUpdateOperationsInput | $Enums.UserMoodType
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FriendshipCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.FriendshipStatus
    user1: UserCreateNestedOneWithoutFriends1Input
    user2: UserCreateNestedOneWithoutFriends2Input
  }

  export type FriendshipUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.FriendshipStatus
    user1Id: string
    user2Id: string
  }

  export type FriendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    user1?: UserUpdateOneRequiredWithoutFriends1NestedInput
    user2?: UserUpdateOneRequiredWithoutFriends2NestedInput
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.FriendshipStatus
    user1Id: string
    user2Id: string
  }

  export type FriendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
  }

  export type ChatroomCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    lastMessage?: string | null
    readStatuses?: ChatroomReadStatusCreateNestedManyWithoutChatroomInput
    messages?: ChatroomMessageCreateNestedManyWithoutChatroomInput
    members?: UserCreateNestedManyWithoutChatroomsInput
  }

  export type ChatroomUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    lastMessage?: string | null
    readStatuses?: ChatroomReadStatusUncheckedCreateNestedManyWithoutChatroomInput
    messages?: ChatroomMessageUncheckedCreateNestedManyWithoutChatroomInput
    members?: UserUncheckedCreateNestedManyWithoutChatroomsInput
  }

  export type ChatroomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readStatuses?: ChatroomReadStatusUpdateManyWithoutChatroomNestedInput
    messages?: ChatroomMessageUpdateManyWithoutChatroomNestedInput
    members?: UserUpdateManyWithoutChatroomsNestedInput
  }

  export type ChatroomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readStatuses?: ChatroomReadStatusUncheckedUpdateManyWithoutChatroomNestedInput
    messages?: ChatroomMessageUncheckedUpdateManyWithoutChatroomNestedInput
    members?: UserUncheckedUpdateManyWithoutChatroomsNestedInput
  }

  export type ChatroomCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    lastMessage?: string | null
  }

  export type ChatroomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatroomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatroomMessageCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusCreateNestedManyWithoutMessageInput
    chatroom: ChatroomCreateNestedOneWithoutMessagesInput
    reply?: ChatroomMessageCreateNestedOneWithoutChat_messageInput
    chat_message?: ChatroomMessageCreateNestedManyWithoutReplyInput
    sender: UserCreateNestedOneWithoutChatroomMessageInput
  }

  export type ChatroomMessageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatroomId: string
    senderId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    reply_id?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusUncheckedCreateNestedManyWithoutMessageInput
    chat_message?: ChatroomMessageUncheckedCreateNestedManyWithoutReplyInput
  }

  export type ChatroomMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUpdateManyWithoutMessageNestedInput
    chatroom?: ChatroomUpdateOneRequiredWithoutMessagesNestedInput
    reply?: ChatroomMessageUpdateOneWithoutChat_messageNestedInput
    chat_message?: ChatroomMessageUpdateManyWithoutReplyNestedInput
    sender?: UserUpdateOneRequiredWithoutChatroomMessageNestedInput
  }

  export type ChatroomMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUncheckedUpdateManyWithoutMessageNestedInput
    chat_message?: ChatroomMessageUncheckedUpdateManyWithoutReplyNestedInput
  }

  export type ChatroomMessageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatroomId: string
    senderId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    reply_id?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
  }

  export type ChatroomMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatroomMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatroomReadStatusCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    chatroom: ChatroomCreateNestedOneWithoutReadStatusesInput
    message: ChatroomMessageCreateNestedOneWithoutReadByInput
  }

  export type ChatroomReadStatusUncheckedCreateInput = {
    id?: string
    chatroomId: string
    userId: string
    messageId: string
    createdAt?: Date | string
  }

  export type ChatroomReadStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom?: ChatroomUpdateOneRequiredWithoutReadStatusesNestedInput
    message?: ChatroomMessageUpdateOneRequiredWithoutReadByNestedInput
  }

  export type ChatroomReadStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatroomReadStatusCreateManyInput = {
    id?: string
    chatroomId: string
    userId: string
    messageId: string
    createdAt?: Date | string
  }

  export type ChatroomReadStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatroomReadStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    total_likes?: number
    total_comments?: number
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutPostsInput
    viewStatus?: PostViewStatusCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    userId: string
    total_likes?: number
    total_comments?: number
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentUncheckedCreateNestedManyWithoutPostInput
    viewStatus?: PostViewStatusUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    viewStatus?: PostViewStatusUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUncheckedUpdateManyWithoutPostNestedInput
    viewStatus?: PostViewStatusUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    userId: string
    total_likes?: number
    total_comments?: number
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
  }

  export type MediaAttachmentCreateInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    post: PostCreateNestedOneWithoutMediaAttachmentsInput
  }

  export type MediaAttachmentUncheckedCreateInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    postId: string
  }

  export type MediaAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutMediaAttachmentsNestedInput
  }

  export type MediaAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaAttachmentCreateManyInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    postId: string
  }

  export type MediaAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MediaAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    text: string
    post: PostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    text: string
    postId: string
    userId: string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    text: string
    postId: string
    userId: string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    userId: string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LikeCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    userId: string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type HelpCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutHelpInput
    messages?: HelpMessageCreateNestedManyWithoutHelpInput
    helper?: UserCreateNestedOneWithoutHelperInput
    requestedBy: UserCreateNestedOneWithoutRequestedHelpInput
  }

  export type HelpUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    requestedById: string
    helperId?: string | null
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutHelpInput
    messages?: HelpMessageUncheckedCreateNestedManyWithoutHelpInput
  }

  export type HelpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    helpReadStatus?: HelpReadStatusUpdateManyWithoutHelpNestedInput
    messages?: HelpMessageUpdateManyWithoutHelpNestedInput
    helper?: UserUpdateOneWithoutHelperNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRequestedHelpNestedInput
  }

  export type HelpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: StringFieldUpdateOperationsInput | string
    helperId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutHelpNestedInput
    messages?: HelpMessageUncheckedUpdateManyWithoutHelpNestedInput
  }

  export type HelpCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    requestedById: string
    helperId?: string | null
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
  }

  export type HelpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HelpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: StringFieldUpdateOperationsInput | string
    helperId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HelpMessageCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
    readBy?: HelpReadStatusCreateNestedManyWithoutHelpMessageInput
    help: HelpCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutHelp_messagesInput
  }

  export type HelpMessageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    helpId: string
    senderId: string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
    readBy?: HelpReadStatusUncheckedCreateNestedManyWithoutHelpMessageInput
  }

  export type HelpMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: HelpReadStatusUpdateManyWithoutHelpMessageNestedInput
    help?: HelpUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutHelp_messagesNestedInput
  }

  export type HelpMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: HelpReadStatusUncheckedUpdateManyWithoutHelpMessageNestedInput
  }

  export type HelpMessageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    helpId: string
    senderId: string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
  }

  export type HelpMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelpMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelpReadStatusCreateInput = {
    id?: string
    createdAt?: Date | string
    help: HelpCreateNestedOneWithoutHelpReadStatusInput
    helpMessage?: HelpMessageCreateNestedOneWithoutReadByInput
    user: UserCreateNestedOneWithoutHelpReadStatusInput
  }

  export type HelpReadStatusUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    helpId: string
    userId: string
    helpMessageId?: string | null
  }

  export type HelpReadStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    help?: HelpUpdateOneRequiredWithoutHelpReadStatusNestedInput
    helpMessage?: HelpMessageUpdateOneWithoutReadByNestedInput
    user?: UserUpdateOneRequiredWithoutHelpReadStatusNestedInput
  }

  export type HelpReadStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    helpMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelpReadStatusCreateManyInput = {
    id?: string
    createdAt?: Date | string
    helpId: string
    userId: string
    helpMessageId?: string | null
  }

  export type HelpReadStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpReadStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    helpMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationsCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    type: string
    content: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    users: UserCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
    type: string
    content: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    users?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type notificationsCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
    type: string
    content: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostViewStatusCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastViewedAt: Date | string
    post: PostCreateNestedOneWithoutViewStatusInput
    user: UserCreateNestedOneWithoutPostViewsInput
  }

  export type PostViewStatusUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    postId: string
    lastViewedAt: Date | string
  }

  export type PostViewStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutViewStatusNestedInput
    user?: UserUpdateOneRequiredWithoutPostViewsNestedInput
  }

  export type PostViewStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewStatusCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    postId: string
    lastViewedAt: Date | string
  }

  export type PostViewStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type HelpReadStatusListRelationFilter = {
    every?: HelpReadStatusWhereInput
    some?: HelpReadStatusWhereInput
    none?: HelpReadStatusWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type ChatroomMessageListRelationFilter = {
    every?: ChatroomMessageWhereInput
    some?: ChatroomMessageWhereInput
    none?: ChatroomMessageWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: FriendshipWhereInput
    some?: FriendshipWhereInput
    none?: FriendshipWhereInput
  }

  export type HelpMessageListRelationFilter = {
    every?: HelpMessageWhereInput
    some?: HelpMessageWhereInput
    none?: HelpMessageWhereInput
  }

  export type HelpListRelationFilter = {
    every?: HelpWhereInput
    some?: HelpWhereInput
    none?: HelpWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type PostViewStatusListRelationFilter = {
    every?: PostViewStatusWhereInput
    some?: PostViewStatusWhereInput
    none?: PostViewStatusWhereInput
  }

  export type UserDeviceTokenListRelationFilter = {
    every?: UserDeviceTokenWhereInput
    some?: UserDeviceTokenWhereInput
    none?: UserDeviceTokenWhereInput
  }

  export type UserMoodListRelationFilter = {
    every?: UserMoodWhereInput
    some?: UserMoodWhereInput
    none?: UserMoodWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type ChatroomListRelationFilter = {
    every?: ChatroomWhereInput
    some?: ChatroomWhereInput
    none?: ChatroomWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelpReadStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatroomMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelpMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostViewStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDeviceTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserMoodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    local?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profilePicture?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    schoolName?: SortOrder
    className?: SortOrder
    teacherName?: SortOrder
    isVerified?: SortOrder
    isBlocked?: SortOrder
    isOnline?: SortOrder
    isDeleted?: SortOrder
    isHelping?: SortOrder
    Aliyun_token?: SortOrder
    device_type?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    local?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profilePicture?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    schoolName?: SortOrder
    className?: SortOrder
    teacherName?: SortOrder
    isVerified?: SortOrder
    isBlocked?: SortOrder
    isOnline?: SortOrder
    isDeleted?: SortOrder
    isHelping?: SortOrder
    Aliyun_token?: SortOrder
    device_type?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    local?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profilePicture?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    schoolName?: SortOrder
    className?: SortOrder
    teacherName?: SortOrder
    isVerified?: SortOrder
    isBlocked?: SortOrder
    isOnline?: SortOrder
    isDeleted?: SortOrder
    isHelping?: SortOrder
    Aliyun_token?: SortOrder
    device_type?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserDeviceTokenCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device_type?: SortOrder
  }

  export type UserDeviceTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device_type?: SortOrder
  }

  export type UserDeviceTokenMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device_type?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type EnumUserMoodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserMoodType | EnumUserMoodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserMoodType[] | ListEnumUserMoodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserMoodType[] | ListEnumUserMoodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserMoodTypeFilter<$PrismaModel> | $Enums.UserMoodType
  }

  export type UserMoodCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    note?: SortOrder
  }

  export type UserMoodMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    note?: SortOrder
  }

  export type UserMoodMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    note?: SortOrder
  }

  export type EnumUserMoodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserMoodType | EnumUserMoodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserMoodType[] | ListEnumUserMoodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserMoodType[] | ListEnumUserMoodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserMoodTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserMoodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserMoodTypeFilter<$PrismaModel>
    _max?: NestedEnumUserMoodTypeFilter<$PrismaModel>
  }

  export type EnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
  }

  export type EnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type ChatroomReadStatusListRelationFilter = {
    every?: ChatroomReadStatusWhereInput
    some?: ChatroomReadStatusWhereInput
    none?: ChatroomReadStatusWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ChatroomReadStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatroomCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    lastMessage?: SortOrder
  }

  export type ChatroomMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    lastMessage?: SortOrder
  }

  export type ChatroomMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    lastMessage?: SortOrder
  }

  export type EnumChatroomMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatroomMessageStatus | EnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatroomMessageStatus[] | ListEnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatroomMessageStatus[] | ListEnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatroomMessageStatusFilter<$PrismaModel> | $Enums.ChatroomMessageStatus
  }

  export type EnumChatroomMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatroomMessageType | EnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatroomMessageType[] | ListEnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatroomMessageType[] | ListEnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatroomMessageTypeFilter<$PrismaModel> | $Enums.ChatroomMessageType
  }

  export type EnumCallMessageStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CallMessageStatus | EnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallMessageStatus[] | ListEnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallMessageStatus[] | ListEnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallMessageStatusNullableFilter<$PrismaModel> | $Enums.CallMessageStatus | null
  }

  export type ChatroomRelationFilter = {
    is?: ChatroomWhereInput
    isNot?: ChatroomWhereInput
  }

  export type ChatroomMessageNullableRelationFilter = {
    is?: ChatroomMessageWhereInput | null
    isNot?: ChatroomMessageWhereInput | null
  }

  export type ChatroomMessageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatroomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrder
    reply_id?: SortOrder
    call_message_status?: SortOrder
    isDeleted?: SortOrder
    payload?: SortOrder
  }

  export type ChatroomMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatroomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrder
    reply_id?: SortOrder
    call_message_status?: SortOrder
    isDeleted?: SortOrder
    payload?: SortOrder
  }

  export type ChatroomMessageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatroomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrder
    reply_id?: SortOrder
    call_message_status?: SortOrder
    isDeleted?: SortOrder
    payload?: SortOrder
  }

  export type EnumChatroomMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatroomMessageStatus | EnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatroomMessageStatus[] | ListEnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatroomMessageStatus[] | ListEnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatroomMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChatroomMessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatroomMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumChatroomMessageStatusFilter<$PrismaModel>
  }

  export type EnumChatroomMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatroomMessageType | EnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatroomMessageType[] | ListEnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatroomMessageType[] | ListEnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatroomMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChatroomMessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatroomMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumChatroomMessageTypeFilter<$PrismaModel>
  }

  export type EnumCallMessageStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallMessageStatus | EnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallMessageStatus[] | ListEnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallMessageStatus[] | ListEnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallMessageStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CallMessageStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCallMessageStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCallMessageStatusNullableFilter<$PrismaModel>
  }

  export type ChatroomMessageRelationFilter = {
    is?: ChatroomMessageWhereInput
    isNot?: ChatroomMessageWhereInput
  }

  export type ChatroomReadStatusChatroomIdUserIdMessageIdCompoundUniqueInput = {
    chatroomId: string
    userId: string
    messageId: string
  }

  export type ChatroomReadStatusCountOrderByAggregateInput = {
    id?: SortOrder
    chatroomId?: SortOrder
    userId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatroomReadStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    chatroomId?: SortOrder
    userId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatroomReadStatusMinOrderByAggregateInput = {
    id?: SortOrder
    chatroomId?: SortOrder
    userId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type MediaAttachmentListRelationFilter = {
    every?: MediaAttachmentWhereInput
    some?: MediaAttachmentWhereInput
    none?: MediaAttachmentWhereInput
  }

  export type MediaAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_anonymous?: SortOrder
    text?: SortOrder
    mood?: SortOrder
    userId?: SortOrder
    total_likes?: SortOrder
    total_comments?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    total_likes?: SortOrder
    total_comments?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_anonymous?: SortOrder
    text?: SortOrder
    mood?: SortOrder
    userId?: SortOrder
    total_likes?: SortOrder
    total_comments?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_anonymous?: SortOrder
    text?: SortOrder
    mood?: SortOrder
    userId?: SortOrder
    total_likes?: SortOrder
    total_comments?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    total_likes?: SortOrder
    total_comments?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type MediaAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    postId?: SortOrder
  }

  export type MediaAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    postId?: SortOrder
  }

  export type MediaAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    postId?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    text?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    text?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    text?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type EnumHelpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HelpStatus | EnumHelpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HelpStatus[] | ListEnumHelpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HelpStatus[] | ListEnumHelpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHelpStatusFilter<$PrismaModel> | $Enums.HelpStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type HelpCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    requestedById?: SortOrder
    helperId?: SortOrder
    status?: SortOrder
    locationLat?: SortOrder
    locationLng?: SortOrder
    address?: SortOrder
    isDeleted?: SortOrder
  }

  export type HelpAvgOrderByAggregateInput = {
    locationLat?: SortOrder
    locationLng?: SortOrder
  }

  export type HelpMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    requestedById?: SortOrder
    helperId?: SortOrder
    status?: SortOrder
    locationLat?: SortOrder
    locationLng?: SortOrder
    address?: SortOrder
    isDeleted?: SortOrder
  }

  export type HelpMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    requestedById?: SortOrder
    helperId?: SortOrder
    status?: SortOrder
    locationLat?: SortOrder
    locationLng?: SortOrder
    address?: SortOrder
    isDeleted?: SortOrder
  }

  export type HelpSumOrderByAggregateInput = {
    locationLat?: SortOrder
    locationLng?: SortOrder
  }

  export type EnumHelpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HelpStatus | EnumHelpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HelpStatus[] | ListEnumHelpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HelpStatus[] | ListEnumHelpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHelpStatusWithAggregatesFilter<$PrismaModel> | $Enums.HelpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHelpStatusFilter<$PrismaModel>
    _max?: NestedEnumHelpStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type HelpRelationFilter = {
    is?: HelpWhereInput
    isNot?: HelpWhereInput
  }

  export type HelpMessageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    helpId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrder
    locationLat?: SortOrder
    locationLng?: SortOrder
    isDeleted?: SortOrder
    reply_id?: SortOrder
  }

  export type HelpMessageAvgOrderByAggregateInput = {
    locationLat?: SortOrder
    locationLng?: SortOrder
  }

  export type HelpMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    helpId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrder
    locationLat?: SortOrder
    locationLng?: SortOrder
    isDeleted?: SortOrder
    reply_id?: SortOrder
  }

  export type HelpMessageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    helpId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    type?: SortOrder
    file?: SortOrder
    locationLat?: SortOrder
    locationLng?: SortOrder
    isDeleted?: SortOrder
    reply_id?: SortOrder
  }

  export type HelpMessageSumOrderByAggregateInput = {
    locationLat?: SortOrder
    locationLng?: SortOrder
  }

  export type HelpMessageNullableRelationFilter = {
    is?: HelpMessageWhereInput | null
    isNot?: HelpMessageWhereInput | null
  }

  export type HelpReadStatusHelpMessageIdHelpIdUserIdCompoundUniqueInput = {
    helpMessageId: string
    helpId: string
    userId: string
  }

  export type HelpReadStatusCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    helpId?: SortOrder
    userId?: SortOrder
    helpMessageId?: SortOrder
  }

  export type HelpReadStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    helpId?: SortOrder
    userId?: SortOrder
    helpMessageId?: SortOrder
  }

  export type HelpReadStatusMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    helpId?: SortOrder
    userId?: SortOrder
    helpMessageId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
    metadata?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    read?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PostViewStatusUserIdPostIdCompoundUniqueInput = {
    userId: string
    postId: string
  }

  export type PostViewStatusCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type PostViewStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type PostViewStatusMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type HelpReadStatusCreateNestedManyWithoutUserInput = {
    create?: XOR<HelpReadStatusCreateWithoutUserInput, HelpReadStatusUncheckedCreateWithoutUserInput> | HelpReadStatusCreateWithoutUserInput[] | HelpReadStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutUserInput | HelpReadStatusCreateOrConnectWithoutUserInput[]
    createMany?: HelpReadStatusCreateManyUserInputEnvelope
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ChatroomMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatroomMessageCreateWithoutSenderInput, ChatroomMessageUncheckedCreateWithoutSenderInput> | ChatroomMessageCreateWithoutSenderInput[] | ChatroomMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutSenderInput | ChatroomMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatroomMessageCreateManySenderInputEnvelope
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutUser1Input = {
    create?: XOR<FriendshipCreateWithoutUser1Input, FriendshipUncheckedCreateWithoutUser1Input> | FriendshipCreateWithoutUser1Input[] | FriendshipUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUser1Input | FriendshipCreateOrConnectWithoutUser1Input[]
    createMany?: FriendshipCreateManyUser1InputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutUser2Input = {
    create?: XOR<FriendshipCreateWithoutUser2Input, FriendshipUncheckedCreateWithoutUser2Input> | FriendshipCreateWithoutUser2Input[] | FriendshipUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUser2Input | FriendshipCreateOrConnectWithoutUser2Input[]
    createMany?: FriendshipCreateManyUser2InputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type HelpMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<HelpMessageCreateWithoutSenderInput, HelpMessageUncheckedCreateWithoutSenderInput> | HelpMessageCreateWithoutSenderInput[] | HelpMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: HelpMessageCreateOrConnectWithoutSenderInput | HelpMessageCreateOrConnectWithoutSenderInput[]
    createMany?: HelpMessageCreateManySenderInputEnvelope
    connect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
  }

  export type HelpCreateNestedManyWithoutHelperInput = {
    create?: XOR<HelpCreateWithoutHelperInput, HelpUncheckedCreateWithoutHelperInput> | HelpCreateWithoutHelperInput[] | HelpUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: HelpCreateOrConnectWithoutHelperInput | HelpCreateOrConnectWithoutHelperInput[]
    createMany?: HelpCreateManyHelperInputEnvelope
    connect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
  }

  export type HelpCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<HelpCreateWithoutRequestedByInput, HelpUncheckedCreateWithoutRequestedByInput> | HelpCreateWithoutRequestedByInput[] | HelpUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: HelpCreateOrConnectWithoutRequestedByInput | HelpCreateOrConnectWithoutRequestedByInput[]
    createMany?: HelpCreateManyRequestedByInputEnvelope
    connect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type PostViewStatusCreateNestedManyWithoutUserInput = {
    create?: XOR<PostViewStatusCreateWithoutUserInput, PostViewStatusUncheckedCreateWithoutUserInput> | PostViewStatusCreateWithoutUserInput[] | PostViewStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostViewStatusCreateOrConnectWithoutUserInput | PostViewStatusCreateOrConnectWithoutUserInput[]
    createMany?: PostViewStatusCreateManyUserInputEnvelope
    connect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
  }

  export type UserDeviceTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDeviceTokenCreateWithoutUserInput, UserDeviceTokenUncheckedCreateWithoutUserInput> | UserDeviceTokenCreateWithoutUserInput[] | UserDeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceTokenCreateOrConnectWithoutUserInput | UserDeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: UserDeviceTokenCreateManyUserInputEnvelope
    connect?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
  }

  export type UserMoodCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMoodCreateWithoutUserInput, UserMoodUncheckedCreateWithoutUserInput> | UserMoodCreateWithoutUserInput[] | UserMoodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMoodCreateOrConnectWithoutUserInput | UserMoodCreateOrConnectWithoutUserInput[]
    createMany?: UserMoodCreateManyUserInputEnvelope
    connect?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type ChatroomCreateNestedManyWithoutMembersInput = {
    create?: XOR<ChatroomCreateWithoutMembersInput, ChatroomUncheckedCreateWithoutMembersInput> | ChatroomCreateWithoutMembersInput[] | ChatroomUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ChatroomCreateOrConnectWithoutMembersInput | ChatroomCreateOrConnectWithoutMembersInput[]
    connect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type HelpReadStatusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HelpReadStatusCreateWithoutUserInput, HelpReadStatusUncheckedCreateWithoutUserInput> | HelpReadStatusCreateWithoutUserInput[] | HelpReadStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutUserInput | HelpReadStatusCreateOrConnectWithoutUserInput[]
    createMany?: HelpReadStatusCreateManyUserInputEnvelope
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatroomMessageCreateWithoutSenderInput, ChatroomMessageUncheckedCreateWithoutSenderInput> | ChatroomMessageCreateWithoutSenderInput[] | ChatroomMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutSenderInput | ChatroomMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatroomMessageCreateManySenderInputEnvelope
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutUser1Input = {
    create?: XOR<FriendshipCreateWithoutUser1Input, FriendshipUncheckedCreateWithoutUser1Input> | FriendshipCreateWithoutUser1Input[] | FriendshipUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUser1Input | FriendshipCreateOrConnectWithoutUser1Input[]
    createMany?: FriendshipCreateManyUser1InputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutUser2Input = {
    create?: XOR<FriendshipCreateWithoutUser2Input, FriendshipUncheckedCreateWithoutUser2Input> | FriendshipCreateWithoutUser2Input[] | FriendshipUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUser2Input | FriendshipCreateOrConnectWithoutUser2Input[]
    createMany?: FriendshipCreateManyUser2InputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type HelpMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<HelpMessageCreateWithoutSenderInput, HelpMessageUncheckedCreateWithoutSenderInput> | HelpMessageCreateWithoutSenderInput[] | HelpMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: HelpMessageCreateOrConnectWithoutSenderInput | HelpMessageCreateOrConnectWithoutSenderInput[]
    createMany?: HelpMessageCreateManySenderInputEnvelope
    connect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
  }

  export type HelpUncheckedCreateNestedManyWithoutHelperInput = {
    create?: XOR<HelpCreateWithoutHelperInput, HelpUncheckedCreateWithoutHelperInput> | HelpCreateWithoutHelperInput[] | HelpUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: HelpCreateOrConnectWithoutHelperInput | HelpCreateOrConnectWithoutHelperInput[]
    createMany?: HelpCreateManyHelperInputEnvelope
    connect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
  }

  export type HelpUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<HelpCreateWithoutRequestedByInput, HelpUncheckedCreateWithoutRequestedByInput> | HelpCreateWithoutRequestedByInput[] | HelpUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: HelpCreateOrConnectWithoutRequestedByInput | HelpCreateOrConnectWithoutRequestedByInput[]
    createMany?: HelpCreateManyRequestedByInputEnvelope
    connect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type PostViewStatusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostViewStatusCreateWithoutUserInput, PostViewStatusUncheckedCreateWithoutUserInput> | PostViewStatusCreateWithoutUserInput[] | PostViewStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostViewStatusCreateOrConnectWithoutUserInput | PostViewStatusCreateOrConnectWithoutUserInput[]
    createMany?: PostViewStatusCreateManyUserInputEnvelope
    connect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
  }

  export type UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDeviceTokenCreateWithoutUserInput, UserDeviceTokenUncheckedCreateWithoutUserInput> | UserDeviceTokenCreateWithoutUserInput[] | UserDeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceTokenCreateOrConnectWithoutUserInput | UserDeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: UserDeviceTokenCreateManyUserInputEnvelope
    connect?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
  }

  export type UserMoodUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMoodCreateWithoutUserInput, UserMoodUncheckedCreateWithoutUserInput> | UserMoodCreateWithoutUserInput[] | UserMoodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMoodCreateOrConnectWithoutUserInput | UserMoodCreateOrConnectWithoutUserInput[]
    createMany?: UserMoodCreateManyUserInputEnvelope
    connect?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type ChatroomUncheckedCreateNestedManyWithoutMembersInput = {
    create?: XOR<ChatroomCreateWithoutMembersInput, ChatroomUncheckedCreateWithoutMembersInput> | ChatroomCreateWithoutMembersInput[] | ChatroomUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ChatroomCreateOrConnectWithoutMembersInput | ChatroomCreateOrConnectWithoutMembersInput[]
    connect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type HelpReadStatusUpdateManyWithoutUserNestedInput = {
    create?: XOR<HelpReadStatusCreateWithoutUserInput, HelpReadStatusUncheckedCreateWithoutUserInput> | HelpReadStatusCreateWithoutUserInput[] | HelpReadStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutUserInput | HelpReadStatusCreateOrConnectWithoutUserInput[]
    upsert?: HelpReadStatusUpsertWithWhereUniqueWithoutUserInput | HelpReadStatusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HelpReadStatusCreateManyUserInputEnvelope
    set?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    disconnect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    delete?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    update?: HelpReadStatusUpdateWithWhereUniqueWithoutUserInput | HelpReadStatusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HelpReadStatusUpdateManyWithWhereWithoutUserInput | HelpReadStatusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HelpReadStatusScalarWhereInput | HelpReadStatusScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ChatroomMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatroomMessageCreateWithoutSenderInput, ChatroomMessageUncheckedCreateWithoutSenderInput> | ChatroomMessageCreateWithoutSenderInput[] | ChatroomMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutSenderInput | ChatroomMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatroomMessageUpsertWithWhereUniqueWithoutSenderInput | ChatroomMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatroomMessageCreateManySenderInputEnvelope
    set?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    disconnect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    delete?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    update?: ChatroomMessageUpdateWithWhereUniqueWithoutSenderInput | ChatroomMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatroomMessageUpdateManyWithWhereWithoutSenderInput | ChatroomMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatroomMessageScalarWhereInput | ChatroomMessageScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutUser1NestedInput = {
    create?: XOR<FriendshipCreateWithoutUser1Input, FriendshipUncheckedCreateWithoutUser1Input> | FriendshipCreateWithoutUser1Input[] | FriendshipUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUser1Input | FriendshipCreateOrConnectWithoutUser1Input[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUser1Input | FriendshipUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: FriendshipCreateManyUser1InputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUser1Input | FriendshipUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUser1Input | FriendshipUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutUser2NestedInput = {
    create?: XOR<FriendshipCreateWithoutUser2Input, FriendshipUncheckedCreateWithoutUser2Input> | FriendshipCreateWithoutUser2Input[] | FriendshipUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUser2Input | FriendshipCreateOrConnectWithoutUser2Input[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUser2Input | FriendshipUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: FriendshipCreateManyUser2InputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUser2Input | FriendshipUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUser2Input | FriendshipUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type HelpMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<HelpMessageCreateWithoutSenderInput, HelpMessageUncheckedCreateWithoutSenderInput> | HelpMessageCreateWithoutSenderInput[] | HelpMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: HelpMessageCreateOrConnectWithoutSenderInput | HelpMessageCreateOrConnectWithoutSenderInput[]
    upsert?: HelpMessageUpsertWithWhereUniqueWithoutSenderInput | HelpMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: HelpMessageCreateManySenderInputEnvelope
    set?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    disconnect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    delete?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    connect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    update?: HelpMessageUpdateWithWhereUniqueWithoutSenderInput | HelpMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: HelpMessageUpdateManyWithWhereWithoutSenderInput | HelpMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: HelpMessageScalarWhereInput | HelpMessageScalarWhereInput[]
  }

  export type HelpUpdateManyWithoutHelperNestedInput = {
    create?: XOR<HelpCreateWithoutHelperInput, HelpUncheckedCreateWithoutHelperInput> | HelpCreateWithoutHelperInput[] | HelpUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: HelpCreateOrConnectWithoutHelperInput | HelpCreateOrConnectWithoutHelperInput[]
    upsert?: HelpUpsertWithWhereUniqueWithoutHelperInput | HelpUpsertWithWhereUniqueWithoutHelperInput[]
    createMany?: HelpCreateManyHelperInputEnvelope
    set?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    disconnect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    delete?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    connect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    update?: HelpUpdateWithWhereUniqueWithoutHelperInput | HelpUpdateWithWhereUniqueWithoutHelperInput[]
    updateMany?: HelpUpdateManyWithWhereWithoutHelperInput | HelpUpdateManyWithWhereWithoutHelperInput[]
    deleteMany?: HelpScalarWhereInput | HelpScalarWhereInput[]
  }

  export type HelpUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<HelpCreateWithoutRequestedByInput, HelpUncheckedCreateWithoutRequestedByInput> | HelpCreateWithoutRequestedByInput[] | HelpUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: HelpCreateOrConnectWithoutRequestedByInput | HelpCreateOrConnectWithoutRequestedByInput[]
    upsert?: HelpUpsertWithWhereUniqueWithoutRequestedByInput | HelpUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: HelpCreateManyRequestedByInputEnvelope
    set?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    disconnect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    delete?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    connect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    update?: HelpUpdateWithWhereUniqueWithoutRequestedByInput | HelpUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: HelpUpdateManyWithWhereWithoutRequestedByInput | HelpUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: HelpScalarWhereInput | HelpScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type PostViewStatusUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostViewStatusCreateWithoutUserInput, PostViewStatusUncheckedCreateWithoutUserInput> | PostViewStatusCreateWithoutUserInput[] | PostViewStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostViewStatusCreateOrConnectWithoutUserInput | PostViewStatusCreateOrConnectWithoutUserInput[]
    upsert?: PostViewStatusUpsertWithWhereUniqueWithoutUserInput | PostViewStatusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostViewStatusCreateManyUserInputEnvelope
    set?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    disconnect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    delete?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    connect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    update?: PostViewStatusUpdateWithWhereUniqueWithoutUserInput | PostViewStatusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostViewStatusUpdateManyWithWhereWithoutUserInput | PostViewStatusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostViewStatusScalarWhereInput | PostViewStatusScalarWhereInput[]
  }

  export type UserDeviceTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDeviceTokenCreateWithoutUserInput, UserDeviceTokenUncheckedCreateWithoutUserInput> | UserDeviceTokenCreateWithoutUserInput[] | UserDeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceTokenCreateOrConnectWithoutUserInput | UserDeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: UserDeviceTokenUpsertWithWhereUniqueWithoutUserInput | UserDeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDeviceTokenCreateManyUserInputEnvelope
    set?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
    disconnect?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
    delete?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
    connect?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
    update?: UserDeviceTokenUpdateWithWhereUniqueWithoutUserInput | UserDeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDeviceTokenUpdateManyWithWhereWithoutUserInput | UserDeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDeviceTokenScalarWhereInput | UserDeviceTokenScalarWhereInput[]
  }

  export type UserMoodUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMoodCreateWithoutUserInput, UserMoodUncheckedCreateWithoutUserInput> | UserMoodCreateWithoutUserInput[] | UserMoodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMoodCreateOrConnectWithoutUserInput | UserMoodCreateOrConnectWithoutUserInput[]
    upsert?: UserMoodUpsertWithWhereUniqueWithoutUserInput | UserMoodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMoodCreateManyUserInputEnvelope
    set?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
    disconnect?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
    delete?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
    connect?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
    update?: UserMoodUpdateWithWhereUniqueWithoutUserInput | UserMoodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMoodUpdateManyWithWhereWithoutUserInput | UserMoodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMoodScalarWhereInput | UserMoodScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type ChatroomUpdateManyWithoutMembersNestedInput = {
    create?: XOR<ChatroomCreateWithoutMembersInput, ChatroomUncheckedCreateWithoutMembersInput> | ChatroomCreateWithoutMembersInput[] | ChatroomUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ChatroomCreateOrConnectWithoutMembersInput | ChatroomCreateOrConnectWithoutMembersInput[]
    upsert?: ChatroomUpsertWithWhereUniqueWithoutMembersInput | ChatroomUpsertWithWhereUniqueWithoutMembersInput[]
    set?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    disconnect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    delete?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    connect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    update?: ChatroomUpdateWithWhereUniqueWithoutMembersInput | ChatroomUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: ChatroomUpdateManyWithWhereWithoutMembersInput | ChatroomUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: ChatroomScalarWhereInput | ChatroomScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HelpReadStatusCreateWithoutUserInput, HelpReadStatusUncheckedCreateWithoutUserInput> | HelpReadStatusCreateWithoutUserInput[] | HelpReadStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutUserInput | HelpReadStatusCreateOrConnectWithoutUserInput[]
    upsert?: HelpReadStatusUpsertWithWhereUniqueWithoutUserInput | HelpReadStatusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HelpReadStatusCreateManyUserInputEnvelope
    set?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    disconnect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    delete?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    update?: HelpReadStatusUpdateWithWhereUniqueWithoutUserInput | HelpReadStatusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HelpReadStatusUpdateManyWithWhereWithoutUserInput | HelpReadStatusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HelpReadStatusScalarWhereInput | HelpReadStatusScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatroomMessageCreateWithoutSenderInput, ChatroomMessageUncheckedCreateWithoutSenderInput> | ChatroomMessageCreateWithoutSenderInput[] | ChatroomMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutSenderInput | ChatroomMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatroomMessageUpsertWithWhereUniqueWithoutSenderInput | ChatroomMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatroomMessageCreateManySenderInputEnvelope
    set?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    disconnect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    delete?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    update?: ChatroomMessageUpdateWithWhereUniqueWithoutSenderInput | ChatroomMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatroomMessageUpdateManyWithWhereWithoutSenderInput | ChatroomMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatroomMessageScalarWhereInput | ChatroomMessageScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutUser1NestedInput = {
    create?: XOR<FriendshipCreateWithoutUser1Input, FriendshipUncheckedCreateWithoutUser1Input> | FriendshipCreateWithoutUser1Input[] | FriendshipUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUser1Input | FriendshipCreateOrConnectWithoutUser1Input[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUser1Input | FriendshipUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: FriendshipCreateManyUser1InputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUser1Input | FriendshipUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUser1Input | FriendshipUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutUser2NestedInput = {
    create?: XOR<FriendshipCreateWithoutUser2Input, FriendshipUncheckedCreateWithoutUser2Input> | FriendshipCreateWithoutUser2Input[] | FriendshipUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUser2Input | FriendshipCreateOrConnectWithoutUser2Input[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUser2Input | FriendshipUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: FriendshipCreateManyUser2InputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUser2Input | FriendshipUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUser2Input | FriendshipUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type HelpMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<HelpMessageCreateWithoutSenderInput, HelpMessageUncheckedCreateWithoutSenderInput> | HelpMessageCreateWithoutSenderInput[] | HelpMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: HelpMessageCreateOrConnectWithoutSenderInput | HelpMessageCreateOrConnectWithoutSenderInput[]
    upsert?: HelpMessageUpsertWithWhereUniqueWithoutSenderInput | HelpMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: HelpMessageCreateManySenderInputEnvelope
    set?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    disconnect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    delete?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    connect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    update?: HelpMessageUpdateWithWhereUniqueWithoutSenderInput | HelpMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: HelpMessageUpdateManyWithWhereWithoutSenderInput | HelpMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: HelpMessageScalarWhereInput | HelpMessageScalarWhereInput[]
  }

  export type HelpUncheckedUpdateManyWithoutHelperNestedInput = {
    create?: XOR<HelpCreateWithoutHelperInput, HelpUncheckedCreateWithoutHelperInput> | HelpCreateWithoutHelperInput[] | HelpUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: HelpCreateOrConnectWithoutHelperInput | HelpCreateOrConnectWithoutHelperInput[]
    upsert?: HelpUpsertWithWhereUniqueWithoutHelperInput | HelpUpsertWithWhereUniqueWithoutHelperInput[]
    createMany?: HelpCreateManyHelperInputEnvelope
    set?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    disconnect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    delete?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    connect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    update?: HelpUpdateWithWhereUniqueWithoutHelperInput | HelpUpdateWithWhereUniqueWithoutHelperInput[]
    updateMany?: HelpUpdateManyWithWhereWithoutHelperInput | HelpUpdateManyWithWhereWithoutHelperInput[]
    deleteMany?: HelpScalarWhereInput | HelpScalarWhereInput[]
  }

  export type HelpUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<HelpCreateWithoutRequestedByInput, HelpUncheckedCreateWithoutRequestedByInput> | HelpCreateWithoutRequestedByInput[] | HelpUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: HelpCreateOrConnectWithoutRequestedByInput | HelpCreateOrConnectWithoutRequestedByInput[]
    upsert?: HelpUpsertWithWhereUniqueWithoutRequestedByInput | HelpUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: HelpCreateManyRequestedByInputEnvelope
    set?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    disconnect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    delete?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    connect?: HelpWhereUniqueInput | HelpWhereUniqueInput[]
    update?: HelpUpdateWithWhereUniqueWithoutRequestedByInput | HelpUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: HelpUpdateManyWithWhereWithoutRequestedByInput | HelpUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: HelpScalarWhereInput | HelpScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type PostViewStatusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostViewStatusCreateWithoutUserInput, PostViewStatusUncheckedCreateWithoutUserInput> | PostViewStatusCreateWithoutUserInput[] | PostViewStatusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostViewStatusCreateOrConnectWithoutUserInput | PostViewStatusCreateOrConnectWithoutUserInput[]
    upsert?: PostViewStatusUpsertWithWhereUniqueWithoutUserInput | PostViewStatusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostViewStatusCreateManyUserInputEnvelope
    set?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    disconnect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    delete?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    connect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    update?: PostViewStatusUpdateWithWhereUniqueWithoutUserInput | PostViewStatusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostViewStatusUpdateManyWithWhereWithoutUserInput | PostViewStatusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostViewStatusScalarWhereInput | PostViewStatusScalarWhereInput[]
  }

  export type UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDeviceTokenCreateWithoutUserInput, UserDeviceTokenUncheckedCreateWithoutUserInput> | UserDeviceTokenCreateWithoutUserInput[] | UserDeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceTokenCreateOrConnectWithoutUserInput | UserDeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: UserDeviceTokenUpsertWithWhereUniqueWithoutUserInput | UserDeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDeviceTokenCreateManyUserInputEnvelope
    set?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
    disconnect?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
    delete?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
    connect?: UserDeviceTokenWhereUniqueInput | UserDeviceTokenWhereUniqueInput[]
    update?: UserDeviceTokenUpdateWithWhereUniqueWithoutUserInput | UserDeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDeviceTokenUpdateManyWithWhereWithoutUserInput | UserDeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDeviceTokenScalarWhereInput | UserDeviceTokenScalarWhereInput[]
  }

  export type UserMoodUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMoodCreateWithoutUserInput, UserMoodUncheckedCreateWithoutUserInput> | UserMoodCreateWithoutUserInput[] | UserMoodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMoodCreateOrConnectWithoutUserInput | UserMoodCreateOrConnectWithoutUserInput[]
    upsert?: UserMoodUpsertWithWhereUniqueWithoutUserInput | UserMoodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMoodCreateManyUserInputEnvelope
    set?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
    disconnect?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
    delete?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
    connect?: UserMoodWhereUniqueInput | UserMoodWhereUniqueInput[]
    update?: UserMoodUpdateWithWhereUniqueWithoutUserInput | UserMoodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMoodUpdateManyWithWhereWithoutUserInput | UserMoodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMoodScalarWhereInput | UserMoodScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type ChatroomUncheckedUpdateManyWithoutMembersNestedInput = {
    create?: XOR<ChatroomCreateWithoutMembersInput, ChatroomUncheckedCreateWithoutMembersInput> | ChatroomCreateWithoutMembersInput[] | ChatroomUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ChatroomCreateOrConnectWithoutMembersInput | ChatroomCreateOrConnectWithoutMembersInput[]
    upsert?: ChatroomUpsertWithWhereUniqueWithoutMembersInput | ChatroomUpsertWithWhereUniqueWithoutMembersInput[]
    set?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    disconnect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    delete?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    connect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    update?: ChatroomUpdateWithWhereUniqueWithoutMembersInput | ChatroomUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: ChatroomUpdateManyWithWhereWithoutMembersInput | ChatroomUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: ChatroomScalarWhereInput | ChatroomScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDeviceTokensInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeviceTokensNestedInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    upsert?: UserUpsertWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeviceTokensInput, UserUpdateWithoutDeviceTokensInput>, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutMoodsInput = {
    create?: XOR<UserCreateWithoutMoodsInput, UserUncheckedCreateWithoutMoodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUserMoodTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserMoodType
  }

  export type UserUpdateOneRequiredWithoutMoodsNestedInput = {
    create?: XOR<UserCreateWithoutMoodsInput, UserUncheckedCreateWithoutMoodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodsInput
    upsert?: UserUpsertWithoutMoodsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMoodsInput, UserUpdateWithoutMoodsInput>, UserUncheckedUpdateWithoutMoodsInput>
  }

  export type UserCreateNestedOneWithoutFriends1Input = {
    create?: XOR<UserCreateWithoutFriends1Input, UserUncheckedCreateWithoutFriends1Input>
    connectOrCreate?: UserCreateOrConnectWithoutFriends1Input
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFriends2Input = {
    create?: XOR<UserCreateWithoutFriends2Input, UserUncheckedCreateWithoutFriends2Input>
    connectOrCreate?: UserCreateOrConnectWithoutFriends2Input
    connect?: UserWhereUniqueInput
  }

  export type EnumFriendshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.FriendshipStatus
  }

  export type UserUpdateOneRequiredWithoutFriends1NestedInput = {
    create?: XOR<UserCreateWithoutFriends1Input, UserUncheckedCreateWithoutFriends1Input>
    connectOrCreate?: UserCreateOrConnectWithoutFriends1Input
    upsert?: UserUpsertWithoutFriends1Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriends1Input, UserUpdateWithoutFriends1Input>, UserUncheckedUpdateWithoutFriends1Input>
  }

  export type UserUpdateOneRequiredWithoutFriends2NestedInput = {
    create?: XOR<UserCreateWithoutFriends2Input, UserUncheckedCreateWithoutFriends2Input>
    connectOrCreate?: UserCreateOrConnectWithoutFriends2Input
    upsert?: UserUpsertWithoutFriends2Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriends2Input, UserUpdateWithoutFriends2Input>, UserUncheckedUpdateWithoutFriends2Input>
  }

  export type ChatroomReadStatusCreateNestedManyWithoutChatroomInput = {
    create?: XOR<ChatroomReadStatusCreateWithoutChatroomInput, ChatroomReadStatusUncheckedCreateWithoutChatroomInput> | ChatroomReadStatusCreateWithoutChatroomInput[] | ChatroomReadStatusUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatroomReadStatusCreateOrConnectWithoutChatroomInput | ChatroomReadStatusCreateOrConnectWithoutChatroomInput[]
    createMany?: ChatroomReadStatusCreateManyChatroomInputEnvelope
    connect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
  }

  export type ChatroomMessageCreateNestedManyWithoutChatroomInput = {
    create?: XOR<ChatroomMessageCreateWithoutChatroomInput, ChatroomMessageUncheckedCreateWithoutChatroomInput> | ChatroomMessageCreateWithoutChatroomInput[] | ChatroomMessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutChatroomInput | ChatroomMessageCreateOrConnectWithoutChatroomInput[]
    createMany?: ChatroomMessageCreateManyChatroomInputEnvelope
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutChatroomsInput = {
    create?: XOR<UserCreateWithoutChatroomsInput, UserUncheckedCreateWithoutChatroomsInput> | UserCreateWithoutChatroomsInput[] | UserUncheckedCreateWithoutChatroomsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutChatroomsInput | UserCreateOrConnectWithoutChatroomsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ChatroomReadStatusUncheckedCreateNestedManyWithoutChatroomInput = {
    create?: XOR<ChatroomReadStatusCreateWithoutChatroomInput, ChatroomReadStatusUncheckedCreateWithoutChatroomInput> | ChatroomReadStatusCreateWithoutChatroomInput[] | ChatroomReadStatusUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatroomReadStatusCreateOrConnectWithoutChatroomInput | ChatroomReadStatusCreateOrConnectWithoutChatroomInput[]
    createMany?: ChatroomReadStatusCreateManyChatroomInputEnvelope
    connect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
  }

  export type ChatroomMessageUncheckedCreateNestedManyWithoutChatroomInput = {
    create?: XOR<ChatroomMessageCreateWithoutChatroomInput, ChatroomMessageUncheckedCreateWithoutChatroomInput> | ChatroomMessageCreateWithoutChatroomInput[] | ChatroomMessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutChatroomInput | ChatroomMessageCreateOrConnectWithoutChatroomInput[]
    createMany?: ChatroomMessageCreateManyChatroomInputEnvelope
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutChatroomsInput = {
    create?: XOR<UserCreateWithoutChatroomsInput, UserUncheckedCreateWithoutChatroomsInput> | UserCreateWithoutChatroomsInput[] | UserUncheckedCreateWithoutChatroomsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutChatroomsInput | UserCreateOrConnectWithoutChatroomsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ChatroomReadStatusUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<ChatroomReadStatusCreateWithoutChatroomInput, ChatroomReadStatusUncheckedCreateWithoutChatroomInput> | ChatroomReadStatusCreateWithoutChatroomInput[] | ChatroomReadStatusUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatroomReadStatusCreateOrConnectWithoutChatroomInput | ChatroomReadStatusCreateOrConnectWithoutChatroomInput[]
    upsert?: ChatroomReadStatusUpsertWithWhereUniqueWithoutChatroomInput | ChatroomReadStatusUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: ChatroomReadStatusCreateManyChatroomInputEnvelope
    set?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    disconnect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    delete?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    connect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    update?: ChatroomReadStatusUpdateWithWhereUniqueWithoutChatroomInput | ChatroomReadStatusUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: ChatroomReadStatusUpdateManyWithWhereWithoutChatroomInput | ChatroomReadStatusUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: ChatroomReadStatusScalarWhereInput | ChatroomReadStatusScalarWhereInput[]
  }

  export type ChatroomMessageUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<ChatroomMessageCreateWithoutChatroomInput, ChatroomMessageUncheckedCreateWithoutChatroomInput> | ChatroomMessageCreateWithoutChatroomInput[] | ChatroomMessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutChatroomInput | ChatroomMessageCreateOrConnectWithoutChatroomInput[]
    upsert?: ChatroomMessageUpsertWithWhereUniqueWithoutChatroomInput | ChatroomMessageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: ChatroomMessageCreateManyChatroomInputEnvelope
    set?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    disconnect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    delete?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    update?: ChatroomMessageUpdateWithWhereUniqueWithoutChatroomInput | ChatroomMessageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: ChatroomMessageUpdateManyWithWhereWithoutChatroomInput | ChatroomMessageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: ChatroomMessageScalarWhereInput | ChatroomMessageScalarWhereInput[]
  }

  export type UserUpdateManyWithoutChatroomsNestedInput = {
    create?: XOR<UserCreateWithoutChatroomsInput, UserUncheckedCreateWithoutChatroomsInput> | UserCreateWithoutChatroomsInput[] | UserUncheckedCreateWithoutChatroomsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutChatroomsInput | UserCreateOrConnectWithoutChatroomsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutChatroomsInput | UserUpsertWithWhereUniqueWithoutChatroomsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutChatroomsInput | UserUpdateWithWhereUniqueWithoutChatroomsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutChatroomsInput | UserUpdateManyWithWhereWithoutChatroomsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ChatroomReadStatusUncheckedUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<ChatroomReadStatusCreateWithoutChatroomInput, ChatroomReadStatusUncheckedCreateWithoutChatroomInput> | ChatroomReadStatusCreateWithoutChatroomInput[] | ChatroomReadStatusUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatroomReadStatusCreateOrConnectWithoutChatroomInput | ChatroomReadStatusCreateOrConnectWithoutChatroomInput[]
    upsert?: ChatroomReadStatusUpsertWithWhereUniqueWithoutChatroomInput | ChatroomReadStatusUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: ChatroomReadStatusCreateManyChatroomInputEnvelope
    set?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    disconnect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    delete?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    connect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    update?: ChatroomReadStatusUpdateWithWhereUniqueWithoutChatroomInput | ChatroomReadStatusUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: ChatroomReadStatusUpdateManyWithWhereWithoutChatroomInput | ChatroomReadStatusUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: ChatroomReadStatusScalarWhereInput | ChatroomReadStatusScalarWhereInput[]
  }

  export type ChatroomMessageUncheckedUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<ChatroomMessageCreateWithoutChatroomInput, ChatroomMessageUncheckedCreateWithoutChatroomInput> | ChatroomMessageCreateWithoutChatroomInput[] | ChatroomMessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutChatroomInput | ChatroomMessageCreateOrConnectWithoutChatroomInput[]
    upsert?: ChatroomMessageUpsertWithWhereUniqueWithoutChatroomInput | ChatroomMessageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: ChatroomMessageCreateManyChatroomInputEnvelope
    set?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    disconnect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    delete?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    update?: ChatroomMessageUpdateWithWhereUniqueWithoutChatroomInput | ChatroomMessageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: ChatroomMessageUpdateManyWithWhereWithoutChatroomInput | ChatroomMessageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: ChatroomMessageScalarWhereInput | ChatroomMessageScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutChatroomsNestedInput = {
    create?: XOR<UserCreateWithoutChatroomsInput, UserUncheckedCreateWithoutChatroomsInput> | UserCreateWithoutChatroomsInput[] | UserUncheckedCreateWithoutChatroomsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutChatroomsInput | UserCreateOrConnectWithoutChatroomsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutChatroomsInput | UserUpsertWithWhereUniqueWithoutChatroomsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutChatroomsInput | UserUpdateWithWhereUniqueWithoutChatroomsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutChatroomsInput | UserUpdateManyWithWhereWithoutChatroomsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ChatroomReadStatusCreateNestedManyWithoutMessageInput = {
    create?: XOR<ChatroomReadStatusCreateWithoutMessageInput, ChatroomReadStatusUncheckedCreateWithoutMessageInput> | ChatroomReadStatusCreateWithoutMessageInput[] | ChatroomReadStatusUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatroomReadStatusCreateOrConnectWithoutMessageInput | ChatroomReadStatusCreateOrConnectWithoutMessageInput[]
    createMany?: ChatroomReadStatusCreateManyMessageInputEnvelope
    connect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
  }

  export type ChatroomCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatroomCreateWithoutMessagesInput, ChatroomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatroomCreateOrConnectWithoutMessagesInput
    connect?: ChatroomWhereUniqueInput
  }

  export type ChatroomMessageCreateNestedOneWithoutChat_messageInput = {
    create?: XOR<ChatroomMessageCreateWithoutChat_messageInput, ChatroomMessageUncheckedCreateWithoutChat_messageInput>
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutChat_messageInput
    connect?: ChatroomMessageWhereUniqueInput
  }

  export type ChatroomMessageCreateNestedManyWithoutReplyInput = {
    create?: XOR<ChatroomMessageCreateWithoutReplyInput, ChatroomMessageUncheckedCreateWithoutReplyInput> | ChatroomMessageCreateWithoutReplyInput[] | ChatroomMessageUncheckedCreateWithoutReplyInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutReplyInput | ChatroomMessageCreateOrConnectWithoutReplyInput[]
    createMany?: ChatroomMessageCreateManyReplyInputEnvelope
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutChatroomMessageInput = {
    create?: XOR<UserCreateWithoutChatroomMessageInput, UserUncheckedCreateWithoutChatroomMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatroomMessageInput
    connect?: UserWhereUniqueInput
  }

  export type ChatroomReadStatusUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<ChatroomReadStatusCreateWithoutMessageInput, ChatroomReadStatusUncheckedCreateWithoutMessageInput> | ChatroomReadStatusCreateWithoutMessageInput[] | ChatroomReadStatusUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatroomReadStatusCreateOrConnectWithoutMessageInput | ChatroomReadStatusCreateOrConnectWithoutMessageInput[]
    createMany?: ChatroomReadStatusCreateManyMessageInputEnvelope
    connect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
  }

  export type ChatroomMessageUncheckedCreateNestedManyWithoutReplyInput = {
    create?: XOR<ChatroomMessageCreateWithoutReplyInput, ChatroomMessageUncheckedCreateWithoutReplyInput> | ChatroomMessageCreateWithoutReplyInput[] | ChatroomMessageUncheckedCreateWithoutReplyInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutReplyInput | ChatroomMessageCreateOrConnectWithoutReplyInput[]
    createMany?: ChatroomMessageCreateManyReplyInputEnvelope
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
  }

  export type EnumChatroomMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChatroomMessageStatus
  }

  export type EnumChatroomMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChatroomMessageType
  }

  export type NullableEnumCallMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.CallMessageStatus | null
  }

  export type ChatroomReadStatusUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ChatroomReadStatusCreateWithoutMessageInput, ChatroomReadStatusUncheckedCreateWithoutMessageInput> | ChatroomReadStatusCreateWithoutMessageInput[] | ChatroomReadStatusUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatroomReadStatusCreateOrConnectWithoutMessageInput | ChatroomReadStatusCreateOrConnectWithoutMessageInput[]
    upsert?: ChatroomReadStatusUpsertWithWhereUniqueWithoutMessageInput | ChatroomReadStatusUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ChatroomReadStatusCreateManyMessageInputEnvelope
    set?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    disconnect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    delete?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    connect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    update?: ChatroomReadStatusUpdateWithWhereUniqueWithoutMessageInput | ChatroomReadStatusUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ChatroomReadStatusUpdateManyWithWhereWithoutMessageInput | ChatroomReadStatusUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ChatroomReadStatusScalarWhereInput | ChatroomReadStatusScalarWhereInput[]
  }

  export type ChatroomUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatroomCreateWithoutMessagesInput, ChatroomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatroomCreateOrConnectWithoutMessagesInput
    upsert?: ChatroomUpsertWithoutMessagesInput
    connect?: ChatroomWhereUniqueInput
    update?: XOR<XOR<ChatroomUpdateToOneWithWhereWithoutMessagesInput, ChatroomUpdateWithoutMessagesInput>, ChatroomUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatroomMessageUpdateOneWithoutChat_messageNestedInput = {
    create?: XOR<ChatroomMessageCreateWithoutChat_messageInput, ChatroomMessageUncheckedCreateWithoutChat_messageInput>
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutChat_messageInput
    upsert?: ChatroomMessageUpsertWithoutChat_messageInput
    disconnect?: ChatroomMessageWhereInput | boolean
    delete?: ChatroomMessageWhereInput | boolean
    connect?: ChatroomMessageWhereUniqueInput
    update?: XOR<XOR<ChatroomMessageUpdateToOneWithWhereWithoutChat_messageInput, ChatroomMessageUpdateWithoutChat_messageInput>, ChatroomMessageUncheckedUpdateWithoutChat_messageInput>
  }

  export type ChatroomMessageUpdateManyWithoutReplyNestedInput = {
    create?: XOR<ChatroomMessageCreateWithoutReplyInput, ChatroomMessageUncheckedCreateWithoutReplyInput> | ChatroomMessageCreateWithoutReplyInput[] | ChatroomMessageUncheckedCreateWithoutReplyInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutReplyInput | ChatroomMessageCreateOrConnectWithoutReplyInput[]
    upsert?: ChatroomMessageUpsertWithWhereUniqueWithoutReplyInput | ChatroomMessageUpsertWithWhereUniqueWithoutReplyInput[]
    createMany?: ChatroomMessageCreateManyReplyInputEnvelope
    set?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    disconnect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    delete?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    update?: ChatroomMessageUpdateWithWhereUniqueWithoutReplyInput | ChatroomMessageUpdateWithWhereUniqueWithoutReplyInput[]
    updateMany?: ChatroomMessageUpdateManyWithWhereWithoutReplyInput | ChatroomMessageUpdateManyWithWhereWithoutReplyInput[]
    deleteMany?: ChatroomMessageScalarWhereInput | ChatroomMessageScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutChatroomMessageNestedInput = {
    create?: XOR<UserCreateWithoutChatroomMessageInput, UserUncheckedCreateWithoutChatroomMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatroomMessageInput
    upsert?: UserUpsertWithoutChatroomMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatroomMessageInput, UserUpdateWithoutChatroomMessageInput>, UserUncheckedUpdateWithoutChatroomMessageInput>
  }

  export type ChatroomReadStatusUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ChatroomReadStatusCreateWithoutMessageInput, ChatroomReadStatusUncheckedCreateWithoutMessageInput> | ChatroomReadStatusCreateWithoutMessageInput[] | ChatroomReadStatusUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatroomReadStatusCreateOrConnectWithoutMessageInput | ChatroomReadStatusCreateOrConnectWithoutMessageInput[]
    upsert?: ChatroomReadStatusUpsertWithWhereUniqueWithoutMessageInput | ChatroomReadStatusUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ChatroomReadStatusCreateManyMessageInputEnvelope
    set?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    disconnect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    delete?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    connect?: ChatroomReadStatusWhereUniqueInput | ChatroomReadStatusWhereUniqueInput[]
    update?: ChatroomReadStatusUpdateWithWhereUniqueWithoutMessageInput | ChatroomReadStatusUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ChatroomReadStatusUpdateManyWithWhereWithoutMessageInput | ChatroomReadStatusUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ChatroomReadStatusScalarWhereInput | ChatroomReadStatusScalarWhereInput[]
  }

  export type ChatroomMessageUncheckedUpdateManyWithoutReplyNestedInput = {
    create?: XOR<ChatroomMessageCreateWithoutReplyInput, ChatroomMessageUncheckedCreateWithoutReplyInput> | ChatroomMessageCreateWithoutReplyInput[] | ChatroomMessageUncheckedCreateWithoutReplyInput[]
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutReplyInput | ChatroomMessageCreateOrConnectWithoutReplyInput[]
    upsert?: ChatroomMessageUpsertWithWhereUniqueWithoutReplyInput | ChatroomMessageUpsertWithWhereUniqueWithoutReplyInput[]
    createMany?: ChatroomMessageCreateManyReplyInputEnvelope
    set?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    disconnect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    delete?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    connect?: ChatroomMessageWhereUniqueInput | ChatroomMessageWhereUniqueInput[]
    update?: ChatroomMessageUpdateWithWhereUniqueWithoutReplyInput | ChatroomMessageUpdateWithWhereUniqueWithoutReplyInput[]
    updateMany?: ChatroomMessageUpdateManyWithWhereWithoutReplyInput | ChatroomMessageUpdateManyWithWhereWithoutReplyInput[]
    deleteMany?: ChatroomMessageScalarWhereInput | ChatroomMessageScalarWhereInput[]
  }

  export type ChatroomCreateNestedOneWithoutReadStatusesInput = {
    create?: XOR<ChatroomCreateWithoutReadStatusesInput, ChatroomUncheckedCreateWithoutReadStatusesInput>
    connectOrCreate?: ChatroomCreateOrConnectWithoutReadStatusesInput
    connect?: ChatroomWhereUniqueInput
  }

  export type ChatroomMessageCreateNestedOneWithoutReadByInput = {
    create?: XOR<ChatroomMessageCreateWithoutReadByInput, ChatroomMessageUncheckedCreateWithoutReadByInput>
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutReadByInput
    connect?: ChatroomMessageWhereUniqueInput
  }

  export type ChatroomUpdateOneRequiredWithoutReadStatusesNestedInput = {
    create?: XOR<ChatroomCreateWithoutReadStatusesInput, ChatroomUncheckedCreateWithoutReadStatusesInput>
    connectOrCreate?: ChatroomCreateOrConnectWithoutReadStatusesInput
    upsert?: ChatroomUpsertWithoutReadStatusesInput
    connect?: ChatroomWhereUniqueInput
    update?: XOR<XOR<ChatroomUpdateToOneWithWhereWithoutReadStatusesInput, ChatroomUpdateWithoutReadStatusesInput>, ChatroomUncheckedUpdateWithoutReadStatusesInput>
  }

  export type ChatroomMessageUpdateOneRequiredWithoutReadByNestedInput = {
    create?: XOR<ChatroomMessageCreateWithoutReadByInput, ChatroomMessageUncheckedCreateWithoutReadByInput>
    connectOrCreate?: ChatroomMessageCreateOrConnectWithoutReadByInput
    upsert?: ChatroomMessageUpsertWithoutReadByInput
    connect?: ChatroomMessageWhereUniqueInput
    update?: XOR<XOR<ChatroomMessageUpdateToOneWithWhereWithoutReadByInput, ChatroomMessageUpdateWithoutReadByInput>, ChatroomMessageUncheckedUpdateWithoutReadByInput>
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type MediaAttachmentCreateNestedManyWithoutPostInput = {
    create?: XOR<MediaAttachmentCreateWithoutPostInput, MediaAttachmentUncheckedCreateWithoutPostInput> | MediaAttachmentCreateWithoutPostInput[] | MediaAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaAttachmentCreateOrConnectWithoutPostInput | MediaAttachmentCreateOrConnectWithoutPostInput[]
    createMany?: MediaAttachmentCreateManyPostInputEnvelope
    connect?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostViewStatusCreateNestedManyWithoutPostInput = {
    create?: XOR<PostViewStatusCreateWithoutPostInput, PostViewStatusUncheckedCreateWithoutPostInput> | PostViewStatusCreateWithoutPostInput[] | PostViewStatusUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostViewStatusCreateOrConnectWithoutPostInput | PostViewStatusCreateOrConnectWithoutPostInput[]
    createMany?: PostViewStatusCreateManyPostInputEnvelope
    connect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type MediaAttachmentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<MediaAttachmentCreateWithoutPostInput, MediaAttachmentUncheckedCreateWithoutPostInput> | MediaAttachmentCreateWithoutPostInput[] | MediaAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaAttachmentCreateOrConnectWithoutPostInput | MediaAttachmentCreateOrConnectWithoutPostInput[]
    createMany?: MediaAttachmentCreateManyPostInputEnvelope
    connect?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
  }

  export type PostViewStatusUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostViewStatusCreateWithoutPostInput, PostViewStatusUncheckedCreateWithoutPostInput> | PostViewStatusCreateWithoutPostInput[] | PostViewStatusUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostViewStatusCreateOrConnectWithoutPostInput | PostViewStatusCreateOrConnectWithoutPostInput[]
    createMany?: PostViewStatusCreateManyPostInputEnvelope
    connect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type MediaAttachmentUpdateManyWithoutPostNestedInput = {
    create?: XOR<MediaAttachmentCreateWithoutPostInput, MediaAttachmentUncheckedCreateWithoutPostInput> | MediaAttachmentCreateWithoutPostInput[] | MediaAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaAttachmentCreateOrConnectWithoutPostInput | MediaAttachmentCreateOrConnectWithoutPostInput[]
    upsert?: MediaAttachmentUpsertWithWhereUniqueWithoutPostInput | MediaAttachmentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: MediaAttachmentCreateManyPostInputEnvelope
    set?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
    disconnect?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
    delete?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
    connect?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
    update?: MediaAttachmentUpdateWithWhereUniqueWithoutPostInput | MediaAttachmentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: MediaAttachmentUpdateManyWithWhereWithoutPostInput | MediaAttachmentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: MediaAttachmentScalarWhereInput | MediaAttachmentScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type PostViewStatusUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostViewStatusCreateWithoutPostInput, PostViewStatusUncheckedCreateWithoutPostInput> | PostViewStatusCreateWithoutPostInput[] | PostViewStatusUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostViewStatusCreateOrConnectWithoutPostInput | PostViewStatusCreateOrConnectWithoutPostInput[]
    upsert?: PostViewStatusUpsertWithWhereUniqueWithoutPostInput | PostViewStatusUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostViewStatusCreateManyPostInputEnvelope
    set?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    disconnect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    delete?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    connect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    update?: PostViewStatusUpdateWithWhereUniqueWithoutPostInput | PostViewStatusUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostViewStatusUpdateManyWithWhereWithoutPostInput | PostViewStatusUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostViewStatusScalarWhereInput | PostViewStatusScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type MediaAttachmentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<MediaAttachmentCreateWithoutPostInput, MediaAttachmentUncheckedCreateWithoutPostInput> | MediaAttachmentCreateWithoutPostInput[] | MediaAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaAttachmentCreateOrConnectWithoutPostInput | MediaAttachmentCreateOrConnectWithoutPostInput[]
    upsert?: MediaAttachmentUpsertWithWhereUniqueWithoutPostInput | MediaAttachmentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: MediaAttachmentCreateManyPostInputEnvelope
    set?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
    disconnect?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
    delete?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
    connect?: MediaAttachmentWhereUniqueInput | MediaAttachmentWhereUniqueInput[]
    update?: MediaAttachmentUpdateWithWhereUniqueWithoutPostInput | MediaAttachmentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: MediaAttachmentUpdateManyWithWhereWithoutPostInput | MediaAttachmentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: MediaAttachmentScalarWhereInput | MediaAttachmentScalarWhereInput[]
  }

  export type PostViewStatusUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostViewStatusCreateWithoutPostInput, PostViewStatusUncheckedCreateWithoutPostInput> | PostViewStatusCreateWithoutPostInput[] | PostViewStatusUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostViewStatusCreateOrConnectWithoutPostInput | PostViewStatusCreateOrConnectWithoutPostInput[]
    upsert?: PostViewStatusUpsertWithWhereUniqueWithoutPostInput | PostViewStatusUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostViewStatusCreateManyPostInputEnvelope
    set?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    disconnect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    delete?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    connect?: PostViewStatusWhereUniqueInput | PostViewStatusWhereUniqueInput[]
    update?: PostViewStatusUpdateWithWhereUniqueWithoutPostInput | PostViewStatusUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostViewStatusUpdateManyWithWhereWithoutPostInput | PostViewStatusUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostViewStatusScalarWhereInput | PostViewStatusScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutMediaAttachmentsInput = {
    create?: XOR<PostCreateWithoutMediaAttachmentsInput, PostUncheckedCreateWithoutMediaAttachmentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutMediaAttachmentsInput
    connect?: PostWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type PostUpdateOneRequiredWithoutMediaAttachmentsNestedInput = {
    create?: XOR<PostCreateWithoutMediaAttachmentsInput, PostUncheckedCreateWithoutMediaAttachmentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutMediaAttachmentsInput
    upsert?: PostUpsertWithoutMediaAttachmentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutMediaAttachmentsInput, PostUpdateWithoutMediaAttachmentsInput>, PostUncheckedUpdateWithoutMediaAttachmentsInput>
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type PostCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    upsert?: PostUpsertWithoutLikesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutLikesInput, PostUpdateWithoutLikesInput>, PostUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    upsert?: UserUpsertWithoutLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesInput, UserUpdateWithoutLikesInput>, UserUncheckedUpdateWithoutLikesInput>
  }

  export type HelpReadStatusCreateNestedManyWithoutHelpInput = {
    create?: XOR<HelpReadStatusCreateWithoutHelpInput, HelpReadStatusUncheckedCreateWithoutHelpInput> | HelpReadStatusCreateWithoutHelpInput[] | HelpReadStatusUncheckedCreateWithoutHelpInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutHelpInput | HelpReadStatusCreateOrConnectWithoutHelpInput[]
    createMany?: HelpReadStatusCreateManyHelpInputEnvelope
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
  }

  export type HelpMessageCreateNestedManyWithoutHelpInput = {
    create?: XOR<HelpMessageCreateWithoutHelpInput, HelpMessageUncheckedCreateWithoutHelpInput> | HelpMessageCreateWithoutHelpInput[] | HelpMessageUncheckedCreateWithoutHelpInput[]
    connectOrCreate?: HelpMessageCreateOrConnectWithoutHelpInput | HelpMessageCreateOrConnectWithoutHelpInput[]
    createMany?: HelpMessageCreateManyHelpInputEnvelope
    connect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutHelperInput = {
    create?: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelperInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestedHelpInput = {
    create?: XOR<UserCreateWithoutRequestedHelpInput, UserUncheckedCreateWithoutRequestedHelpInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestedHelpInput
    connect?: UserWhereUniqueInput
  }

  export type HelpReadStatusUncheckedCreateNestedManyWithoutHelpInput = {
    create?: XOR<HelpReadStatusCreateWithoutHelpInput, HelpReadStatusUncheckedCreateWithoutHelpInput> | HelpReadStatusCreateWithoutHelpInput[] | HelpReadStatusUncheckedCreateWithoutHelpInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutHelpInput | HelpReadStatusCreateOrConnectWithoutHelpInput[]
    createMany?: HelpReadStatusCreateManyHelpInputEnvelope
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
  }

  export type HelpMessageUncheckedCreateNestedManyWithoutHelpInput = {
    create?: XOR<HelpMessageCreateWithoutHelpInput, HelpMessageUncheckedCreateWithoutHelpInput> | HelpMessageCreateWithoutHelpInput[] | HelpMessageUncheckedCreateWithoutHelpInput[]
    connectOrCreate?: HelpMessageCreateOrConnectWithoutHelpInput | HelpMessageCreateOrConnectWithoutHelpInput[]
    createMany?: HelpMessageCreateManyHelpInputEnvelope
    connect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
  }

  export type EnumHelpStatusFieldUpdateOperationsInput = {
    set?: $Enums.HelpStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HelpReadStatusUpdateManyWithoutHelpNestedInput = {
    create?: XOR<HelpReadStatusCreateWithoutHelpInput, HelpReadStatusUncheckedCreateWithoutHelpInput> | HelpReadStatusCreateWithoutHelpInput[] | HelpReadStatusUncheckedCreateWithoutHelpInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutHelpInput | HelpReadStatusCreateOrConnectWithoutHelpInput[]
    upsert?: HelpReadStatusUpsertWithWhereUniqueWithoutHelpInput | HelpReadStatusUpsertWithWhereUniqueWithoutHelpInput[]
    createMany?: HelpReadStatusCreateManyHelpInputEnvelope
    set?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    disconnect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    delete?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    update?: HelpReadStatusUpdateWithWhereUniqueWithoutHelpInput | HelpReadStatusUpdateWithWhereUniqueWithoutHelpInput[]
    updateMany?: HelpReadStatusUpdateManyWithWhereWithoutHelpInput | HelpReadStatusUpdateManyWithWhereWithoutHelpInput[]
    deleteMany?: HelpReadStatusScalarWhereInput | HelpReadStatusScalarWhereInput[]
  }

  export type HelpMessageUpdateManyWithoutHelpNestedInput = {
    create?: XOR<HelpMessageCreateWithoutHelpInput, HelpMessageUncheckedCreateWithoutHelpInput> | HelpMessageCreateWithoutHelpInput[] | HelpMessageUncheckedCreateWithoutHelpInput[]
    connectOrCreate?: HelpMessageCreateOrConnectWithoutHelpInput | HelpMessageCreateOrConnectWithoutHelpInput[]
    upsert?: HelpMessageUpsertWithWhereUniqueWithoutHelpInput | HelpMessageUpsertWithWhereUniqueWithoutHelpInput[]
    createMany?: HelpMessageCreateManyHelpInputEnvelope
    set?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    disconnect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    delete?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    connect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    update?: HelpMessageUpdateWithWhereUniqueWithoutHelpInput | HelpMessageUpdateWithWhereUniqueWithoutHelpInput[]
    updateMany?: HelpMessageUpdateManyWithWhereWithoutHelpInput | HelpMessageUpdateManyWithWhereWithoutHelpInput[]
    deleteMany?: HelpMessageScalarWhereInput | HelpMessageScalarWhereInput[]
  }

  export type UserUpdateOneWithoutHelperNestedInput = {
    create?: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelperInput
    upsert?: UserUpsertWithoutHelperInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHelperInput, UserUpdateWithoutHelperInput>, UserUncheckedUpdateWithoutHelperInput>
  }

  export type UserUpdateOneRequiredWithoutRequestedHelpNestedInput = {
    create?: XOR<UserCreateWithoutRequestedHelpInput, UserUncheckedCreateWithoutRequestedHelpInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestedHelpInput
    upsert?: UserUpsertWithoutRequestedHelpInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestedHelpInput, UserUpdateWithoutRequestedHelpInput>, UserUncheckedUpdateWithoutRequestedHelpInput>
  }

  export type HelpReadStatusUncheckedUpdateManyWithoutHelpNestedInput = {
    create?: XOR<HelpReadStatusCreateWithoutHelpInput, HelpReadStatusUncheckedCreateWithoutHelpInput> | HelpReadStatusCreateWithoutHelpInput[] | HelpReadStatusUncheckedCreateWithoutHelpInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutHelpInput | HelpReadStatusCreateOrConnectWithoutHelpInput[]
    upsert?: HelpReadStatusUpsertWithWhereUniqueWithoutHelpInput | HelpReadStatusUpsertWithWhereUniqueWithoutHelpInput[]
    createMany?: HelpReadStatusCreateManyHelpInputEnvelope
    set?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    disconnect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    delete?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    update?: HelpReadStatusUpdateWithWhereUniqueWithoutHelpInput | HelpReadStatusUpdateWithWhereUniqueWithoutHelpInput[]
    updateMany?: HelpReadStatusUpdateManyWithWhereWithoutHelpInput | HelpReadStatusUpdateManyWithWhereWithoutHelpInput[]
    deleteMany?: HelpReadStatusScalarWhereInput | HelpReadStatusScalarWhereInput[]
  }

  export type HelpMessageUncheckedUpdateManyWithoutHelpNestedInput = {
    create?: XOR<HelpMessageCreateWithoutHelpInput, HelpMessageUncheckedCreateWithoutHelpInput> | HelpMessageCreateWithoutHelpInput[] | HelpMessageUncheckedCreateWithoutHelpInput[]
    connectOrCreate?: HelpMessageCreateOrConnectWithoutHelpInput | HelpMessageCreateOrConnectWithoutHelpInput[]
    upsert?: HelpMessageUpsertWithWhereUniqueWithoutHelpInput | HelpMessageUpsertWithWhereUniqueWithoutHelpInput[]
    createMany?: HelpMessageCreateManyHelpInputEnvelope
    set?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    disconnect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    delete?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    connect?: HelpMessageWhereUniqueInput | HelpMessageWhereUniqueInput[]
    update?: HelpMessageUpdateWithWhereUniqueWithoutHelpInput | HelpMessageUpdateWithWhereUniqueWithoutHelpInput[]
    updateMany?: HelpMessageUpdateManyWithWhereWithoutHelpInput | HelpMessageUpdateManyWithWhereWithoutHelpInput[]
    deleteMany?: HelpMessageScalarWhereInput | HelpMessageScalarWhereInput[]
  }

  export type HelpReadStatusCreateNestedManyWithoutHelpMessageInput = {
    create?: XOR<HelpReadStatusCreateWithoutHelpMessageInput, HelpReadStatusUncheckedCreateWithoutHelpMessageInput> | HelpReadStatusCreateWithoutHelpMessageInput[] | HelpReadStatusUncheckedCreateWithoutHelpMessageInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutHelpMessageInput | HelpReadStatusCreateOrConnectWithoutHelpMessageInput[]
    createMany?: HelpReadStatusCreateManyHelpMessageInputEnvelope
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
  }

  export type HelpCreateNestedOneWithoutMessagesInput = {
    create?: XOR<HelpCreateWithoutMessagesInput, HelpUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: HelpCreateOrConnectWithoutMessagesInput
    connect?: HelpWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHelp_messagesInput = {
    create?: XOR<UserCreateWithoutHelp_messagesInput, UserUncheckedCreateWithoutHelp_messagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelp_messagesInput
    connect?: UserWhereUniqueInput
  }

  export type HelpReadStatusUncheckedCreateNestedManyWithoutHelpMessageInput = {
    create?: XOR<HelpReadStatusCreateWithoutHelpMessageInput, HelpReadStatusUncheckedCreateWithoutHelpMessageInput> | HelpReadStatusCreateWithoutHelpMessageInput[] | HelpReadStatusUncheckedCreateWithoutHelpMessageInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutHelpMessageInput | HelpReadStatusCreateOrConnectWithoutHelpMessageInput[]
    createMany?: HelpReadStatusCreateManyHelpMessageInputEnvelope
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
  }

  export type HelpReadStatusUpdateManyWithoutHelpMessageNestedInput = {
    create?: XOR<HelpReadStatusCreateWithoutHelpMessageInput, HelpReadStatusUncheckedCreateWithoutHelpMessageInput> | HelpReadStatusCreateWithoutHelpMessageInput[] | HelpReadStatusUncheckedCreateWithoutHelpMessageInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutHelpMessageInput | HelpReadStatusCreateOrConnectWithoutHelpMessageInput[]
    upsert?: HelpReadStatusUpsertWithWhereUniqueWithoutHelpMessageInput | HelpReadStatusUpsertWithWhereUniqueWithoutHelpMessageInput[]
    createMany?: HelpReadStatusCreateManyHelpMessageInputEnvelope
    set?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    disconnect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    delete?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    update?: HelpReadStatusUpdateWithWhereUniqueWithoutHelpMessageInput | HelpReadStatusUpdateWithWhereUniqueWithoutHelpMessageInput[]
    updateMany?: HelpReadStatusUpdateManyWithWhereWithoutHelpMessageInput | HelpReadStatusUpdateManyWithWhereWithoutHelpMessageInput[]
    deleteMany?: HelpReadStatusScalarWhereInput | HelpReadStatusScalarWhereInput[]
  }

  export type HelpUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<HelpCreateWithoutMessagesInput, HelpUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: HelpCreateOrConnectWithoutMessagesInput
    upsert?: HelpUpsertWithoutMessagesInput
    connect?: HelpWhereUniqueInput
    update?: XOR<XOR<HelpUpdateToOneWithWhereWithoutMessagesInput, HelpUpdateWithoutMessagesInput>, HelpUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutHelp_messagesNestedInput = {
    create?: XOR<UserCreateWithoutHelp_messagesInput, UserUncheckedCreateWithoutHelp_messagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelp_messagesInput
    upsert?: UserUpsertWithoutHelp_messagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHelp_messagesInput, UserUpdateWithoutHelp_messagesInput>, UserUncheckedUpdateWithoutHelp_messagesInput>
  }

  export type HelpReadStatusUncheckedUpdateManyWithoutHelpMessageNestedInput = {
    create?: XOR<HelpReadStatusCreateWithoutHelpMessageInput, HelpReadStatusUncheckedCreateWithoutHelpMessageInput> | HelpReadStatusCreateWithoutHelpMessageInput[] | HelpReadStatusUncheckedCreateWithoutHelpMessageInput[]
    connectOrCreate?: HelpReadStatusCreateOrConnectWithoutHelpMessageInput | HelpReadStatusCreateOrConnectWithoutHelpMessageInput[]
    upsert?: HelpReadStatusUpsertWithWhereUniqueWithoutHelpMessageInput | HelpReadStatusUpsertWithWhereUniqueWithoutHelpMessageInput[]
    createMany?: HelpReadStatusCreateManyHelpMessageInputEnvelope
    set?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    disconnect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    delete?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    connect?: HelpReadStatusWhereUniqueInput | HelpReadStatusWhereUniqueInput[]
    update?: HelpReadStatusUpdateWithWhereUniqueWithoutHelpMessageInput | HelpReadStatusUpdateWithWhereUniqueWithoutHelpMessageInput[]
    updateMany?: HelpReadStatusUpdateManyWithWhereWithoutHelpMessageInput | HelpReadStatusUpdateManyWithWhereWithoutHelpMessageInput[]
    deleteMany?: HelpReadStatusScalarWhereInput | HelpReadStatusScalarWhereInput[]
  }

  export type HelpCreateNestedOneWithoutHelpReadStatusInput = {
    create?: XOR<HelpCreateWithoutHelpReadStatusInput, HelpUncheckedCreateWithoutHelpReadStatusInput>
    connectOrCreate?: HelpCreateOrConnectWithoutHelpReadStatusInput
    connect?: HelpWhereUniqueInput
  }

  export type HelpMessageCreateNestedOneWithoutReadByInput = {
    create?: XOR<HelpMessageCreateWithoutReadByInput, HelpMessageUncheckedCreateWithoutReadByInput>
    connectOrCreate?: HelpMessageCreateOrConnectWithoutReadByInput
    connect?: HelpMessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHelpReadStatusInput = {
    create?: XOR<UserCreateWithoutHelpReadStatusInput, UserUncheckedCreateWithoutHelpReadStatusInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelpReadStatusInput
    connect?: UserWhereUniqueInput
  }

  export type HelpUpdateOneRequiredWithoutHelpReadStatusNestedInput = {
    create?: XOR<HelpCreateWithoutHelpReadStatusInput, HelpUncheckedCreateWithoutHelpReadStatusInput>
    connectOrCreate?: HelpCreateOrConnectWithoutHelpReadStatusInput
    upsert?: HelpUpsertWithoutHelpReadStatusInput
    connect?: HelpWhereUniqueInput
    update?: XOR<XOR<HelpUpdateToOneWithWhereWithoutHelpReadStatusInput, HelpUpdateWithoutHelpReadStatusInput>, HelpUncheckedUpdateWithoutHelpReadStatusInput>
  }

  export type HelpMessageUpdateOneWithoutReadByNestedInput = {
    create?: XOR<HelpMessageCreateWithoutReadByInput, HelpMessageUncheckedCreateWithoutReadByInput>
    connectOrCreate?: HelpMessageCreateOrConnectWithoutReadByInput
    upsert?: HelpMessageUpsertWithoutReadByInput
    disconnect?: HelpMessageWhereInput | boolean
    delete?: HelpMessageWhereInput | boolean
    connect?: HelpMessageWhereUniqueInput
    update?: XOR<XOR<HelpMessageUpdateToOneWithWhereWithoutReadByInput, HelpMessageUpdateWithoutReadByInput>, HelpMessageUncheckedUpdateWithoutReadByInput>
  }

  export type UserUpdateOneRequiredWithoutHelpReadStatusNestedInput = {
    create?: XOR<UserCreateWithoutHelpReadStatusInput, UserUncheckedCreateWithoutHelpReadStatusInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelpReadStatusInput
    upsert?: UserUpsertWithoutHelpReadStatusInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHelpReadStatusInput, UserUpdateWithoutHelpReadStatusInput>, UserUncheckedUpdateWithoutHelpReadStatusInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type PostCreateNestedOneWithoutViewStatusInput = {
    create?: XOR<PostCreateWithoutViewStatusInput, PostUncheckedCreateWithoutViewStatusInput>
    connectOrCreate?: PostCreateOrConnectWithoutViewStatusInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostViewsInput = {
    create?: XOR<UserCreateWithoutPostViewsInput, UserUncheckedCreateWithoutPostViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostViewsInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutViewStatusNestedInput = {
    create?: XOR<PostCreateWithoutViewStatusInput, PostUncheckedCreateWithoutViewStatusInput>
    connectOrCreate?: PostCreateOrConnectWithoutViewStatusInput
    upsert?: PostUpsertWithoutViewStatusInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutViewStatusInput, PostUpdateWithoutViewStatusInput>, PostUncheckedUpdateWithoutViewStatusInput>
  }

  export type UserUpdateOneRequiredWithoutPostViewsNestedInput = {
    create?: XOR<UserCreateWithoutPostViewsInput, UserUncheckedCreateWithoutPostViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostViewsInput
    upsert?: UserUpsertWithoutPostViewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostViewsInput, UserUpdateWithoutPostViewsInput>, UserUncheckedUpdateWithoutPostViewsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserMoodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserMoodType | EnumUserMoodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserMoodType[] | ListEnumUserMoodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserMoodType[] | ListEnumUserMoodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserMoodTypeFilter<$PrismaModel> | $Enums.UserMoodType
  }

  export type NestedEnumUserMoodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserMoodType | EnumUserMoodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserMoodType[] | ListEnumUserMoodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserMoodType[] | ListEnumUserMoodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserMoodTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserMoodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserMoodTypeFilter<$PrismaModel>
    _max?: NestedEnumUserMoodTypeFilter<$PrismaModel>
  }

  export type NestedEnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type NestedEnumChatroomMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatroomMessageStatus | EnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatroomMessageStatus[] | ListEnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatroomMessageStatus[] | ListEnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatroomMessageStatusFilter<$PrismaModel> | $Enums.ChatroomMessageStatus
  }

  export type NestedEnumChatroomMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatroomMessageType | EnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatroomMessageType[] | ListEnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatroomMessageType[] | ListEnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatroomMessageTypeFilter<$PrismaModel> | $Enums.ChatroomMessageType
  }

  export type NestedEnumCallMessageStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CallMessageStatus | EnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallMessageStatus[] | ListEnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallMessageStatus[] | ListEnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallMessageStatusNullableFilter<$PrismaModel> | $Enums.CallMessageStatus | null
  }

  export type NestedEnumChatroomMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatroomMessageStatus | EnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatroomMessageStatus[] | ListEnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatroomMessageStatus[] | ListEnumChatroomMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatroomMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChatroomMessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatroomMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumChatroomMessageStatusFilter<$PrismaModel>
  }

  export type NestedEnumChatroomMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatroomMessageType | EnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatroomMessageType[] | ListEnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatroomMessageType[] | ListEnumChatroomMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatroomMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChatroomMessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatroomMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumChatroomMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumCallMessageStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallMessageStatus | EnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallMessageStatus[] | ListEnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallMessageStatus[] | ListEnumCallMessageStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallMessageStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CallMessageStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCallMessageStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCallMessageStatusNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumHelpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HelpStatus | EnumHelpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HelpStatus[] | ListEnumHelpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HelpStatus[] | ListEnumHelpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHelpStatusFilter<$PrismaModel> | $Enums.HelpStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumHelpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HelpStatus | EnumHelpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HelpStatus[] | ListEnumHelpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HelpStatus[] | ListEnumHelpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHelpStatusWithAggregatesFilter<$PrismaModel> | $Enums.HelpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHelpStatusFilter<$PrismaModel>
    _max?: NestedEnumHelpStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    text: string
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    text: string
    postId: string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HelpReadStatusCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    help: HelpCreateNestedOneWithoutHelpReadStatusInput
    helpMessage?: HelpMessageCreateNestedOneWithoutReadByInput
  }

  export type HelpReadStatusUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    helpId: string
    helpMessageId?: string | null
  }

  export type HelpReadStatusCreateOrConnectWithoutUserInput = {
    where: HelpReadStatusWhereUniqueInput
    create: XOR<HelpReadStatusCreateWithoutUserInput, HelpReadStatusUncheckedCreateWithoutUserInput>
  }

  export type HelpReadStatusCreateManyUserInputEnvelope = {
    data: HelpReadStatusCreateManyUserInput | HelpReadStatusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
  }

  export type LikeCreateOrConnectWithoutUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeCreateManyUserInputEnvelope = {
    data: LikeCreateManyUserInput | LikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    total_likes?: number
    total_comments?: number
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentCreateNestedManyWithoutPostInput
    viewStatus?: PostViewStatusCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    total_likes?: number
    total_comments?: number
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentUncheckedCreateNestedManyWithoutPostInput
    viewStatus?: PostViewStatusUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: PostCreateManyUserInput | PostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatroomMessageCreateWithoutSenderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusCreateNestedManyWithoutMessageInput
    chatroom: ChatroomCreateNestedOneWithoutMessagesInput
    reply?: ChatroomMessageCreateNestedOneWithoutChat_messageInput
    chat_message?: ChatroomMessageCreateNestedManyWithoutReplyInput
  }

  export type ChatroomMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatroomId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    reply_id?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusUncheckedCreateNestedManyWithoutMessageInput
    chat_message?: ChatroomMessageUncheckedCreateNestedManyWithoutReplyInput
  }

  export type ChatroomMessageCreateOrConnectWithoutSenderInput = {
    where: ChatroomMessageWhereUniqueInput
    create: XOR<ChatroomMessageCreateWithoutSenderInput, ChatroomMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatroomMessageCreateManySenderInputEnvelope = {
    data: ChatroomMessageCreateManySenderInput | ChatroomMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutUser1Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.FriendshipStatus
    user2: UserCreateNestedOneWithoutFriends2Input
  }

  export type FriendshipUncheckedCreateWithoutUser1Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.FriendshipStatus
    user2Id: string
  }

  export type FriendshipCreateOrConnectWithoutUser1Input = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutUser1Input, FriendshipUncheckedCreateWithoutUser1Input>
  }

  export type FriendshipCreateManyUser1InputEnvelope = {
    data: FriendshipCreateManyUser1Input | FriendshipCreateManyUser1Input[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutUser2Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.FriendshipStatus
    user1: UserCreateNestedOneWithoutFriends1Input
  }

  export type FriendshipUncheckedCreateWithoutUser2Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.FriendshipStatus
    user1Id: string
  }

  export type FriendshipCreateOrConnectWithoutUser2Input = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutUser2Input, FriendshipUncheckedCreateWithoutUser2Input>
  }

  export type FriendshipCreateManyUser2InputEnvelope = {
    data: FriendshipCreateManyUser2Input | FriendshipCreateManyUser2Input[]
    skipDuplicates?: boolean
  }

  export type HelpMessageCreateWithoutSenderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
    readBy?: HelpReadStatusCreateNestedManyWithoutHelpMessageInput
    help: HelpCreateNestedOneWithoutMessagesInput
  }

  export type HelpMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    helpId: string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
    readBy?: HelpReadStatusUncheckedCreateNestedManyWithoutHelpMessageInput
  }

  export type HelpMessageCreateOrConnectWithoutSenderInput = {
    where: HelpMessageWhereUniqueInput
    create: XOR<HelpMessageCreateWithoutSenderInput, HelpMessageUncheckedCreateWithoutSenderInput>
  }

  export type HelpMessageCreateManySenderInputEnvelope = {
    data: HelpMessageCreateManySenderInput | HelpMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type HelpCreateWithoutHelperInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutHelpInput
    messages?: HelpMessageCreateNestedManyWithoutHelpInput
    requestedBy: UserCreateNestedOneWithoutRequestedHelpInput
  }

  export type HelpUncheckedCreateWithoutHelperInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    requestedById: string
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutHelpInput
    messages?: HelpMessageUncheckedCreateNestedManyWithoutHelpInput
  }

  export type HelpCreateOrConnectWithoutHelperInput = {
    where: HelpWhereUniqueInput
    create: XOR<HelpCreateWithoutHelperInput, HelpUncheckedCreateWithoutHelperInput>
  }

  export type HelpCreateManyHelperInputEnvelope = {
    data: HelpCreateManyHelperInput | HelpCreateManyHelperInput[]
    skipDuplicates?: boolean
  }

  export type HelpCreateWithoutRequestedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutHelpInput
    messages?: HelpMessageCreateNestedManyWithoutHelpInput
    helper?: UserCreateNestedOneWithoutHelperInput
  }

  export type HelpUncheckedCreateWithoutRequestedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    helperId?: string | null
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutHelpInput
    messages?: HelpMessageUncheckedCreateNestedManyWithoutHelpInput
  }

  export type HelpCreateOrConnectWithoutRequestedByInput = {
    where: HelpWhereUniqueInput
    create: XOR<HelpCreateWithoutRequestedByInput, HelpUncheckedCreateWithoutRequestedByInput>
  }

  export type HelpCreateManyRequestedByInputEnvelope = {
    data: HelpCreateManyRequestedByInput | HelpCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    type: string
    content: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type notificationsUncheckedCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    type: string
    content: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type notificationsCreateOrConnectWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsCreateManyUsersInputEnvelope = {
    data: notificationsCreateManyUsersInput | notificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type PostViewStatusCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastViewedAt: Date | string
    post: PostCreateNestedOneWithoutViewStatusInput
  }

  export type PostViewStatusUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    lastViewedAt: Date | string
  }

  export type PostViewStatusCreateOrConnectWithoutUserInput = {
    where: PostViewStatusWhereUniqueInput
    create: XOR<PostViewStatusCreateWithoutUserInput, PostViewStatusUncheckedCreateWithoutUserInput>
  }

  export type PostViewStatusCreateManyUserInputEnvelope = {
    data: PostViewStatusCreateManyUserInput | PostViewStatusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserDeviceTokenCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    device_type: string
  }

  export type UserDeviceTokenUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    device_type: string
  }

  export type UserDeviceTokenCreateOrConnectWithoutUserInput = {
    where: UserDeviceTokenWhereUniqueInput
    create: XOR<UserDeviceTokenCreateWithoutUserInput, UserDeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type UserDeviceTokenCreateManyUserInputEnvelope = {
    data: UserDeviceTokenCreateManyUserInput | UserDeviceTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserMoodCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mood: $Enums.UserMoodType
    note?: string | null
  }

  export type UserMoodUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mood: $Enums.UserMoodType
    note?: string | null
  }

  export type UserMoodCreateOrConnectWithoutUserInput = {
    where: UserMoodWhereUniqueInput
    create: XOR<UserMoodCreateWithoutUserInput, UserMoodUncheckedCreateWithoutUserInput>
  }

  export type UserMoodCreateManyUserInputEnvelope = {
    data: UserMoodCreateManyUserInput | UserMoodCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatroomCreateWithoutMembersInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    lastMessage?: string | null
    readStatuses?: ChatroomReadStatusCreateNestedManyWithoutChatroomInput
    messages?: ChatroomMessageCreateNestedManyWithoutChatroomInput
  }

  export type ChatroomUncheckedCreateWithoutMembersInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    lastMessage?: string | null
    readStatuses?: ChatroomReadStatusUncheckedCreateNestedManyWithoutChatroomInput
    messages?: ChatroomMessageUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type ChatroomCreateOrConnectWithoutMembersInput = {
    where: ChatroomWhereUniqueInput
    create: XOR<ChatroomCreateWithoutMembersInput, ChatroomUncheckedCreateWithoutMembersInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    text?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
  }

  export type HelpReadStatusUpsertWithWhereUniqueWithoutUserInput = {
    where: HelpReadStatusWhereUniqueInput
    update: XOR<HelpReadStatusUpdateWithoutUserInput, HelpReadStatusUncheckedUpdateWithoutUserInput>
    create: XOR<HelpReadStatusCreateWithoutUserInput, HelpReadStatusUncheckedCreateWithoutUserInput>
  }

  export type HelpReadStatusUpdateWithWhereUniqueWithoutUserInput = {
    where: HelpReadStatusWhereUniqueInput
    data: XOR<HelpReadStatusUpdateWithoutUserInput, HelpReadStatusUncheckedUpdateWithoutUserInput>
  }

  export type HelpReadStatusUpdateManyWithWhereWithoutUserInput = {
    where: HelpReadStatusScalarWhereInput
    data: XOR<HelpReadStatusUpdateManyMutationInput, HelpReadStatusUncheckedUpdateManyWithoutUserInput>
  }

  export type HelpReadStatusScalarWhereInput = {
    AND?: HelpReadStatusScalarWhereInput | HelpReadStatusScalarWhereInput[]
    OR?: HelpReadStatusScalarWhereInput[]
    NOT?: HelpReadStatusScalarWhereInput | HelpReadStatusScalarWhereInput[]
    id?: StringFilter<"HelpReadStatus"> | string
    createdAt?: DateTimeFilter<"HelpReadStatus"> | Date | string
    helpId?: StringFilter<"HelpReadStatus"> | string
    userId?: StringFilter<"HelpReadStatus"> | string
    helpMessageId?: StringNullableFilter<"HelpReadStatus"> | string | null
  }

  export type LikeUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    updatedAt?: DateTimeFilter<"Like"> | Date | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutUserInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    is_anonymous?: BoolFilter<"Post"> | boolean
    text?: StringNullableFilter<"Post"> | string | null
    mood?: StringNullableFilter<"Post"> | string | null
    userId?: StringFilter<"Post"> | string
    total_likes?: IntFilter<"Post"> | number
    total_comments?: IntFilter<"Post"> | number
  }

  export type ChatroomMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatroomMessageWhereUniqueInput
    update: XOR<ChatroomMessageUpdateWithoutSenderInput, ChatroomMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatroomMessageCreateWithoutSenderInput, ChatroomMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatroomMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatroomMessageWhereUniqueInput
    data: XOR<ChatroomMessageUpdateWithoutSenderInput, ChatroomMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatroomMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatroomMessageScalarWhereInput
    data: XOR<ChatroomMessageUpdateManyMutationInput, ChatroomMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ChatroomMessageScalarWhereInput = {
    AND?: ChatroomMessageScalarWhereInput | ChatroomMessageScalarWhereInput[]
    OR?: ChatroomMessageScalarWhereInput[]
    NOT?: ChatroomMessageScalarWhereInput | ChatroomMessageScalarWhereInput[]
    id?: StringFilter<"ChatroomMessage"> | string
    createdAt?: DateTimeFilter<"ChatroomMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatroomMessage"> | Date | string
    chatroomId?: StringFilter<"ChatroomMessage"> | string
    senderId?: StringFilter<"ChatroomMessage"> | string
    message?: StringFilter<"ChatroomMessage"> | string
    status?: EnumChatroomMessageStatusFilter<"ChatroomMessage"> | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFilter<"ChatroomMessage"> | $Enums.ChatroomMessageType
    file?: StringNullableFilter<"ChatroomMessage"> | string | null
    reply_id?: StringNullableFilter<"ChatroomMessage"> | string | null
    call_message_status?: EnumCallMessageStatusNullableFilter<"ChatroomMessage"> | $Enums.CallMessageStatus | null
    isDeleted?: BoolFilter<"ChatroomMessage"> | boolean
    payload?: StringNullableFilter<"ChatroomMessage"> | string | null
  }

  export type FriendshipUpsertWithWhereUniqueWithoutUser1Input = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutUser1Input, FriendshipUncheckedUpdateWithoutUser1Input>
    create: XOR<FriendshipCreateWithoutUser1Input, FriendshipUncheckedCreateWithoutUser1Input>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutUser1Input = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutUser1Input, FriendshipUncheckedUpdateWithoutUser1Input>
  }

  export type FriendshipUpdateManyWithWhereWithoutUser1Input = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutUser1Input>
  }

  export type FriendshipScalarWhereInput = {
    AND?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    OR?: FriendshipScalarWhereInput[]
    NOT?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    id?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeFilter<"Friendship"> | Date | string
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    user1Id?: StringFilter<"Friendship"> | string
    user2Id?: StringFilter<"Friendship"> | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutUser2Input = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutUser2Input, FriendshipUncheckedUpdateWithoutUser2Input>
    create: XOR<FriendshipCreateWithoutUser2Input, FriendshipUncheckedCreateWithoutUser2Input>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutUser2Input = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutUser2Input, FriendshipUncheckedUpdateWithoutUser2Input>
  }

  export type FriendshipUpdateManyWithWhereWithoutUser2Input = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutUser2Input>
  }

  export type HelpMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: HelpMessageWhereUniqueInput
    update: XOR<HelpMessageUpdateWithoutSenderInput, HelpMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<HelpMessageCreateWithoutSenderInput, HelpMessageUncheckedCreateWithoutSenderInput>
  }

  export type HelpMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: HelpMessageWhereUniqueInput
    data: XOR<HelpMessageUpdateWithoutSenderInput, HelpMessageUncheckedUpdateWithoutSenderInput>
  }

  export type HelpMessageUpdateManyWithWhereWithoutSenderInput = {
    where: HelpMessageScalarWhereInput
    data: XOR<HelpMessageUpdateManyMutationInput, HelpMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type HelpMessageScalarWhereInput = {
    AND?: HelpMessageScalarWhereInput | HelpMessageScalarWhereInput[]
    OR?: HelpMessageScalarWhereInput[]
    NOT?: HelpMessageScalarWhereInput | HelpMessageScalarWhereInput[]
    id?: StringFilter<"HelpMessage"> | string
    createdAt?: DateTimeFilter<"HelpMessage"> | Date | string
    updatedAt?: DateTimeFilter<"HelpMessage"> | Date | string
    helpId?: StringFilter<"HelpMessage"> | string
    senderId?: StringFilter<"HelpMessage"> | string
    message?: StringNullableFilter<"HelpMessage"> | string | null
    status?: EnumChatroomMessageStatusFilter<"HelpMessage"> | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFilter<"HelpMessage"> | $Enums.ChatroomMessageType
    file?: StringNullableFilter<"HelpMessage"> | string | null
    locationLat?: FloatNullableFilter<"HelpMessage"> | number | null
    locationLng?: FloatNullableFilter<"HelpMessage"> | number | null
    isDeleted?: BoolFilter<"HelpMessage"> | boolean
    reply_id?: StringNullableFilter<"HelpMessage"> | string | null
  }

  export type HelpUpsertWithWhereUniqueWithoutHelperInput = {
    where: HelpWhereUniqueInput
    update: XOR<HelpUpdateWithoutHelperInput, HelpUncheckedUpdateWithoutHelperInput>
    create: XOR<HelpCreateWithoutHelperInput, HelpUncheckedCreateWithoutHelperInput>
  }

  export type HelpUpdateWithWhereUniqueWithoutHelperInput = {
    where: HelpWhereUniqueInput
    data: XOR<HelpUpdateWithoutHelperInput, HelpUncheckedUpdateWithoutHelperInput>
  }

  export type HelpUpdateManyWithWhereWithoutHelperInput = {
    where: HelpScalarWhereInput
    data: XOR<HelpUpdateManyMutationInput, HelpUncheckedUpdateManyWithoutHelperInput>
  }

  export type HelpScalarWhereInput = {
    AND?: HelpScalarWhereInput | HelpScalarWhereInput[]
    OR?: HelpScalarWhereInput[]
    NOT?: HelpScalarWhereInput | HelpScalarWhereInput[]
    id?: StringFilter<"Help"> | string
    createdAt?: DateTimeFilter<"Help"> | Date | string
    updatedAt?: DateTimeFilter<"Help"> | Date | string
    expiresAt?: DateTimeFilter<"Help"> | Date | string
    requestedById?: StringFilter<"Help"> | string
    helperId?: StringNullableFilter<"Help"> | string | null
    status?: EnumHelpStatusFilter<"Help"> | $Enums.HelpStatus
    locationLat?: FloatNullableFilter<"Help"> | number | null
    locationLng?: FloatNullableFilter<"Help"> | number | null
    address?: StringNullableFilter<"Help"> | string | null
    isDeleted?: BoolFilter<"Help"> | boolean
  }

  export type HelpUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: HelpWhereUniqueInput
    update: XOR<HelpUpdateWithoutRequestedByInput, HelpUncheckedUpdateWithoutRequestedByInput>
    create: XOR<HelpCreateWithoutRequestedByInput, HelpUncheckedCreateWithoutRequestedByInput>
  }

  export type HelpUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: HelpWhereUniqueInput
    data: XOR<HelpUpdateWithoutRequestedByInput, HelpUncheckedUpdateWithoutRequestedByInput>
  }

  export type HelpUpdateManyWithWhereWithoutRequestedByInput = {
    where: HelpScalarWhereInput
    data: XOR<HelpUpdateManyMutationInput, HelpUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type notificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUsersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: StringFilter<"notifications"> | string
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
    userId?: StringFilter<"notifications"> | string
    type?: StringFilter<"notifications"> | string
    content?: StringFilter<"notifications"> | string
    read?: BoolFilter<"notifications"> | boolean
    metadata?: JsonNullableFilter<"notifications">
  }

  export type PostViewStatusUpsertWithWhereUniqueWithoutUserInput = {
    where: PostViewStatusWhereUniqueInput
    update: XOR<PostViewStatusUpdateWithoutUserInput, PostViewStatusUncheckedUpdateWithoutUserInput>
    create: XOR<PostViewStatusCreateWithoutUserInput, PostViewStatusUncheckedCreateWithoutUserInput>
  }

  export type PostViewStatusUpdateWithWhereUniqueWithoutUserInput = {
    where: PostViewStatusWhereUniqueInput
    data: XOR<PostViewStatusUpdateWithoutUserInput, PostViewStatusUncheckedUpdateWithoutUserInput>
  }

  export type PostViewStatusUpdateManyWithWhereWithoutUserInput = {
    where: PostViewStatusScalarWhereInput
    data: XOR<PostViewStatusUpdateManyMutationInput, PostViewStatusUncheckedUpdateManyWithoutUserInput>
  }

  export type PostViewStatusScalarWhereInput = {
    AND?: PostViewStatusScalarWhereInput | PostViewStatusScalarWhereInput[]
    OR?: PostViewStatusScalarWhereInput[]
    NOT?: PostViewStatusScalarWhereInput | PostViewStatusScalarWhereInput[]
    id?: StringFilter<"PostViewStatus"> | string
    createdAt?: DateTimeFilter<"PostViewStatus"> | Date | string
    updatedAt?: DateTimeFilter<"PostViewStatus"> | Date | string
    userId?: StringFilter<"PostViewStatus"> | string
    postId?: StringFilter<"PostViewStatus"> | string
    lastViewedAt?: DateTimeFilter<"PostViewStatus"> | Date | string
  }

  export type UserDeviceTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDeviceTokenWhereUniqueInput
    update: XOR<UserDeviceTokenUpdateWithoutUserInput, UserDeviceTokenUncheckedUpdateWithoutUserInput>
    create: XOR<UserDeviceTokenCreateWithoutUserInput, UserDeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type UserDeviceTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDeviceTokenWhereUniqueInput
    data: XOR<UserDeviceTokenUpdateWithoutUserInput, UserDeviceTokenUncheckedUpdateWithoutUserInput>
  }

  export type UserDeviceTokenUpdateManyWithWhereWithoutUserInput = {
    where: UserDeviceTokenScalarWhereInput
    data: XOR<UserDeviceTokenUpdateManyMutationInput, UserDeviceTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type UserDeviceTokenScalarWhereInput = {
    AND?: UserDeviceTokenScalarWhereInput | UserDeviceTokenScalarWhereInput[]
    OR?: UserDeviceTokenScalarWhereInput[]
    NOT?: UserDeviceTokenScalarWhereInput | UserDeviceTokenScalarWhereInput[]
    id?: StringFilter<"UserDeviceToken"> | string
    createdAt?: DateTimeFilter<"UserDeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"UserDeviceToken"> | Date | string
    userId?: StringFilter<"UserDeviceToken"> | string
    token?: StringFilter<"UserDeviceToken"> | string
    device_type?: StringFilter<"UserDeviceToken"> | string
  }

  export type UserMoodUpsertWithWhereUniqueWithoutUserInput = {
    where: UserMoodWhereUniqueInput
    update: XOR<UserMoodUpdateWithoutUserInput, UserMoodUncheckedUpdateWithoutUserInput>
    create: XOR<UserMoodCreateWithoutUserInput, UserMoodUncheckedCreateWithoutUserInput>
  }

  export type UserMoodUpdateWithWhereUniqueWithoutUserInput = {
    where: UserMoodWhereUniqueInput
    data: XOR<UserMoodUpdateWithoutUserInput, UserMoodUncheckedUpdateWithoutUserInput>
  }

  export type UserMoodUpdateManyWithWhereWithoutUserInput = {
    where: UserMoodScalarWhereInput
    data: XOR<UserMoodUpdateManyMutationInput, UserMoodUncheckedUpdateManyWithoutUserInput>
  }

  export type UserMoodScalarWhereInput = {
    AND?: UserMoodScalarWhereInput | UserMoodScalarWhereInput[]
    OR?: UserMoodScalarWhereInput[]
    NOT?: UserMoodScalarWhereInput | UserMoodScalarWhereInput[]
    id?: StringFilter<"UserMood"> | string
    createdAt?: DateTimeFilter<"UserMood"> | Date | string
    updatedAt?: DateTimeFilter<"UserMood"> | Date | string
    userId?: StringFilter<"UserMood"> | string
    mood?: EnumUserMoodTypeFilter<"UserMood"> | $Enums.UserMoodType
    note?: StringNullableFilter<"UserMood"> | string | null
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
  }

  export type ChatroomUpsertWithWhereUniqueWithoutMembersInput = {
    where: ChatroomWhereUniqueInput
    update: XOR<ChatroomUpdateWithoutMembersInput, ChatroomUncheckedUpdateWithoutMembersInput>
    create: XOR<ChatroomCreateWithoutMembersInput, ChatroomUncheckedCreateWithoutMembersInput>
  }

  export type ChatroomUpdateWithWhereUniqueWithoutMembersInput = {
    where: ChatroomWhereUniqueInput
    data: XOR<ChatroomUpdateWithoutMembersInput, ChatroomUncheckedUpdateWithoutMembersInput>
  }

  export type ChatroomUpdateManyWithWhereWithoutMembersInput = {
    where: ChatroomScalarWhereInput
    data: XOR<ChatroomUpdateManyMutationInput, ChatroomUncheckedUpdateManyWithoutMembersInput>
  }

  export type ChatroomScalarWhereInput = {
    AND?: ChatroomScalarWhereInput | ChatroomScalarWhereInput[]
    OR?: ChatroomScalarWhereInput[]
    NOT?: ChatroomScalarWhereInput | ChatroomScalarWhereInput[]
    id?: StringFilter<"Chatroom"> | string
    createdAt?: DateTimeFilter<"Chatroom"> | Date | string
    updatedAt?: DateTimeFilter<"Chatroom"> | Date | string
    name?: StringNullableFilter<"Chatroom"> | string | null
    lastMessage?: StringNullableFilter<"Chatroom"> | string | null
  }

  export type UserCreateWithoutDeviceTokensInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutDeviceTokensInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutDeviceTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
  }

  export type UserUpsertWithoutDeviceTokensInput = {
    update: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeviceTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type UserUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type UserCreateWithoutMoodsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutMoodsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutMoodsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMoodsInput, UserUncheckedCreateWithoutMoodsInput>
  }

  export type UserUpsertWithoutMoodsInput = {
    update: XOR<UserUpdateWithoutMoodsInput, UserUncheckedUpdateWithoutMoodsInput>
    create: XOR<UserCreateWithoutMoodsInput, UserUncheckedCreateWithoutMoodsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMoodsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMoodsInput, UserUncheckedUpdateWithoutMoodsInput>
  }

  export type UserUpdateWithoutMoodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutMoodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type UserCreateWithoutFriends1Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutFriends1Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutFriends1Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriends1Input, UserUncheckedCreateWithoutFriends1Input>
  }

  export type UserCreateWithoutFriends2Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutFriends2Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutFriends2Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriends2Input, UserUncheckedCreateWithoutFriends2Input>
  }

  export type UserUpsertWithoutFriends1Input = {
    update: XOR<UserUpdateWithoutFriends1Input, UserUncheckedUpdateWithoutFriends1Input>
    create: XOR<UserCreateWithoutFriends1Input, UserUncheckedCreateWithoutFriends1Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriends1Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriends1Input, UserUncheckedUpdateWithoutFriends1Input>
  }

  export type UserUpdateWithoutFriends1Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutFriends1Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type UserUpsertWithoutFriends2Input = {
    update: XOR<UserUpdateWithoutFriends2Input, UserUncheckedUpdateWithoutFriends2Input>
    create: XOR<UserCreateWithoutFriends2Input, UserUncheckedCreateWithoutFriends2Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriends2Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriends2Input, UserUncheckedUpdateWithoutFriends2Input>
  }

  export type UserUpdateWithoutFriends2Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutFriends2Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type ChatroomReadStatusCreateWithoutChatroomInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    message: ChatroomMessageCreateNestedOneWithoutReadByInput
  }

  export type ChatroomReadStatusUncheckedCreateWithoutChatroomInput = {
    id?: string
    userId: string
    messageId: string
    createdAt?: Date | string
  }

  export type ChatroomReadStatusCreateOrConnectWithoutChatroomInput = {
    where: ChatroomReadStatusWhereUniqueInput
    create: XOR<ChatroomReadStatusCreateWithoutChatroomInput, ChatroomReadStatusUncheckedCreateWithoutChatroomInput>
  }

  export type ChatroomReadStatusCreateManyChatroomInputEnvelope = {
    data: ChatroomReadStatusCreateManyChatroomInput | ChatroomReadStatusCreateManyChatroomInput[]
    skipDuplicates?: boolean
  }

  export type ChatroomMessageCreateWithoutChatroomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusCreateNestedManyWithoutMessageInput
    reply?: ChatroomMessageCreateNestedOneWithoutChat_messageInput
    chat_message?: ChatroomMessageCreateNestedManyWithoutReplyInput
    sender: UserCreateNestedOneWithoutChatroomMessageInput
  }

  export type ChatroomMessageUncheckedCreateWithoutChatroomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    reply_id?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusUncheckedCreateNestedManyWithoutMessageInput
    chat_message?: ChatroomMessageUncheckedCreateNestedManyWithoutReplyInput
  }

  export type ChatroomMessageCreateOrConnectWithoutChatroomInput = {
    where: ChatroomMessageWhereUniqueInput
    create: XOR<ChatroomMessageCreateWithoutChatroomInput, ChatroomMessageUncheckedCreateWithoutChatroomInput>
  }

  export type ChatroomMessageCreateManyChatroomInputEnvelope = {
    data: ChatroomMessageCreateManyChatroomInput | ChatroomMessageCreateManyChatroomInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutChatroomsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatroomsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatroomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatroomsInput, UserUncheckedCreateWithoutChatroomsInput>
  }

  export type ChatroomReadStatusUpsertWithWhereUniqueWithoutChatroomInput = {
    where: ChatroomReadStatusWhereUniqueInput
    update: XOR<ChatroomReadStatusUpdateWithoutChatroomInput, ChatroomReadStatusUncheckedUpdateWithoutChatroomInput>
    create: XOR<ChatroomReadStatusCreateWithoutChatroomInput, ChatroomReadStatusUncheckedCreateWithoutChatroomInput>
  }

  export type ChatroomReadStatusUpdateWithWhereUniqueWithoutChatroomInput = {
    where: ChatroomReadStatusWhereUniqueInput
    data: XOR<ChatroomReadStatusUpdateWithoutChatroomInput, ChatroomReadStatusUncheckedUpdateWithoutChatroomInput>
  }

  export type ChatroomReadStatusUpdateManyWithWhereWithoutChatroomInput = {
    where: ChatroomReadStatusScalarWhereInput
    data: XOR<ChatroomReadStatusUpdateManyMutationInput, ChatroomReadStatusUncheckedUpdateManyWithoutChatroomInput>
  }

  export type ChatroomReadStatusScalarWhereInput = {
    AND?: ChatroomReadStatusScalarWhereInput | ChatroomReadStatusScalarWhereInput[]
    OR?: ChatroomReadStatusScalarWhereInput[]
    NOT?: ChatroomReadStatusScalarWhereInput | ChatroomReadStatusScalarWhereInput[]
    id?: StringFilter<"ChatroomReadStatus"> | string
    chatroomId?: StringFilter<"ChatroomReadStatus"> | string
    userId?: StringFilter<"ChatroomReadStatus"> | string
    messageId?: StringFilter<"ChatroomReadStatus"> | string
    createdAt?: DateTimeFilter<"ChatroomReadStatus"> | Date | string
  }

  export type ChatroomMessageUpsertWithWhereUniqueWithoutChatroomInput = {
    where: ChatroomMessageWhereUniqueInput
    update: XOR<ChatroomMessageUpdateWithoutChatroomInput, ChatroomMessageUncheckedUpdateWithoutChatroomInput>
    create: XOR<ChatroomMessageCreateWithoutChatroomInput, ChatroomMessageUncheckedCreateWithoutChatroomInput>
  }

  export type ChatroomMessageUpdateWithWhereUniqueWithoutChatroomInput = {
    where: ChatroomMessageWhereUniqueInput
    data: XOR<ChatroomMessageUpdateWithoutChatroomInput, ChatroomMessageUncheckedUpdateWithoutChatroomInput>
  }

  export type ChatroomMessageUpdateManyWithWhereWithoutChatroomInput = {
    where: ChatroomMessageScalarWhereInput
    data: XOR<ChatroomMessageUpdateManyMutationInput, ChatroomMessageUncheckedUpdateManyWithoutChatroomInput>
  }

  export type UserUpsertWithWhereUniqueWithoutChatroomsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutChatroomsInput, UserUncheckedUpdateWithoutChatroomsInput>
    create: XOR<UserCreateWithoutChatroomsInput, UserUncheckedCreateWithoutChatroomsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutChatroomsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutChatroomsInput, UserUncheckedUpdateWithoutChatroomsInput>
  }

  export type UserUpdateManyWithWhereWithoutChatroomsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutChatroomsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    local?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profilePicture?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    schoolName?: StringNullableFilter<"User"> | string | null
    className?: StringNullableFilter<"User"> | string | null
    teacherName?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isBlocked?: BoolFilter<"User"> | boolean
    isOnline?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    isHelping?: BoolFilter<"User"> | boolean
    Aliyun_token?: StringNullableFilter<"User"> | string | null
    device_type?: StringNullableFilter<"User"> | string | null
  }

  export type ChatroomReadStatusCreateWithoutMessageInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    chatroom: ChatroomCreateNestedOneWithoutReadStatusesInput
  }

  export type ChatroomReadStatusUncheckedCreateWithoutMessageInput = {
    id?: string
    chatroomId: string
    userId: string
    createdAt?: Date | string
  }

  export type ChatroomReadStatusCreateOrConnectWithoutMessageInput = {
    where: ChatroomReadStatusWhereUniqueInput
    create: XOR<ChatroomReadStatusCreateWithoutMessageInput, ChatroomReadStatusUncheckedCreateWithoutMessageInput>
  }

  export type ChatroomReadStatusCreateManyMessageInputEnvelope = {
    data: ChatroomReadStatusCreateManyMessageInput | ChatroomReadStatusCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ChatroomCreateWithoutMessagesInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    lastMessage?: string | null
    readStatuses?: ChatroomReadStatusCreateNestedManyWithoutChatroomInput
    members?: UserCreateNestedManyWithoutChatroomsInput
  }

  export type ChatroomUncheckedCreateWithoutMessagesInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    lastMessage?: string | null
    readStatuses?: ChatroomReadStatusUncheckedCreateNestedManyWithoutChatroomInput
    members?: UserUncheckedCreateNestedManyWithoutChatroomsInput
  }

  export type ChatroomCreateOrConnectWithoutMessagesInput = {
    where: ChatroomWhereUniqueInput
    create: XOR<ChatroomCreateWithoutMessagesInput, ChatroomUncheckedCreateWithoutMessagesInput>
  }

  export type ChatroomMessageCreateWithoutChat_messageInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusCreateNestedManyWithoutMessageInput
    chatroom: ChatroomCreateNestedOneWithoutMessagesInput
    reply?: ChatroomMessageCreateNestedOneWithoutChat_messageInput
    sender: UserCreateNestedOneWithoutChatroomMessageInput
  }

  export type ChatroomMessageUncheckedCreateWithoutChat_messageInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatroomId: string
    senderId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    reply_id?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusUncheckedCreateNestedManyWithoutMessageInput
  }

  export type ChatroomMessageCreateOrConnectWithoutChat_messageInput = {
    where: ChatroomMessageWhereUniqueInput
    create: XOR<ChatroomMessageCreateWithoutChat_messageInput, ChatroomMessageUncheckedCreateWithoutChat_messageInput>
  }

  export type ChatroomMessageCreateWithoutReplyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusCreateNestedManyWithoutMessageInput
    chatroom: ChatroomCreateNestedOneWithoutMessagesInput
    chat_message?: ChatroomMessageCreateNestedManyWithoutReplyInput
    sender: UserCreateNestedOneWithoutChatroomMessageInput
  }

  export type ChatroomMessageUncheckedCreateWithoutReplyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatroomId: string
    senderId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    readBy?: ChatroomReadStatusUncheckedCreateNestedManyWithoutMessageInput
    chat_message?: ChatroomMessageUncheckedCreateNestedManyWithoutReplyInput
  }

  export type ChatroomMessageCreateOrConnectWithoutReplyInput = {
    where: ChatroomMessageWhereUniqueInput
    create: XOR<ChatroomMessageCreateWithoutReplyInput, ChatroomMessageUncheckedCreateWithoutReplyInput>
  }

  export type ChatroomMessageCreateManyReplyInputEnvelope = {
    data: ChatroomMessageCreateManyReplyInput | ChatroomMessageCreateManyReplyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutChatroomMessageInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutChatroomMessageInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutChatroomMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatroomMessageInput, UserUncheckedCreateWithoutChatroomMessageInput>
  }

  export type ChatroomReadStatusUpsertWithWhereUniqueWithoutMessageInput = {
    where: ChatroomReadStatusWhereUniqueInput
    update: XOR<ChatroomReadStatusUpdateWithoutMessageInput, ChatroomReadStatusUncheckedUpdateWithoutMessageInput>
    create: XOR<ChatroomReadStatusCreateWithoutMessageInput, ChatroomReadStatusUncheckedCreateWithoutMessageInput>
  }

  export type ChatroomReadStatusUpdateWithWhereUniqueWithoutMessageInput = {
    where: ChatroomReadStatusWhereUniqueInput
    data: XOR<ChatroomReadStatusUpdateWithoutMessageInput, ChatroomReadStatusUncheckedUpdateWithoutMessageInput>
  }

  export type ChatroomReadStatusUpdateManyWithWhereWithoutMessageInput = {
    where: ChatroomReadStatusScalarWhereInput
    data: XOR<ChatroomReadStatusUpdateManyMutationInput, ChatroomReadStatusUncheckedUpdateManyWithoutMessageInput>
  }

  export type ChatroomUpsertWithoutMessagesInput = {
    update: XOR<ChatroomUpdateWithoutMessagesInput, ChatroomUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatroomCreateWithoutMessagesInput, ChatroomUncheckedCreateWithoutMessagesInput>
    where?: ChatroomWhereInput
  }

  export type ChatroomUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatroomWhereInput
    data: XOR<ChatroomUpdateWithoutMessagesInput, ChatroomUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatroomUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readStatuses?: ChatroomReadStatusUpdateManyWithoutChatroomNestedInput
    members?: UserUpdateManyWithoutChatroomsNestedInput
  }

  export type ChatroomUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readStatuses?: ChatroomReadStatusUncheckedUpdateManyWithoutChatroomNestedInput
    members?: UserUncheckedUpdateManyWithoutChatroomsNestedInput
  }

  export type ChatroomMessageUpsertWithoutChat_messageInput = {
    update: XOR<ChatroomMessageUpdateWithoutChat_messageInput, ChatroomMessageUncheckedUpdateWithoutChat_messageInput>
    create: XOR<ChatroomMessageCreateWithoutChat_messageInput, ChatroomMessageUncheckedCreateWithoutChat_messageInput>
    where?: ChatroomMessageWhereInput
  }

  export type ChatroomMessageUpdateToOneWithWhereWithoutChat_messageInput = {
    where?: ChatroomMessageWhereInput
    data: XOR<ChatroomMessageUpdateWithoutChat_messageInput, ChatroomMessageUncheckedUpdateWithoutChat_messageInput>
  }

  export type ChatroomMessageUpdateWithoutChat_messageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUpdateManyWithoutMessageNestedInput
    chatroom?: ChatroomUpdateOneRequiredWithoutMessagesNestedInput
    reply?: ChatroomMessageUpdateOneWithoutChat_messageNestedInput
    sender?: UserUpdateOneRequiredWithoutChatroomMessageNestedInput
  }

  export type ChatroomMessageUncheckedUpdateWithoutChat_messageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type ChatroomMessageUpsertWithWhereUniqueWithoutReplyInput = {
    where: ChatroomMessageWhereUniqueInput
    update: XOR<ChatroomMessageUpdateWithoutReplyInput, ChatroomMessageUncheckedUpdateWithoutReplyInput>
    create: XOR<ChatroomMessageCreateWithoutReplyInput, ChatroomMessageUncheckedCreateWithoutReplyInput>
  }

  export type ChatroomMessageUpdateWithWhereUniqueWithoutReplyInput = {
    where: ChatroomMessageWhereUniqueInput
    data: XOR<ChatroomMessageUpdateWithoutReplyInput, ChatroomMessageUncheckedUpdateWithoutReplyInput>
  }

  export type ChatroomMessageUpdateManyWithWhereWithoutReplyInput = {
    where: ChatroomMessageScalarWhereInput
    data: XOR<ChatroomMessageUpdateManyMutationInput, ChatroomMessageUncheckedUpdateManyWithoutReplyInput>
  }

  export type UserUpsertWithoutChatroomMessageInput = {
    update: XOR<UserUpdateWithoutChatroomMessageInput, UserUncheckedUpdateWithoutChatroomMessageInput>
    create: XOR<UserCreateWithoutChatroomMessageInput, UserUncheckedCreateWithoutChatroomMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatroomMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatroomMessageInput, UserUncheckedUpdateWithoutChatroomMessageInput>
  }

  export type UserUpdateWithoutChatroomMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutChatroomMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type ChatroomCreateWithoutReadStatusesInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    lastMessage?: string | null
    messages?: ChatroomMessageCreateNestedManyWithoutChatroomInput
    members?: UserCreateNestedManyWithoutChatroomsInput
  }

  export type ChatroomUncheckedCreateWithoutReadStatusesInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    lastMessage?: string | null
    messages?: ChatroomMessageUncheckedCreateNestedManyWithoutChatroomInput
    members?: UserUncheckedCreateNestedManyWithoutChatroomsInput
  }

  export type ChatroomCreateOrConnectWithoutReadStatusesInput = {
    where: ChatroomWhereUniqueInput
    create: XOR<ChatroomCreateWithoutReadStatusesInput, ChatroomUncheckedCreateWithoutReadStatusesInput>
  }

  export type ChatroomMessageCreateWithoutReadByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    chatroom: ChatroomCreateNestedOneWithoutMessagesInput
    reply?: ChatroomMessageCreateNestedOneWithoutChat_messageInput
    chat_message?: ChatroomMessageCreateNestedManyWithoutReplyInput
    sender: UserCreateNestedOneWithoutChatroomMessageInput
  }

  export type ChatroomMessageUncheckedCreateWithoutReadByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatroomId: string
    senderId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    reply_id?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
    chat_message?: ChatroomMessageUncheckedCreateNestedManyWithoutReplyInput
  }

  export type ChatroomMessageCreateOrConnectWithoutReadByInput = {
    where: ChatroomMessageWhereUniqueInput
    create: XOR<ChatroomMessageCreateWithoutReadByInput, ChatroomMessageUncheckedCreateWithoutReadByInput>
  }

  export type ChatroomUpsertWithoutReadStatusesInput = {
    update: XOR<ChatroomUpdateWithoutReadStatusesInput, ChatroomUncheckedUpdateWithoutReadStatusesInput>
    create: XOR<ChatroomCreateWithoutReadStatusesInput, ChatroomUncheckedCreateWithoutReadStatusesInput>
    where?: ChatroomWhereInput
  }

  export type ChatroomUpdateToOneWithWhereWithoutReadStatusesInput = {
    where?: ChatroomWhereInput
    data: XOR<ChatroomUpdateWithoutReadStatusesInput, ChatroomUncheckedUpdateWithoutReadStatusesInput>
  }

  export type ChatroomUpdateWithoutReadStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: ChatroomMessageUpdateManyWithoutChatroomNestedInput
    members?: UserUpdateManyWithoutChatroomsNestedInput
  }

  export type ChatroomUncheckedUpdateWithoutReadStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: ChatroomMessageUncheckedUpdateManyWithoutChatroomNestedInput
    members?: UserUncheckedUpdateManyWithoutChatroomsNestedInput
  }

  export type ChatroomMessageUpsertWithoutReadByInput = {
    update: XOR<ChatroomMessageUpdateWithoutReadByInput, ChatroomMessageUncheckedUpdateWithoutReadByInput>
    create: XOR<ChatroomMessageCreateWithoutReadByInput, ChatroomMessageUncheckedCreateWithoutReadByInput>
    where?: ChatroomMessageWhereInput
  }

  export type ChatroomMessageUpdateToOneWithWhereWithoutReadByInput = {
    where?: ChatroomMessageWhereInput
    data: XOR<ChatroomMessageUpdateWithoutReadByInput, ChatroomMessageUncheckedUpdateWithoutReadByInput>
  }

  export type ChatroomMessageUpdateWithoutReadByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    chatroom?: ChatroomUpdateOneRequiredWithoutMessagesNestedInput
    reply?: ChatroomMessageUpdateOneWithoutChat_messageNestedInput
    chat_message?: ChatroomMessageUpdateManyWithoutReplyNestedInput
    sender?: UserUpdateOneRequiredWithoutChatroomMessageNestedInput
  }

  export type ChatroomMessageUncheckedUpdateWithoutReadByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    chat_message?: ChatroomMessageUncheckedUpdateManyWithoutReplyNestedInput
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    text: string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    text: string
    userId: string
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type LikeCreateOrConnectWithoutPostInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeCreateManyPostInputEnvelope = {
    data: LikeCreateManyPostInput | LikeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type MediaAttachmentCreateWithoutPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
  }

  export type MediaAttachmentUncheckedCreateWithoutPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
  }

  export type MediaAttachmentCreateOrConnectWithoutPostInput = {
    where: MediaAttachmentWhereUniqueInput
    create: XOR<MediaAttachmentCreateWithoutPostInput, MediaAttachmentUncheckedCreateWithoutPostInput>
  }

  export type MediaAttachmentCreateManyPostInputEnvelope = {
    data: MediaAttachmentCreateManyPostInput | MediaAttachmentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type PostViewStatusCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastViewedAt: Date | string
    user: UserCreateNestedOneWithoutPostViewsInput
  }

  export type PostViewStatusUncheckedCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    lastViewedAt: Date | string
  }

  export type PostViewStatusCreateOrConnectWithoutPostInput = {
    where: PostViewStatusWhereUniqueInput
    create: XOR<PostViewStatusCreateWithoutPostInput, PostViewStatusUncheckedCreateWithoutPostInput>
  }

  export type PostViewStatusCreateManyPostInputEnvelope = {
    data: PostViewStatusCreateManyPostInput | PostViewStatusCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
  }

  export type LikeUpdateManyWithWhereWithoutPostInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPostInput>
  }

  export type MediaAttachmentUpsertWithWhereUniqueWithoutPostInput = {
    where: MediaAttachmentWhereUniqueInput
    update: XOR<MediaAttachmentUpdateWithoutPostInput, MediaAttachmentUncheckedUpdateWithoutPostInput>
    create: XOR<MediaAttachmentCreateWithoutPostInput, MediaAttachmentUncheckedCreateWithoutPostInput>
  }

  export type MediaAttachmentUpdateWithWhereUniqueWithoutPostInput = {
    where: MediaAttachmentWhereUniqueInput
    data: XOR<MediaAttachmentUpdateWithoutPostInput, MediaAttachmentUncheckedUpdateWithoutPostInput>
  }

  export type MediaAttachmentUpdateManyWithWhereWithoutPostInput = {
    where: MediaAttachmentScalarWhereInput
    data: XOR<MediaAttachmentUpdateManyMutationInput, MediaAttachmentUncheckedUpdateManyWithoutPostInput>
  }

  export type MediaAttachmentScalarWhereInput = {
    AND?: MediaAttachmentScalarWhereInput | MediaAttachmentScalarWhereInput[]
    OR?: MediaAttachmentScalarWhereInput[]
    NOT?: MediaAttachmentScalarWhereInput | MediaAttachmentScalarWhereInput[]
    id?: StringFilter<"MediaAttachment"> | string
    type?: EnumMediaTypeFilter<"MediaAttachment"> | $Enums.MediaType
    url?: StringFilter<"MediaAttachment"> | string
    postId?: StringFilter<"MediaAttachment"> | string
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type PostViewStatusUpsertWithWhereUniqueWithoutPostInput = {
    where: PostViewStatusWhereUniqueInput
    update: XOR<PostViewStatusUpdateWithoutPostInput, PostViewStatusUncheckedUpdateWithoutPostInput>
    create: XOR<PostViewStatusCreateWithoutPostInput, PostViewStatusUncheckedCreateWithoutPostInput>
  }

  export type PostViewStatusUpdateWithWhereUniqueWithoutPostInput = {
    where: PostViewStatusWhereUniqueInput
    data: XOR<PostViewStatusUpdateWithoutPostInput, PostViewStatusUncheckedUpdateWithoutPostInput>
  }

  export type PostViewStatusUpdateManyWithWhereWithoutPostInput = {
    where: PostViewStatusScalarWhereInput
    data: XOR<PostViewStatusUpdateManyMutationInput, PostViewStatusUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutMediaAttachmentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    total_likes?: number
    total_comments?: number
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutPostsInput
    viewStatus?: PostViewStatusCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutMediaAttachmentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    userId: string
    total_likes?: number
    total_comments?: number
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    viewStatus?: PostViewStatusUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutMediaAttachmentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutMediaAttachmentsInput, PostUncheckedCreateWithoutMediaAttachmentsInput>
  }

  export type PostUpsertWithoutMediaAttachmentsInput = {
    update: XOR<PostUpdateWithoutMediaAttachmentsInput, PostUncheckedUpdateWithoutMediaAttachmentsInput>
    create: XOR<PostCreateWithoutMediaAttachmentsInput, PostUncheckedCreateWithoutMediaAttachmentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutMediaAttachmentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutMediaAttachmentsInput, PostUncheckedUpdateWithoutMediaAttachmentsInput>
  }

  export type PostUpdateWithoutMediaAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    viewStatus?: PostViewStatusUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutMediaAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    viewStatus?: PostViewStatusUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    total_likes?: number
    total_comments?: number
    likes?: LikeCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutPostsInput
    viewStatus?: PostViewStatusCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    userId: string
    total_likes?: number
    total_comments?: number
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentUncheckedCreateNestedManyWithoutPostInput
    viewStatus?: PostViewStatusUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    likes?: LikeUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    viewStatus?: PostViewStatusUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUncheckedUpdateManyWithoutPostNestedInput
    viewStatus?: PostViewStatusUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type PostCreateWithoutLikesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    total_likes?: number
    total_comments?: number
    comments?: CommentCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutPostsInput
    viewStatus?: PostViewStatusCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutLikesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    userId: string
    total_likes?: number
    total_comments?: number
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentUncheckedCreateNestedManyWithoutPostInput
    viewStatus?: PostViewStatusUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutLikesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutLikesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutLikesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
  }

  export type PostUpsertWithoutLikesInput = {
    update: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
  }

  export type PostUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    viewStatus?: PostViewStatusUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUncheckedUpdateManyWithoutPostNestedInput
    viewStatus?: PostViewStatusUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutLikesInput = {
    update: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type HelpReadStatusCreateWithoutHelpInput = {
    id?: string
    createdAt?: Date | string
    helpMessage?: HelpMessageCreateNestedOneWithoutReadByInput
    user: UserCreateNestedOneWithoutHelpReadStatusInput
  }

  export type HelpReadStatusUncheckedCreateWithoutHelpInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    helpMessageId?: string | null
  }

  export type HelpReadStatusCreateOrConnectWithoutHelpInput = {
    where: HelpReadStatusWhereUniqueInput
    create: XOR<HelpReadStatusCreateWithoutHelpInput, HelpReadStatusUncheckedCreateWithoutHelpInput>
  }

  export type HelpReadStatusCreateManyHelpInputEnvelope = {
    data: HelpReadStatusCreateManyHelpInput | HelpReadStatusCreateManyHelpInput[]
    skipDuplicates?: boolean
  }

  export type HelpMessageCreateWithoutHelpInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
    readBy?: HelpReadStatusCreateNestedManyWithoutHelpMessageInput
    sender: UserCreateNestedOneWithoutHelp_messagesInput
  }

  export type HelpMessageUncheckedCreateWithoutHelpInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
    readBy?: HelpReadStatusUncheckedCreateNestedManyWithoutHelpMessageInput
  }

  export type HelpMessageCreateOrConnectWithoutHelpInput = {
    where: HelpMessageWhereUniqueInput
    create: XOR<HelpMessageCreateWithoutHelpInput, HelpMessageUncheckedCreateWithoutHelpInput>
  }

  export type HelpMessageCreateManyHelpInputEnvelope = {
    data: HelpMessageCreateManyHelpInput | HelpMessageCreateManyHelpInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutHelperInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutHelperInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutHelperInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
  }

  export type UserCreateWithoutRequestedHelpInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutRequestedHelpInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutRequestedHelpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestedHelpInput, UserUncheckedCreateWithoutRequestedHelpInput>
  }

  export type HelpReadStatusUpsertWithWhereUniqueWithoutHelpInput = {
    where: HelpReadStatusWhereUniqueInput
    update: XOR<HelpReadStatusUpdateWithoutHelpInput, HelpReadStatusUncheckedUpdateWithoutHelpInput>
    create: XOR<HelpReadStatusCreateWithoutHelpInput, HelpReadStatusUncheckedCreateWithoutHelpInput>
  }

  export type HelpReadStatusUpdateWithWhereUniqueWithoutHelpInput = {
    where: HelpReadStatusWhereUniqueInput
    data: XOR<HelpReadStatusUpdateWithoutHelpInput, HelpReadStatusUncheckedUpdateWithoutHelpInput>
  }

  export type HelpReadStatusUpdateManyWithWhereWithoutHelpInput = {
    where: HelpReadStatusScalarWhereInput
    data: XOR<HelpReadStatusUpdateManyMutationInput, HelpReadStatusUncheckedUpdateManyWithoutHelpInput>
  }

  export type HelpMessageUpsertWithWhereUniqueWithoutHelpInput = {
    where: HelpMessageWhereUniqueInput
    update: XOR<HelpMessageUpdateWithoutHelpInput, HelpMessageUncheckedUpdateWithoutHelpInput>
    create: XOR<HelpMessageCreateWithoutHelpInput, HelpMessageUncheckedCreateWithoutHelpInput>
  }

  export type HelpMessageUpdateWithWhereUniqueWithoutHelpInput = {
    where: HelpMessageWhereUniqueInput
    data: XOR<HelpMessageUpdateWithoutHelpInput, HelpMessageUncheckedUpdateWithoutHelpInput>
  }

  export type HelpMessageUpdateManyWithWhereWithoutHelpInput = {
    where: HelpMessageScalarWhereInput
    data: XOR<HelpMessageUpdateManyMutationInput, HelpMessageUncheckedUpdateManyWithoutHelpInput>
  }

  export type UserUpsertWithoutHelperInput = {
    update: XOR<UserUpdateWithoutHelperInput, UserUncheckedUpdateWithoutHelperInput>
    create: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHelperInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHelperInput, UserUncheckedUpdateWithoutHelperInput>
  }

  export type UserUpdateWithoutHelperInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutHelperInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type UserUpsertWithoutRequestedHelpInput = {
    update: XOR<UserUpdateWithoutRequestedHelpInput, UserUncheckedUpdateWithoutRequestedHelpInput>
    create: XOR<UserCreateWithoutRequestedHelpInput, UserUncheckedCreateWithoutRequestedHelpInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestedHelpInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestedHelpInput, UserUncheckedUpdateWithoutRequestedHelpInput>
  }

  export type UserUpdateWithoutRequestedHelpInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestedHelpInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type HelpReadStatusCreateWithoutHelpMessageInput = {
    id?: string
    createdAt?: Date | string
    help: HelpCreateNestedOneWithoutHelpReadStatusInput
    user: UserCreateNestedOneWithoutHelpReadStatusInput
  }

  export type HelpReadStatusUncheckedCreateWithoutHelpMessageInput = {
    id?: string
    createdAt?: Date | string
    helpId: string
    userId: string
  }

  export type HelpReadStatusCreateOrConnectWithoutHelpMessageInput = {
    where: HelpReadStatusWhereUniqueInput
    create: XOR<HelpReadStatusCreateWithoutHelpMessageInput, HelpReadStatusUncheckedCreateWithoutHelpMessageInput>
  }

  export type HelpReadStatusCreateManyHelpMessageInputEnvelope = {
    data: HelpReadStatusCreateManyHelpMessageInput | HelpReadStatusCreateManyHelpMessageInput[]
    skipDuplicates?: boolean
  }

  export type HelpCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutHelpInput
    helper?: UserCreateNestedOneWithoutHelperInput
    requestedBy: UserCreateNestedOneWithoutRequestedHelpInput
  }

  export type HelpUncheckedCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    requestedById: string
    helperId?: string | null
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutHelpInput
  }

  export type HelpCreateOrConnectWithoutMessagesInput = {
    where: HelpWhereUniqueInput
    create: XOR<HelpCreateWithoutMessagesInput, HelpUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutHelp_messagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutHelp_messagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutHelp_messagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHelp_messagesInput, UserUncheckedCreateWithoutHelp_messagesInput>
  }

  export type HelpReadStatusUpsertWithWhereUniqueWithoutHelpMessageInput = {
    where: HelpReadStatusWhereUniqueInput
    update: XOR<HelpReadStatusUpdateWithoutHelpMessageInput, HelpReadStatusUncheckedUpdateWithoutHelpMessageInput>
    create: XOR<HelpReadStatusCreateWithoutHelpMessageInput, HelpReadStatusUncheckedCreateWithoutHelpMessageInput>
  }

  export type HelpReadStatusUpdateWithWhereUniqueWithoutHelpMessageInput = {
    where: HelpReadStatusWhereUniqueInput
    data: XOR<HelpReadStatusUpdateWithoutHelpMessageInput, HelpReadStatusUncheckedUpdateWithoutHelpMessageInput>
  }

  export type HelpReadStatusUpdateManyWithWhereWithoutHelpMessageInput = {
    where: HelpReadStatusScalarWhereInput
    data: XOR<HelpReadStatusUpdateManyMutationInput, HelpReadStatusUncheckedUpdateManyWithoutHelpMessageInput>
  }

  export type HelpUpsertWithoutMessagesInput = {
    update: XOR<HelpUpdateWithoutMessagesInput, HelpUncheckedUpdateWithoutMessagesInput>
    create: XOR<HelpCreateWithoutMessagesInput, HelpUncheckedCreateWithoutMessagesInput>
    where?: HelpWhereInput
  }

  export type HelpUpdateToOneWithWhereWithoutMessagesInput = {
    where?: HelpWhereInput
    data: XOR<HelpUpdateWithoutMessagesInput, HelpUncheckedUpdateWithoutMessagesInput>
  }

  export type HelpUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    helpReadStatus?: HelpReadStatusUpdateManyWithoutHelpNestedInput
    helper?: UserUpdateOneWithoutHelperNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRequestedHelpNestedInput
  }

  export type HelpUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: StringFieldUpdateOperationsInput | string
    helperId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutHelpNestedInput
  }

  export type UserUpsertWithoutHelp_messagesInput = {
    update: XOR<UserUpdateWithoutHelp_messagesInput, UserUncheckedUpdateWithoutHelp_messagesInput>
    create: XOR<UserCreateWithoutHelp_messagesInput, UserUncheckedCreateWithoutHelp_messagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHelp_messagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHelp_messagesInput, UserUncheckedUpdateWithoutHelp_messagesInput>
  }

  export type UserUpdateWithoutHelp_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutHelp_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type HelpCreateWithoutHelpReadStatusInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    messages?: HelpMessageCreateNestedManyWithoutHelpInput
    helper?: UserCreateNestedOneWithoutHelperInput
    requestedBy: UserCreateNestedOneWithoutRequestedHelpInput
  }

  export type HelpUncheckedCreateWithoutHelpReadStatusInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    requestedById: string
    helperId?: string | null
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
    messages?: HelpMessageUncheckedCreateNestedManyWithoutHelpInput
  }

  export type HelpCreateOrConnectWithoutHelpReadStatusInput = {
    where: HelpWhereUniqueInput
    create: XOR<HelpCreateWithoutHelpReadStatusInput, HelpUncheckedCreateWithoutHelpReadStatusInput>
  }

  export type HelpMessageCreateWithoutReadByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
    help: HelpCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutHelp_messagesInput
  }

  export type HelpMessageUncheckedCreateWithoutReadByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    helpId: string
    senderId: string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
  }

  export type HelpMessageCreateOrConnectWithoutReadByInput = {
    where: HelpMessageWhereUniqueInput
    create: XOR<HelpMessageCreateWithoutReadByInput, HelpMessageUncheckedCreateWithoutReadByInput>
  }

  export type UserCreateWithoutHelpReadStatusInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutHelpReadStatusInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutHelpReadStatusInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHelpReadStatusInput, UserUncheckedCreateWithoutHelpReadStatusInput>
  }

  export type HelpUpsertWithoutHelpReadStatusInput = {
    update: XOR<HelpUpdateWithoutHelpReadStatusInput, HelpUncheckedUpdateWithoutHelpReadStatusInput>
    create: XOR<HelpCreateWithoutHelpReadStatusInput, HelpUncheckedCreateWithoutHelpReadStatusInput>
    where?: HelpWhereInput
  }

  export type HelpUpdateToOneWithWhereWithoutHelpReadStatusInput = {
    where?: HelpWhereInput
    data: XOR<HelpUpdateWithoutHelpReadStatusInput, HelpUncheckedUpdateWithoutHelpReadStatusInput>
  }

  export type HelpUpdateWithoutHelpReadStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    messages?: HelpMessageUpdateManyWithoutHelpNestedInput
    helper?: UserUpdateOneWithoutHelperNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRequestedHelpNestedInput
  }

  export type HelpUncheckedUpdateWithoutHelpReadStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: StringFieldUpdateOperationsInput | string
    helperId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    messages?: HelpMessageUncheckedUpdateManyWithoutHelpNestedInput
  }

  export type HelpMessageUpsertWithoutReadByInput = {
    update: XOR<HelpMessageUpdateWithoutReadByInput, HelpMessageUncheckedUpdateWithoutReadByInput>
    create: XOR<HelpMessageCreateWithoutReadByInput, HelpMessageUncheckedCreateWithoutReadByInput>
    where?: HelpMessageWhereInput
  }

  export type HelpMessageUpdateToOneWithWhereWithoutReadByInput = {
    where?: HelpMessageWhereInput
    data: XOR<HelpMessageUpdateWithoutReadByInput, HelpMessageUncheckedUpdateWithoutReadByInput>
  }

  export type HelpMessageUpdateWithoutReadByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    help?: HelpUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutHelp_messagesNestedInput
  }

  export type HelpMessageUncheckedUpdateWithoutReadByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutHelpReadStatusInput = {
    update: XOR<UserUpdateWithoutHelpReadStatusInput, UserUncheckedUpdateWithoutHelpReadStatusInput>
    create: XOR<UserCreateWithoutHelpReadStatusInput, UserUncheckedCreateWithoutHelpReadStatusInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHelpReadStatusInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHelpReadStatusInput, UserUncheckedUpdateWithoutHelpReadStatusInput>
  }

  export type UserUpdateWithoutHelpReadStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutHelpReadStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    postViews?: PostViewStatusCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    postViews?: PostViewStatusUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type PostCreateWithoutViewStatusInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    total_likes?: number
    total_comments?: number
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentCreateNestedManyWithoutPostInput
    user: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutViewStatusInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    userId: string
    total_likes?: number
    total_comments?: number
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    mediaAttachments?: MediaAttachmentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutViewStatusInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutViewStatusInput, PostUncheckedCreateWithoutViewStatusInput>
  }

  export type UserCreateWithoutPostViewsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageCreateNestedManyWithoutSenderInput
    friends1?: FriendshipCreateNestedManyWithoutUser1Input
    friends2?: FriendshipCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageCreateNestedManyWithoutSenderInput
    helper?: HelpCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    deviceTokens?: UserDeviceTokenCreateNestedManyWithoutUserInput
    moods?: UserMoodCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomCreateNestedManyWithoutMembersInput
  }

  export type UserUncheckedCreateWithoutPostViewsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    username: string
    phone: string
    password: string
    userType?: $Enums.UserType
    local?: string | null
    firstName: string
    lastName: string
    profilePicture?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    schoolName?: string | null
    className?: string | null
    teacherName?: string | null
    isVerified?: boolean
    isBlocked?: boolean
    isOnline?: boolean
    isDeleted?: boolean
    isHelping?: boolean
    Aliyun_token?: string | null
    device_type?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    helpReadStatus?: HelpReadStatusUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    chatroomMessage?: ChatroomMessageUncheckedCreateNestedManyWithoutSenderInput
    friends1?: FriendshipUncheckedCreateNestedManyWithoutUser1Input
    friends2?: FriendshipUncheckedCreateNestedManyWithoutUser2Input
    help_messages?: HelpMessageUncheckedCreateNestedManyWithoutSenderInput
    helper?: HelpUncheckedCreateNestedManyWithoutHelperInput
    requestedHelp?: HelpUncheckedCreateNestedManyWithoutRequestedByInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    deviceTokens?: UserDeviceTokenUncheckedCreateNestedManyWithoutUserInput
    moods?: UserMoodUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    chatrooms?: ChatroomUncheckedCreateNestedManyWithoutMembersInput
  }

  export type UserCreateOrConnectWithoutPostViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostViewsInput, UserUncheckedCreateWithoutPostViewsInput>
  }

  export type PostUpsertWithoutViewStatusInput = {
    update: XOR<PostUpdateWithoutViewStatusInput, PostUncheckedUpdateWithoutViewStatusInput>
    create: XOR<PostCreateWithoutViewStatusInput, PostUncheckedCreateWithoutViewStatusInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutViewStatusInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutViewStatusInput, PostUncheckedUpdateWithoutViewStatusInput>
  }

  export type PostUpdateWithoutViewStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUpdateManyWithoutPostNestedInput
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutViewStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutPostViewsInput = {
    update: XOR<UserUpdateWithoutPostViewsInput, UserUncheckedUpdateWithoutPostViewsInput>
    create: XOR<UserCreateWithoutPostViewsInput, UserUncheckedCreateWithoutPostViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostViewsInput, UserUncheckedUpdateWithoutPostViewsInput>
  }

  export type UserUpdateWithoutPostViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUpdateManyWithoutMembersNestedInput
  }

  export type UserUncheckedUpdateWithoutPostViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    chatrooms?: ChatroomUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type CommentCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    text: string
    postId: string
  }

  export type HelpReadStatusCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    helpId: string
    helpMessageId?: string | null
  }

  export type LikeCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
  }

  export type PostCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    is_anonymous?: boolean
    text?: string | null
    mood?: string | null
    total_likes?: number
    total_comments?: number
  }

  export type ChatroomMessageCreateManySenderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatroomId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    reply_id?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
  }

  export type FriendshipCreateManyUser1Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.FriendshipStatus
    user2Id: string
  }

  export type FriendshipCreateManyUser2Input = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.FriendshipStatus
    user1Id: string
  }

  export type HelpMessageCreateManySenderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    helpId: string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
  }

  export type HelpCreateManyHelperInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    requestedById: string
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
  }

  export type HelpCreateManyRequestedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string
    helperId?: string | null
    status?: $Enums.HelpStatus
    locationLat?: number | null
    locationLng?: number | null
    address?: string | null
    isDeleted?: boolean
  }

  export type notificationsCreateManyUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    type: string
    content: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostViewStatusCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    lastViewedAt: Date | string
  }

  export type UserDeviceTokenCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
    device_type: string
  }

  export type UserMoodCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mood: $Enums.UserMoodType
    note?: string | null
  }

  export type UserSessionCreateManyUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type HelpReadStatusUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    help?: HelpUpdateOneRequiredWithoutHelpReadStatusNestedInput
    helpMessage?: HelpMessageUpdateOneWithoutReadByNestedInput
  }

  export type HelpReadStatusUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    helpMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelpReadStatusUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    helpMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type LikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUpdateManyWithoutPostNestedInput
    viewStatus?: PostViewStatusUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    mediaAttachments?: MediaAttachmentUncheckedUpdateManyWithoutPostNestedInput
    viewStatus?: PostViewStatusUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    total_likes?: IntFieldUpdateOperationsInput | number
    total_comments?: IntFieldUpdateOperationsInput | number
  }

  export type ChatroomMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUpdateManyWithoutMessageNestedInput
    chatroom?: ChatroomUpdateOneRequiredWithoutMessagesNestedInput
    reply?: ChatroomMessageUpdateOneWithoutChat_messageNestedInput
    chat_message?: ChatroomMessageUpdateManyWithoutReplyNestedInput
  }

  export type ChatroomMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUncheckedUpdateManyWithoutMessageNestedInput
    chat_message?: ChatroomMessageUncheckedUpdateManyWithoutReplyNestedInput
  }

  export type ChatroomMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FriendshipUpdateWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    user2?: UserUpdateOneRequiredWithoutFriends2NestedInput
  }

  export type FriendshipUncheckedUpdateWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    user2Id?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipUncheckedUpdateManyWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    user2Id?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipUpdateWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    user1?: UserUpdateOneRequiredWithoutFriends1NestedInput
  }

  export type FriendshipUncheckedUpdateWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    user1Id?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipUncheckedUpdateManyWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    user1Id?: StringFieldUpdateOperationsInput | string
  }

  export type HelpMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: HelpReadStatusUpdateManyWithoutHelpMessageNestedInput
    help?: HelpUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type HelpMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: HelpReadStatusUncheckedUpdateManyWithoutHelpMessageNestedInput
  }

  export type HelpMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelpUpdateWithoutHelperInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    helpReadStatus?: HelpReadStatusUpdateManyWithoutHelpNestedInput
    messages?: HelpMessageUpdateManyWithoutHelpNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRequestedHelpNestedInput
  }

  export type HelpUncheckedUpdateWithoutHelperInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: StringFieldUpdateOperationsInput | string
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutHelpNestedInput
    messages?: HelpMessageUncheckedUpdateManyWithoutHelpNestedInput
  }

  export type HelpUncheckedUpdateManyWithoutHelperInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: StringFieldUpdateOperationsInput | string
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HelpUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    helpReadStatus?: HelpReadStatusUpdateManyWithoutHelpNestedInput
    messages?: HelpMessageUpdateManyWithoutHelpNestedInput
    helper?: UserUpdateOneWithoutHelperNestedInput
  }

  export type HelpUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helperId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutHelpNestedInput
    messages?: HelpMessageUncheckedUpdateManyWithoutHelpNestedInput
  }

  export type HelpUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helperId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumHelpStatusFieldUpdateOperationsInput | $Enums.HelpStatus
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificationsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type notificationsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type notificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostViewStatusUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutViewStatusNestedInput
  }

  export type PostViewStatusUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewStatusUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    device_type?: StringFieldUpdateOperationsInput | string
  }

  export type UserDeviceTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    device_type?: StringFieldUpdateOperationsInput | string
  }

  export type UserDeviceTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    device_type?: StringFieldUpdateOperationsInput | string
  }

  export type UserMoodUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: EnumUserMoodTypeFieldUpdateOperationsInput | $Enums.UserMoodType
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserMoodUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: EnumUserMoodTypeFieldUpdateOperationsInput | $Enums.UserMoodType
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserMoodUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: EnumUserMoodTypeFieldUpdateOperationsInput | $Enums.UserMoodType
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type ChatroomUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readStatuses?: ChatroomReadStatusUpdateManyWithoutChatroomNestedInput
    messages?: ChatroomMessageUpdateManyWithoutChatroomNestedInput
  }

  export type ChatroomUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readStatuses?: ChatroomReadStatusUncheckedUpdateManyWithoutChatroomNestedInput
    messages?: ChatroomMessageUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type ChatroomUncheckedUpdateManyWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatroomReadStatusCreateManyChatroomInput = {
    id?: string
    userId: string
    messageId: string
    createdAt?: Date | string
  }

  export type ChatroomMessageCreateManyChatroomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    reply_id?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
  }

  export type ChatroomReadStatusUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: ChatroomMessageUpdateOneRequiredWithoutReadByNestedInput
  }

  export type ChatroomReadStatusUncheckedUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatroomReadStatusUncheckedUpdateManyWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatroomMessageUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUpdateManyWithoutMessageNestedInput
    reply?: ChatroomMessageUpdateOneWithoutChat_messageNestedInput
    chat_message?: ChatroomMessageUpdateManyWithoutReplyNestedInput
    sender?: UserUpdateOneRequiredWithoutChatroomMessageNestedInput
  }

  export type ChatroomMessageUncheckedUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUncheckedUpdateManyWithoutMessageNestedInput
    chat_message?: ChatroomMessageUncheckedUpdateManyWithoutReplyNestedInput
  }

  export type ChatroomMessageUncheckedUpdateManyWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutChatroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUpdateManyWithoutSenderNestedInput
    helper?: HelpUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUpdateManyWithoutUserNestedInput
    moods?: UserMoodUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    helpReadStatus?: HelpReadStatusUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    chatroomMessage?: ChatroomMessageUncheckedUpdateManyWithoutSenderNestedInput
    friends1?: FriendshipUncheckedUpdateManyWithoutUser1NestedInput
    friends2?: FriendshipUncheckedUpdateManyWithoutUser2NestedInput
    help_messages?: HelpMessageUncheckedUpdateManyWithoutSenderNestedInput
    helper?: HelpUncheckedUpdateManyWithoutHelperNestedInput
    requestedHelp?: HelpUncheckedUpdateManyWithoutRequestedByNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    postViews?: PostViewStatusUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: UserDeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    moods?: UserMoodUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutChatroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    local?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    teacherName?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHelping?: BoolFieldUpdateOperationsInput | boolean
    Aliyun_token?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatroomReadStatusCreateManyMessageInput = {
    id?: string
    chatroomId: string
    userId: string
    createdAt?: Date | string
  }

  export type ChatroomMessageCreateManyReplyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatroomId: string
    senderId: string
    message: string
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    call_message_status?: $Enums.CallMessageStatus | null
    isDeleted?: boolean
    payload?: string | null
  }

  export type ChatroomReadStatusUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom?: ChatroomUpdateOneRequiredWithoutReadStatusesNestedInput
  }

  export type ChatroomReadStatusUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatroomReadStatusUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatroomMessageUpdateWithoutReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUpdateManyWithoutMessageNestedInput
    chatroom?: ChatroomUpdateOneRequiredWithoutMessagesNestedInput
    chat_message?: ChatroomMessageUpdateManyWithoutReplyNestedInput
    sender?: UserUpdateOneRequiredWithoutChatroomMessageNestedInput
  }

  export type ChatroomMessageUncheckedUpdateWithoutReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: ChatroomReadStatusUncheckedUpdateManyWithoutMessageNestedInput
    chat_message?: ChatroomMessageUncheckedUpdateManyWithoutReplyNestedInput
  }

  export type ChatroomMessageUncheckedUpdateManyWithoutReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    call_message_status?: NullableEnumCallMessageStatusFieldUpdateOperationsInput | $Enums.CallMessageStatus | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    payload?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    text: string
    userId: string
  }

  export type LikeCreateManyPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type MediaAttachmentCreateManyPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
  }

  export type PostViewStatusCreateManyPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    lastViewedAt: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LikeUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LikeUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaAttachmentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MediaAttachmentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MediaAttachmentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PostViewStatusUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPostViewsNestedInput
  }

  export type PostViewStatusUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostViewStatusUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpReadStatusCreateManyHelpInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    helpMessageId?: string | null
  }

  export type HelpMessageCreateManyHelpInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    message?: string | null
    status?: $Enums.ChatroomMessageStatus
    type?: $Enums.ChatroomMessageType
    file?: string | null
    locationLat?: number | null
    locationLng?: number | null
    isDeleted?: boolean
    reply_id?: string | null
  }

  export type HelpReadStatusUpdateWithoutHelpInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpMessage?: HelpMessageUpdateOneWithoutReadByNestedInput
    user?: UserUpdateOneRequiredWithoutHelpReadStatusNestedInput
  }

  export type HelpReadStatusUncheckedUpdateWithoutHelpInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    helpMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelpReadStatusUncheckedUpdateManyWithoutHelpInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    helpMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelpMessageUpdateWithoutHelpInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: HelpReadStatusUpdateManyWithoutHelpMessageNestedInput
    sender?: UserUpdateOneRequiredWithoutHelp_messagesNestedInput
  }

  export type HelpMessageUncheckedUpdateWithoutHelpInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
    readBy?: HelpReadStatusUncheckedUpdateManyWithoutHelpMessageNestedInput
  }

  export type HelpMessageUncheckedUpdateManyWithoutHelpInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatroomMessageStatusFieldUpdateOperationsInput | $Enums.ChatroomMessageStatus
    type?: EnumChatroomMessageTypeFieldUpdateOperationsInput | $Enums.ChatroomMessageType
    file?: NullableStringFieldUpdateOperationsInput | string | null
    locationLat?: NullableFloatFieldUpdateOperationsInput | number | null
    locationLng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    reply_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelpReadStatusCreateManyHelpMessageInput = {
    id?: string
    createdAt?: Date | string
    helpId: string
    userId: string
  }

  export type HelpReadStatusUpdateWithoutHelpMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    help?: HelpUpdateOneRequiredWithoutHelpReadStatusNestedInput
    user?: UserUpdateOneRequiredWithoutHelpReadStatusNestedInput
  }

  export type HelpReadStatusUncheckedUpdateWithoutHelpMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type HelpReadStatusUncheckedUpdateManyWithoutHelpMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatroomCountOutputTypeDefaultArgs instead
     */
    export type ChatroomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatroomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatroomMessageCountOutputTypeDefaultArgs instead
     */
    export type ChatroomMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatroomMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpCountOutputTypeDefaultArgs instead
     */
    export type HelpCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpMessageCountOutputTypeDefaultArgs instead
     */
    export type HelpMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDeviceTokenDefaultArgs instead
     */
    export type UserDeviceTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDeviceTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSessionDefaultArgs instead
     */
    export type UserSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserMoodDefaultArgs instead
     */
    export type UserMoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserMoodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FriendshipDefaultArgs instead
     */
    export type FriendshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FriendshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatroomDefaultArgs instead
     */
    export type ChatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatroomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatroomMessageDefaultArgs instead
     */
    export type ChatroomMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatroomMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatroomReadStatusDefaultArgs instead
     */
    export type ChatroomReadStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatroomReadStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaAttachmentDefaultArgs instead
     */
    export type MediaAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LikeDefaultArgs instead
     */
    export type LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpDefaultArgs instead
     */
    export type HelpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpMessageDefaultArgs instead
     */
    export type HelpMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpReadStatusDefaultArgs instead
     */
    export type HelpReadStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpReadStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationsDefaultArgs instead
     */
    export type notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostViewStatusDefaultArgs instead
     */
    export type PostViewStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostViewStatusDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}